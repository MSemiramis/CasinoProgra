"use strict";
var __assign = (this && this.__assign)/* istanbul ignore next */ || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var typescript_1 = require("../../typescript");
var textManipulators_1 = require("../textManipulators");
var nodeHandlers_1 = require("../nodeHandlers");
var doManipulation_1 = require("./doManipulation");
var helpers_1 = require("../helpers");
function insertSyntaxList(opts) {
    var insertPos = opts.insertPos, newText = opts.newText, parent = opts.parent;
    doManipulation_1.doManipulation(parent.sourceFile, new textManipulators_1.InsertionTextManipulator({
        insertPos: insertPos,
        newText: newText
    }), new nodeHandlers_1.NodeHandlerFactory().getForCreatingSyntaxList({
        parent: parent,
        insertPos: insertPos
    }));
}
exports.insertSyntaxList = insertSyntaxList;
/**
 * Inserts a text range into a parent.
 */
function insertIntoParentTextRange(opts) {
    var insertPos = opts.insertPos, newText = opts.newText, parent = opts.parent;
    // todo: this should only forget the existing node if the kind changes
    doManipulation_1.doManipulation(parent.sourceFile, new textManipulators_1.InsertionTextManipulator({
        insertPos: insertPos,
        newText: newText,
        replacingLength: opts.replacing == null ? undefined : opts.replacing.textLength
    }), new nodeHandlers_1.NodeHandlerFactory().getForRange({
        parent: parent,
        start: insertPos,
        end: insertPos + newText.length,
        replacingLength: opts.replacing == null ? undefined : opts.replacing.textLength,
        replacingNodes: opts.replacing == null ? undefined : opts.replacing.nodes,
        customMappings: opts.customMappings
    }));
}
exports.insertIntoParentTextRange = insertIntoParentTextRange;
function insertIntoCreatableSyntaxList(opts) {
    var insertPos = opts.insertPos, newText = opts.newText, parent = opts.parent, syntaxList = opts.syntaxList;
    if (syntaxList == null)
        insertSyntaxList({
            parent: parent,
            insertPos: insertPos,
            newText: newText
        });
    else
        insertIntoParentTextRange({
            insertPos: insertPos,
            newText: newText,
            parent: syntaxList
        });
}
exports.insertIntoCreatableSyntaxList = insertIntoCreatableSyntaxList;
function insertIntoCommaSeparatedNodes(opts) {
    // todo: this needs to be fixed/cleaned up in the future, but this is good enough for now
    var currentNodes = opts.currentNodes, insertIndex = opts.insertIndex, newTexts = opts.newTexts, parent = opts.parent;
    var nextNode = currentNodes[insertIndex];
    var previousNode = currentNodes[insertIndex - 1];
    var numberOfSyntaxListItemsInserting = newTexts.length * 2 - 1;
    var separator = opts.useNewLines ? parent.global.manipulationSettings.getNewLineKindAsString() : " ";
    var childIndentationText = parent.getParentOrThrow().getChildIndentationText();
    var parentNextSibling = parent.getNextSibling();
    var isContained = parentNextSibling != null && (parentNextSibling.getKind() === typescript_1.SyntaxKind.CloseBraceToken || parentNextSibling.getKind() === typescript_1.SyntaxKind.CloseBracketToken);
    var newText = newTexts.join("," + separator);
    if (previousNode != null) {
        var nextEndStart = nextNode == null ? (isContained ? parentNextSibling.getStart(true) : parent.getEnd()) : nextNode.getStart(true);
        var insertPos = previousNode.getEnd();
        newText = "," + separator + newText;
        if (nextNode != null) {
            newText += "," + separator;
            if (opts.useNewLines)
                newText += childIndentationText;
        }
        else if (opts.useNewLines)
            newText += separator + parent.getParentOrThrow().getIndentationText();
        insertIntoParentTextRange({
            insertPos: insertPos,
            newText: newText,
            parent: parent,
            replacing: { textLength: nextEndStart - insertPos }
        });
    }
    else if (nextNode != null) {
        if (opts.useNewLines)
            newText = separator + newText;
        newText += "," + separator;
        if (opts.useNewLines)
            newText += childIndentationText;
        var insertPos = isContained ? parent.getPos() : parent.getStart(true);
        insertIntoParentTextRange({
            insertPos: insertPos,
            newText: newText,
            parent: parent,
            replacing: { textLength: nextNode.getStart(true) - insertPos }
        });
    }
    else {
        if (opts.useNewLines)
            newText = separator + newText + parent.global.manipulationSettings.getNewLineKindAsString() + parent.getParentOrThrow().getIndentationText();
        insertIntoParentTextRange({
            insertPos: parent.getPos(),
            newText: newText,
            parent: parent,
            replacing: { textLength: parent.getNextSiblingOrThrow().getStart() - parent.getPos() }
        });
    }
}
exports.insertIntoCommaSeparatedNodes = insertIntoCommaSeparatedNodes;
/**
 * Used to insert non-comma separated nodes into braces or a source file.
 */
function insertIntoBracesOrSourceFile(opts) {
    var parent = opts.parent, index = opts.index, childCodes = opts.childCodes, separator = opts.separator, children = opts.children;
    if (childCodes.length === 0)
        return;
    doManipulation_1.doManipulation(parent.sourceFile, new textManipulators_1.InsertIntoBracesTextManipulator(opts), new nodeHandlers_1.NodeHandlerFactory().getForChildIndex({
        parent: parent.getChildSyntaxListOrThrow(),
        childIndex: index,
        childCount: childCodes.length
    }));
}
exports.insertIntoBracesOrSourceFile = insertIntoBracesOrSourceFile;
/**
 * Glues together insertIntoBracesOrSourceFile and fillAndGetChildren.
 * @param opts - Options to do this operation.
 */
function insertIntoBracesOrSourceFileWithFillAndGetChildren(opts) {
    if (opts.structures.length === 0)
        return [];
    var startChildren = opts.getIndexedChildren();
    var parentSyntaxList = opts.parent.getChildSyntaxListOrThrow();
    var index = helpers_1.verifyAndGetIndex(opts.index, startChildren.length);
    var childIndex = getChildIndex();
    insertIntoBracesOrSourceFile(__assign({}, opts, { children: parentSyntaxList.getChildren(), separator: opts.sourceFile.global.manipulationSettings.getNewLineKindAsString(), index: childIndex }));
    return helpers_1.fillAndGetChildren(__assign({}, opts, { allChildren: opts.getIndexedChildren(), index: index }));
    function getChildIndex() {
        if (index === 0)
            return 0;
        // get the previous member in order to get the implementation signature + 1
        return startChildren[index - 1].getChildIndex() + 1;
    }
}
exports.insertIntoBracesOrSourceFileWithFillAndGetChildren = insertIntoBracesOrSourceFileWithFillAndGetChildren;
