"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Code Verification - Ensure Overload Structures Match.
 * -----------------------------------------------------
 * When a developer adds another interface to a structure like MethodDeclaration (ex. ScopableNodeStructure),
 * then we need to ensure that same structure was also added to MethodOverloadDeclaration.
 *
 * This code verification ensures that an overload structure matches its "implementation" structure.
 * -----------------------------------------------------
 */
var utils_1 = require("../src/utils");
var inspectors_1 = require("./inspectors");
// setup
var factory = new inspectors_1.InspectorFactory();
var inspector = factory.getTsSimpleAstInspector();
// get structures
var structures = inspector.getStructures();
var overloadStructures = inspector.getOverloadStructures();
// find the problems
var problems = [];
var _loop_1 = function (overloadStructure) {
    var structureName = overloadStructure.getName().replace("Overload", "");
    var structure = utils_1.ArrayUtils.find(structures, function (s) { return s.getName() === structureName; });
    if (structure == null)
        throw new Error("Could not find structure for overload: " + overloadStructure.getName());
    var overloadBaseStructures = overloadStructure.getDescendantBaseStructures();
    var structureBaseStructures = structure.getDescendantBaseStructures().filter(function (s) { return isAllowedStructure(s); });
    for (var i = overloadBaseStructures.length - 1; i >= 0; i--) {
        var findIndex = structureBaseStructures.map(function (s) { return s.getName(); }).indexOf(overloadBaseStructures[i].getName());
        if (findIndex >= 0) {
            overloadBaseStructures.splice(i, 1);
            structureBaseStructures.splice(findIndex, 1);
        }
    }
    try {
        for (var overloadBaseStructures_1 = __values(overloadBaseStructures), overloadBaseStructures_1_1 = overloadBaseStructures_1.next(); !overloadBaseStructures_1_1.done; overloadBaseStructures_1_1 = overloadBaseStructures_1.next()) {
            var remainingOverload = overloadBaseStructures_1_1.value;
            problems.push(overloadStructure.getName() + ": Overload extension of " + remainingOverload.getName() + " does not exist on main structure.");
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (overloadBaseStructures_1_1 && !overloadBaseStructures_1_1.done && (_a = overloadBaseStructures_1.return)) _a.call(overloadBaseStructures_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    try {
        for (var structureBaseStructures_1 = __values(structureBaseStructures), structureBaseStructures_1_1 = structureBaseStructures_1.next(); !structureBaseStructures_1_1.done; structureBaseStructures_1_1 = structureBaseStructures_1.next()) {
            var remainingStructure = structureBaseStructures_1_1.value;
            problems.push(overloadStructure.getName() + ": Structure extension of " + remainingStructure.getName() + " does not exist on overload structure.");
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (structureBaseStructures_1_1 && !structureBaseStructures_1_1.done && (_b = structureBaseStructures_1.return)) _b.call(structureBaseStructures_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    var e_1, _a, e_2, _b;
};
try {
    for (var overloadStructures_1 = __values(overloadStructures), overloadStructures_1_1 = overloadStructures_1.next(); !overloadStructures_1_1.done; overloadStructures_1_1 = overloadStructures_1.next()) {
        var overloadStructure = overloadStructures_1_1.value;
        _loop_1(overloadStructure);
    }
}
catch (e_3_1) { e_3 = { error: e_3_1 }; }
finally {
    try {
        if (overloadStructures_1_1 && !overloadStructures_1_1.done && (_a = overloadStructures_1.return)) _a.call(overloadStructures_1);
    }
    finally { if (e_3) throw e_3.error; }
}
// output
if (problems.length > 0) {
    console.log(problems);
    throw new Error("Overload structure did not match main structure!");
}
function isAllowedStructure(structure) {
    switch (structure.getName()) {
        case "NamedNodeStructure":
        case "PropertyNamedNodeStructure":
        case "FunctionLikeDeclarationStructure":
        case "BodiedNodeStructure":
        case "BodyableNodeStructure":
        case "StatementedNodeStructure":
            return false;
    }
    if (structure.getName().indexOf("SpecificStructure") > 0)
        return false;
    return true;
}
var e_3, _a;
