"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Code Analysis - Output wrapped nodes info.
 * ------------------------------------------
 * This outputs information into wrapped-nodes.md saying what nodes have been wrapped and which ones haven't been.
 *
 * In the future, this should check which properites in the compiler haven't been used in this library by doing a "find references" on
 * all the compiler node properties.
 * ------------------------------------------
 */
var path = require("path");
var fs = require("fs");
var config_1 = require("./config");
var inspectors_1 = require("./inspectors");
// setup
var inspectorFactory = new inspectors_1.InspectorFactory();
var tsInspector = inspectorFactory.getTsInspector();
// get info
var tsNodes = tsInspector.getTsNodes();
// figure out ts nodes that are wrapped and not wrapped
var wrappedTsNodes = tsNodes.filter(function (i) { return i.getAssociatedWrappedNode() != null || isImplementedViaMixins(i); });
var notWrappedTsNodes = tsNodes.filter(function (i) { return wrappedTsNodes.indexOf(i) === -1 && !isIgnoredNode(i); });
// output the results (todo: use a template for the output)
var output = "# Wrapped Nodes\n\n" +
    "This file is automatically generated and shows which nodes have been wrapped or not. " +
    "More information will be added to this in the future.\n\n" +
    "The disadvantage to a node not being wrapped is that it won't have helper methods for navigation and manipulationâ€”it will be still " +
    "be wrapped as a `Node`. " +
    "If you would like a node to be wrapped, then please open up an issue and I will give it priority. " +
    "Otherwise they will continue to be slowly wrapped over time.\n\n";
outputCoverage("Exist", wrappedTsNodes);
output += "\n";
outputCoverage("Not Exist", notWrappedTsNodes);
fs.writeFileSync(path.join(config_1.rootFolder, "wrapped-nodes.md"), output);
// play a tone to indicate it's done
console.log("\x07");
function outputCoverage(header, tsNodesForOutput, additionalText) {
    output += "## " + header + "\n\n";
    if (additionalText != null)
        output += additionalText + "\n\n";
    output += "**Total:** " + tsNodesForOutput.length + "\n\n";
    try {
        for (var tsNodesForOutput_1 = __values(tsNodesForOutput), tsNodesForOutput_1_1 = tsNodesForOutput_1.next(); !tsNodesForOutput_1_1.done; tsNodesForOutput_1_1 = tsNodesForOutput_1.next()) {
            var tsNode = tsNodesForOutput_1_1.value;
            console.log("Examining: " + tsNode.getName());
            var wrappedNode = tsNode.getAssociatedWrappedNode();
            if (wrappedNode == null)
                output += "* " + tsNode.getName();
            else
                output += "* [" + tsNode.getName() + "](" + getRelativePath(wrappedNode.getFilePath()) + ")";
            output += isImplementedViaMixins(tsNode) ? " - Implemented via mixin." : "";
            output += "\n";
            if (wrappedNode != null) {
                var properties = tsNode.getProperties();
                try {
                    for (var properties_1 = __values(properties), properties_1_1 = properties_1.next(); !properties_1_1.done; properties_1_1 = properties_1.next()) {
                        var prop = properties_1_1.value;
                        if (!isPropertyToIgnore(prop))
                            outputProperty(prop);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (properties_1_1 && !properties_1_1.done && (_a = properties_1.return)) _a.call(properties_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (tsNodesForOutput_1_1 && !tsNodesForOutput_1_1.done && (_b = tsNodesForOutput_1.return)) _b.call(tsNodesForOutput_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    function outputProperty(prop) {
        output += "    * " + (prop.isReferenced() ? ":heavy_check_mark:" : ":x:") + " " + prop.getName() + "\n";
    }
    var e_2, _b, e_1, _a;
}
// config
function isPropertyToIgnore(prop) {
    return prop.getName() === "kind" ||
        prop.getName() === "parent" ||
        prop.getName()[0] === "_";
}
function isIgnoredNode(node) {
    switch (node.getName()) {
        // this would be implemented via a mixin
        case "Declaration":
            return true;
        default:
            return false;
    }
}
function isImplementedViaMixins(node) {
    switch (node.getName()) {
        case "NamedDeclaration":
        case "FunctionLikeDeclarationBase":
        case "SignatureDeclarationBase":
            return true;
        default:
            return false;
    }
}
function getRelativePath(absolutePath) {
    var index = absolutePath.indexOf("src/compiler");
    if (index === -1)
        throw new Error("Unexpected path: " + absolutePath);
    return absolutePath.substring(index);
}
