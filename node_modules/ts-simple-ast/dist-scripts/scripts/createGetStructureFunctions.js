"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Code generation: Create "get structure" functions
 * -------------------------------------------------
 * This file generations the functions found in getStructureFunctions.ts
 *
 * Right now these are only used to get the structure for populating new overloads. This code needs a lot of work and
 * might be used to implement issue #45 (if it's decided that should be implemented).
 * -------------------------------------------------
 */
var code_block_writer_1 = require("code-block-writer");
var fs = require("fs");
var path = require("path");
var config_1 = require("./config");
// todo: a lot of this code was written before this library supported manipulation
function createGetStructureFunctions(structures) {
    var writer = new code_block_writer_1.default();
    writer.writeLine("/* tslint:disable */");
    writer.writeLine("// DO NOT MANUALLY EDIT!! File generated via: npm run code-generate").newLine();
    writer.writeLine("import * as objectAssign from \"object-assign\";");
    writer.writeLine("import * as compiler from \"../../compiler\";");
    writer.writeLine("import * as structures from \"../../structures\";");
    writer.writeLine("import * as getMixinStructureFuncs from \"./getMixinStructureFunctions\";");
    try {
        for (var _a = __values(structures.filter(function (s) { return shouldCreateForStructure(s.getName()); })), _b = _a.next(); !_b.done; _b = _a.next()) {
            var structure = _b.value;
            writer.newLine();
            write(writer, structure);
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
        }
        finally { if (e_1) throw e_1.error; }
    }
    fs.writeFileSync(path.join(config_1.rootFolder, "src/manipulation/helpers/getStructureFunctions.ts"), writer.toString(), { encoding: "utf-8" });
    var e_1, _c;
}
exports.createGetStructureFunctions = createGetStructureFunctions;
// todo: make this better... good enough for now
// for example, it would be better to be able to get the structure from a node and specify what structures to ignore when calling it... that way the logic could be kept inside
// the application and not here (basically... have a fromFunctionDeclaration(node, [nameof(ParameteredNodeStructure)]);)
function write(writer, structure) {
    var className = structure.getName().replace(/Structure$/, "");
    var functionHeader = "export function from" + className + "(node: compiler." + className.replace("Overload", "") + "): structures." + structure.getName();
    writer.write(functionHeader).block(function () {
        writeBody(writer, structure, structure.getDescendantBaseStructures().filter(function (b) { return shouldAllowExtends(structure, b); }));
    });
}
function writeBody(writer, structure, baseStructures) {
    writer.writeLine("let structure: structures." + structure.getName() + " = {} as any;");
    try {
        for (var baseStructures_1 = __values(baseStructures), baseStructures_1_1 = baseStructures_1.next(); !baseStructures_1_1.done; baseStructures_1_1 = baseStructures_1.next()) {
            var extendsStructure = baseStructures_1_1.value;
            writer.write("objectAssign(structure, ");
            writer.write("getMixinStructureFuncs.");
            var extendsClassName = extendsStructure.getName().replace(/Structure$/, "");
            writer.write("from" + extendsClassName + "(node));").newLine();
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (baseStructures_1_1 && !baseStructures_1_1.done && (_a = baseStructures_1.return)) _a.call(baseStructures_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    writer.writeLine("return structure;");
    var e_2, _a;
}
function shouldCreateForStructure(name) {
    switch (name) {
        case "FunctionDeclarationOverloadStructure":
        case "MethodDeclarationOverloadStructure":
        case "ConstructorDeclarationOverloadStructure":
            return true;
        default:
            return false;
    }
}
function shouldAllowExtends(structure, baseStructure) {
    if (structure.getName() === "FunctionDeclarationOverloadStructure") {
        switch (baseStructure.getName()) {
            case "ParameteredNodeStructure":
            case "TypeParameteredNodeStructure":
            case "JSDocableNodeStructure":
            case "SignaturedDeclarationStructure":
            case "ReturnTypedNodeStructure":
            case "GeneratorableNodeStructure":
            case "AsyncableNodeStructure":
                return false;
            default:
                return true;
        }
    }
    else if (structure.getName() === "MethodDeclarationOverloadStructure") {
        switch (baseStructure.getName()) {
            case "ParameteredNodeStructure":
            case "TypeParameteredNodeStructure":
            case "JSDocableNodeStructure":
            case "SignaturedDeclarationStructure":
            case "ReturnTypedNodeStructure":
            case "GeneratorableNodeStructure":
            case "AsyncableNodeStructure":
            case "DecoratableNodeStructure":
                return false;
            default:
                return true;
        }
    }
    else if (structure.getName() === "ConstructorDeclarationOverloadStructure") {
        switch (baseStructure.getName()) {
            case "ParameteredNodeStructure":
            case "TypeParameteredNodeStructure":
            case "JSDocableNodeStructure":
            case "SignaturedDeclarationStructure":
            case "ReturnTypedNodeStructure":
                return false;
            default:
                return true;
        }
    }
    return true;
}
