"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var main_1 = require("../../src/main");
// todo: in the future this should be done in the library (ex. node.addInterface(cloningInterface.getStructure()))
// What's done here is not so great...
function cloneNamespaces(node, cloningNamespaces) {
    var namespaces = node.addNamespaces(cloningNamespaces.map(function (n) { return ({
        isExported: true,
        hasDeclareKeyword: true,
        name: n.getName()
    }); }));
    for (var i = 0; i < cloningNamespaces.length; i++) {
        cloneInterfaces(namespaces[i], cloningNamespaces[i].getInterfaces());
        cloneClasses(namespaces[i], cloningNamespaces[i].getClasses());
        cloneFunctions(namespaces[i], cloningNamespaces[i].getFunctions());
        cloneEnums(namespaces[i], cloningNamespaces[i].getEnums());
        cloneVariables(namespaces[i], cloningNamespaces[i].getVariableStatements());
        cloneTypeAliases(namespaces[i], cloningNamespaces[i].getTypeAliases());
        try {
            // bad... will be fixed when moving towards using getStructure() functions
            for (var _a = __values(namespaces[i].getStatements()), _b = _a.next(); !_b.done; _b = _a.next()) {
                var statement = _b.value;
                if (main_1.TypeGuards.isAmbientableNode(statement))
                    statement.setHasDeclareKeyword(false);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    var e_1, _c;
}
exports.cloneNamespaces = cloneNamespaces;
function cloneInterfaces(node, cloningInterfaces) {
    node.addInterfaces(cloningInterfaces.map(function (cloningInterface) { return ({
        isExported: true,
        name: cloningInterface.getName(),
        typeParameters: cloningInterface.getTypeParameters().map(function (p) { return ({
            name: p.getName(),
            constraint: p.getConstraintNode() == null ? undefined : p.getConstraintNode().getText()
        }); }),
        extends: cloningInterface.getExtends().map(function (e) { return e.getText(); }),
        docs: cloningInterface.getJsDocs().map(function (d) { return ({ description: d.getInnerText() }); }),
        properties: cloningInterface.getProperties().map(function (nodeProp) { return ({
            name: nodeProp.getName(),
            type: nodeProp.getTypeNodeOrThrow().getText(),
            hasQuestionToken: nodeProp.hasQuestionToken(),
            docs: nodeProp.getJsDocs().map(function (d) { return ({ description: d.getInnerText().replace(/\r?\n/g, "\r\n") }); })
        }); }),
        methods: cloningInterface.getMethods().map(function (method) { return ({
            name: method.getName(),
            hasQuestionToken: method.hasQuestionToken(),
            returnType: method.getReturnTypeNodeOrThrow().getText(),
            docs: method.getJsDocs().map(function (d) { return ({ description: d.getInnerText().replace(/\r?\n/g, "\r\n") }); }),
            typeParameters: method.getTypeParameters().map(function (p) { return ({
                name: p.getName(),
                constraint: p.getConstraintNode() == null ? undefined : p.getConstraintNode().getText()
            }); }),
            parameters: method.getParameters().map(function (p) { return ({
                name: p.getNameOrThrow(),
                hasQuestionToken: p.hasQuestionToken(),
                type: p.getTypeNodeOrThrow().getText()
            }); })
        }); }),
        indexSignatures: cloningInterface.getIndexSignatures().map(function (s) { return ({
            keyName: s.getKeyName(),
            keyType: s.getKeyTypeNode().getText(),
            returnType: s.getReturnTypeNode().getText(),
            docs: s.getJsDocs().map(function (d) { return ({ description: d.getInnerText().replace(/\r?\n/g, "\r\n") }); })
        }); })
    }); }));
}
exports.cloneInterfaces = cloneInterfaces;
function cloneEnums(node, cloningEnums) {
    node.addEnums(cloningEnums.map(function (cloningEnum) { return ({
        name: cloningEnum.getName(),
        isExported: true,
        members: cloningEnum.getMembers().map(function (m) { return ({
            name: m.getName(),
            docs: m.getJsDocs().map(function (d) { return ({ description: d.getInnerText().replace(/\r?\n/g, "\r\n") }); }),
            value: m.getValue()
        }); })
    }); }));
}
exports.cloneEnums = cloneEnums;
function cloneTypeAliases(node, typeAliases) {
    node.addTypeAliases(typeAliases.map(function (typeAlias) { return ({
        name: typeAlias.getName(),
        isExported: true,
        typeParameters: typeAlias.getTypeParameters().map(function (p) { return ({
            name: p.getName(),
            constraint: p.getConstraintNode() == null ? undefined : p.getConstraintNode().getText()
        }); }),
        docs: typeAlias.getJsDocs().map(function (d) { return ({ description: d.getInnerText().replace(/\r?\n/g, "\r\n") }); }),
        type: typeAlias.getTypeNodeOrThrow().getText()
    }); }));
}
exports.cloneTypeAliases = cloneTypeAliases;
function cloneClasses(node, classes) {
    node.addClasses(classes.map(function (c) { return ({
        name: c.getName(),
        isExported: true,
        hasDeclareKeyword: true,
        typeParameters: c.getTypeParameters().map(function (p) { return ({
            name: p.getName(),
            constraint: p.getConstraintNode() == null ? undefined : p.getConstraintNode().getText()
        }); }),
        docs: c.getJsDocs().map(function (d) { return ({ description: d.getInnerText().replace(/\r?\n/g, "\r\n") }); }),
        properties: c.getInstanceProperties().map(function (nodeProp) { return ({
            name: nodeProp.getName(),
            type: nodeProp.getType().getText(),
            hasQuestionToken: nodeProp.hasQuestionToken(),
            docs: nodeProp.getJsDocs().map(function (d) { return ({ description: d.getInnerText().replace(/\r?\n/g, "\r\n") }); })
        }); }),
        methods: c.getInstanceMethods().map(function (method) { return ({
            name: method.getName(),
            returnType: method.getReturnTypeNodeOrThrow().getText(),
            docs: method.getJsDocs().map(function (d) { return ({ description: d.getInnerText().replace(/\r?\n/g, "\r\n") }); }),
            typeParameters: method.getTypeParameters().map(function (p) { return ({
                name: p.getName(),
                constraint: p.getConstraintNode() == null ? undefined : p.getConstraintNode().getText()
            }); }),
            parameters: method.getParameters().map(function (p) { return ({
                name: p.getNameOrThrow(),
                hasQuestionToken: p.hasQuestionToken(),
                type: p.getTypeNodeOrThrow().getText(),
                isRestParameter: p.isRestParameter()
            }); })
        }); })
    }); }));
}
exports.cloneClasses = cloneClasses;
function cloneFunctions(node, functions) {
    node.addFunctions(functions.map(function (f) { return ({
        name: f.getName(),
        hasDeclareKeyword: true,
        isExported: true,
        typeParameters: f.getTypeParameters().map(function (p) { return ({
            name: p.getName(),
            constraint: p.getConstraintNode() == null ? undefined : p.getConstraintNode().getText()
        }); }),
        docs: f.getJsDocs().map(function (d) { return ({ description: d.getInnerText().replace(/\r?\n/g, "\r\n") }); }),
        parameters: f.getParameters().map(function (p) { return ({
            name: p.getNameOrThrow(),
            hasQuestionToken: p.isOptional(),
            type: p.getTypeNodeOrThrow().getText(),
            isRestParameter: p.isRestParameter()
        }); }),
        returnType: f.getReturnTypeNodeOrThrow().getText()
    }); }));
}
exports.cloneFunctions = cloneFunctions;
function cloneVariables(node, variables) {
    node.addVariableStatements(variables.map(function (v) { return ({
        isExported: true,
        declarationType: v.getDeclarationType(),
        hasDeclareKeyword: true,
        docs: v.getJsDocs().map(function (d) { return ({ description: d.getInnerText().replace(/\r?\n/g, "\r\n") }); }),
        declarations: v.getDeclarations().map(function (d) { return ({
            name: d.getName(),
            type: d.getTypeNode() == null ? undefined : d.getTypeNodeOrThrow().getText(),
            initializer: d.getInitializer() == null ? undefined : d.getInitializerOrThrow().getText()
        }); })
    }); }));
}
exports.cloneVariables = cloneVariables;
