"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var main_1 = require("../src/main");
var common_1 = require("./common");
var project = common_1.getDefinitionProject();
var definitionFiles = project.getSourceFiles(["dist/**/*.d.ts", "!dist/typescript/typescript.d.ts"]);
var mainFile = project.getSourceFileOrThrow("main.d.ts");
var compilerApiFile = project.getSourceFileOrThrow("dist/typescript/typescript.d.ts");
var exportedDeclarations = mainFile.getExportedDeclarations();
mainFile.replaceWithText("import CodeBlockWriter from \"code-block-writer\";\n"); // clear the source file
try {
    for (var exportedDeclarations_1 = __values(exportedDeclarations), exportedDeclarations_1_1 = exportedDeclarations_1.next(); !exportedDeclarations_1_1.done; exportedDeclarations_1_1 = exportedDeclarations_1.next()) {
        var declaration = exportedDeclarations_1_1.value;
        if (declaration.getSourceFile() === compilerApiFile)
            continue;
        if (main_1.TypeGuards.isVariableDeclaration(declaration))
            declaration = declaration.getFirstAncestorByKindOrThrow(main_1.SyntaxKind.VariableStatement);
        mainFile.insertText(mainFile.getFullWidth(), declaration.getFullText() + "\n");
    }
}
catch (e_1_1) { e_1 = { error: e_1_1 }; }
finally {
    try {
        if (exportedDeclarations_1_1 && !exportedDeclarations_1_1.done && (_a = exportedDeclarations_1.return)) _a.call(exportedDeclarations_1);
    }
    finally { if (e_1) throw e_1.error; }
}
// add an import to the typescript compiler api file
mainFile.addImportDeclaration({
    namedImports: ["ts", "SyntaxKind", "CompilerOptions", "EmitHint", "ScriptKind", "NewLineKind", "LanguageVariant", "ScriptTarget",
        "TypeFlags", "ObjectFlags", "SymbolFlags", "TypeFormatFlags", "DiagnosticCategory", "EditorSettings"],
    moduleSpecifier: mainFile.getRelativePathToSourceFileAsModuleSpecifier(compilerApiFile)
});
mainFile.addExportDeclaration({ moduleSpecifier: mainFile.getRelativePathToSourceFileAsModuleSpecifier(compilerApiFile) });
// update the main.d.ts file
mainFile.getClassOrThrow("Project").setIsDefaultExport(true);
mainFile.replaceWithText(mainFile.getFullText().replace(/compiler\.([A-Za-z]+)/g, "$1"));
definitionFiles.filter(function (f) { return f !== mainFile; }).forEach(function (f) { return f.delete(); });
project.save();
var e_1, _a;
