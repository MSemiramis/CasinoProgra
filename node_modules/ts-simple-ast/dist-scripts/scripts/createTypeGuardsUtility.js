"use strict";
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../src/utils");
function createTypeGuardsUtility(inspector) {
    var file = inspector.getProject().getSourceFileOrThrow("./src/utils/TypeGuards.ts");
    var typeGuardsClass = file.getClassOrThrow("TypeGuards");
    var nodeToWrapperMappings = inspector.getNodeToWrapperMappings();
    // remove all the static methods that start with "is"
    typeGuardsClass.getStaticMethods()
        .filter(function (m) { return utils_1.StringUtils.startsWith(m.getName(), "is"); })
        .forEach(function (m) { return m.remove(); });
    typeGuardsClass.addMethods(getMethodInfos().map(function (method) { return ({
        name: "is" + method.name,
        isStatic: true,
        docs: [{
                description: "Gets if the node is " + ((method.name[0] === "A" || method.name[0] === "E") ? "an" : "a") + " " + method.name + ".\r\n" +
                    "@param node - Node to check."
            }],
        parameters: [{ name: "node", type: "compiler.Node" }],
        returnType: "node is compiler." + method.wrapperName + (method.isMixin ? " & compiler.Node" : ""),
        bodyText: function (writer) {
            if (method.syntaxKinds.length === 1) {
                writer.writeLine("return node.getKind() === SyntaxKind." + method.syntaxKinds[0] + ";");
                return;
            }
            writer.write("switch (node.getKind())").block(function () {
                try {
                    for (var _a = __values(method.syntaxKinds), _b = _a.next(); !_b.done; _b = _a.next()) {
                        var syntaxKindName = _b.value;
                        writer.writeLine("case SyntaxKind." + syntaxKindName + ":");
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                writer.indent().write("return true;").newLine();
                writer.writeLine("default:")
                    .indent().write("return false;").newLine();
                var e_1, _c;
            });
        }
    }); }));
    function getMethodInfos() {
        var methodInfos = new utils_1.KeyValueCache();
        try {
            for (var _a = __values(inspector.getWrappedNodes().filter(function (n) { return n.getName() !== "Node" && isAllowedClass(n.getName()); })), _b = _a.next(); !_b.done; _b = _a.next()) {
                var node = _b.value;
                var methodInfo = getMethodInfoForNode(node);
                var nodeBase = node.getBase();
                if (nodeBase != null)
                    fillBase(node, nodeBase);
                fillMixinable(node, node);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var allowedBaseNames = ["Node", "Expression", "BooleanLiteral"];
        try {
            for (var _d = __values(nodeToWrapperMappings.filter(function (v) { return allowedBaseNames.indexOf(v.wrapperName) >= 0; })), _e = _d.next(); !_e.done; _e = _d.next()) {
                var nodeToWrapperMapping = _e.value;
                try {
                    for (var _f = __values(nodeToWrapperMapping.syntaxKindNames), _g = _f.next(); !_g.done; _g = _f.next()) {
                        var syntaxKindName = _g.value;
                        methodInfos.set(syntaxKindName, {
                            name: syntaxKindName,
                            wrapperName: nodeToWrapperMapping.wrapperName,
                            syntaxKinds: [syntaxKindName],
                            isMixin: false
                        });
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (_g && !_g.done && (_h = _f.return)) _h.call(_f);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_e && !_e.done && (_j = _d.return)) _j.call(_d);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return utils_1.ArrayUtils.sortByProperty(methodInfos.getValuesAsArray(), function (info) { return info.name; });
        function fillBase(node, nodeBase) {
            if (nodeBase.getName() === "Node")
                return;
            var nodeBaseBase = nodeBase.getBase();
            if (nodeBaseBase != null)
                fillBase(node, nodeBaseBase);
            var methodInfo = getMethodInfoForNode(nodeBase);
            (_a = methodInfo.syntaxKinds).push.apply(_a, __spread(getSyntaxKindsForName(node.getName())));
            fillMixinable(node, nodeBase);
            var _a;
        }
        function fillMixinable(node, mixinable) {
            try {
                for (var _a = __values(mixinable.getMixins()), _b = _a.next(); !_b.done; _b = _a.next()) {
                    var mixin = _b.value;
                    (_c = getMethodInfoForMixin(mixin).syntaxKinds).push.apply(_c, __spread(getSyntaxKindsForName(node.getName())));
                    fillMixinable(node, mixin);
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_b && !_b.done && (_d = _a.return)) _d.call(_a);
                }
                finally { if (e_5) throw e_5.error; }
            }
            var e_5, _d, _c;
        }
        function getMethodInfoForNode(node) {
            var nodeName = node.getName();
            if (methodInfos.has(nodeName))
                return methodInfos.get(nodeName);
            var methodInfo = {
                name: nodeName,
                wrapperName: nodeName,
                syntaxKinds: __spread(getSyntaxKindsForName(nodeName)),
                isMixin: false
            };
            methodInfos.set(nodeName, methodInfo);
            return methodInfo;
        }
        function getMethodInfoForMixin(mixin) {
            var mixinName = mixin.getName();
            if (methodInfos.has(mixinName))
                return methodInfos.get(mixinName);
            var methodInfo = {
                name: mixinName,
                wrapperName: mixinName,
                syntaxKinds: [],
                isMixin: true
            };
            methodInfos.set(mixinName, methodInfo);
            return methodInfo;
        }
        function getSyntaxKindsForName(name) {
            var nodeToWrapperVM = utils_1.ArrayUtils.find(nodeToWrapperMappings, function (n) { return n.wrapperName === name; });
            if (nodeToWrapperVM == null)
                return [];
            return nodeToWrapperVM.syntaxKindNames;
        }
        var e_2, _c, e_4, _j, e_3, _h;
    }
}
exports.createTypeGuardsUtility = createTypeGuardsUtility;
function isAllowedClass(name) {
    switch (name) {
        // todo: should support these classes eventually (they probably need to be customly implemented)
        case "ObjectDestructuringAssignment":
        case "ArrayDestructuringAssignment":
        case "AssignmentExpression":
        case "SuperElementAccessExpression":
        case "SuperPropertyAccessExpression":
            return false;
        default:
            return true;
    }
}
