import { ts, SyntaxKind } from "../../../typescript";
import { NamedNode, QuestionTokenableNode, InitializerGetExpressionableNode } from "../../base";
import { Expression } from "../Expression";
import { Node } from "../../common";
import { PropertyAssignment } from "./PropertyAssignment";
export declare const ShorthandPropertyAssignmentBase: (new (...args: any[]) => InitializerGetExpressionableNode) & (new (...args: any[]) => QuestionTokenableNode) & (new (...args: any[]) => NamedNode) & typeof Node;
export declare class ShorthandPropertyAssignment extends ShorthandPropertyAssignmentBase<ts.ShorthandPropertyAssignment> {
    /**
     * Gets if the shorthand property assignment has an object assignment initializer.
     */
    hasObjectAssignmentInitializer(): boolean;
    /**
     * Gets the object assignment initializer or throws if it doesn't exist.
     */
    getObjectAssignmentInitializerOrThrow(): Expression<ts.Expression>;
    /**
     * Gets the object assignment initializer if it exists.
     */
    getObjectAssignmentInitializer(): Expression<ts.Expression> | undefined;
    /**
     * Gets the equals token or throws if it doesn't exist.
     */
    getEqualsTokenOrThrow(): Node<ts.Token<SyntaxKind.EqualsToken>>;
    /**
     * Gets the equals token if it exists.
     */
    getEqualsToken(): Node<ts.Token<SyntaxKind.EqualsToken>> | undefined;
    /**
     * Remove the object assignment initializer.
     *
     * This is only useful to remove bad code.
     */
    removeObjectAssignmentInitializer(): this;
    /**
     * Sets the initializer.
     *
     * Note: The current node will no longer be valid because it's no longer a shorthand property assignment.
     * @param text - New text to set for the initializer.
     */
    setInitializer(text: string): PropertyAssignment;
}
