"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var path = require("path");
var chai_1 = require("chai");
var typescript_1 = require("../typescript");
var compiler_1 = require("../compiler");
var fileSystem_1 = require("../fileSystem");
var Project_1 = require("../Project");
var ManipulationSettings_1 = require("../ManipulationSettings");
var errors = require("../errors");
var testHelpers = require("./testHelpers");
console.log("");
console.log("TypeScript version: " + typescript_1.ts.version);
describe("Project", function () {
    describe("constructor", function () {
        it("should set the manipulation settings if provided", function () {
            var project = new Project_1.Project({
                manipulationSettings: {
                    indentationText: ManipulationSettings_1.IndentationText.EightSpaces
                }
            });
            chai_1.expect(project.manipulationSettings.getIndentationText()).to.equal(ManipulationSettings_1.IndentationText.EightSpaces);
        });
        it("should add the files from tsconfig.json by default", function () {
            var fs = new fileSystem_1.VirtualFileSystemHost();
            fs.writeFileSync("tsconfig.json", "{ \"compilerOptions\": { \"rootDir\": \"test\", \"target\": \"ES5\" } }");
            fs.writeFileSync("/otherFile.ts", "");
            fs.writeFileSync("/test/file.ts", "");
            fs.writeFileSync("/test/test2/file2.ts", "");
            var project = new Project_1.Project({ tsConfigFilePath: "tsconfig.json" }, fs);
            chai_1.expect(project.getSourceFiles().map(function (s) { return s.getFilePath(); }).sort()).to.deep.equal(["/test/file.ts", "/test/test2/file2.ts"].sort());
        });
        it("should add the files from tsconfig.json by default and also take into account the passed in compiler options", function () {
            var fs = new fileSystem_1.VirtualFileSystemHost();
            fs.writeFileSync("tsconfig.json", "{ \"compilerOptions\": { \"target\": \"ES5\" } }");
            fs.writeFileSync("/otherFile.ts", "");
            fs.writeFileSync("/test/file.ts", "");
            fs.writeFileSync("/test/test2/file2.ts", "");
            var project = new Project_1.Project({ tsConfigFilePath: "tsconfig.json", compilerOptions: { rootDir: "/test/test2" } }, fs);
            chai_1.expect(project.getSourceFiles().map(function (s) { return s.getFilePath(); }).sort()).to.deep.equal(["/test/test2/file2.ts"].sort());
        });
        it("should not add the files from tsconfig.json when specifying not to", function () {
            var fs = new fileSystem_1.VirtualFileSystemHost();
            fs.writeFileSync("tsconfig.json", "{ \"compilerOptions\": { \"rootDir\": \"test\", \"target\": \"ES5\" } }");
            fs.writeFileSync("/test/file.ts", "");
            fs.writeFileSync("/test/test2/file2.ts", "");
            var project = new Project_1.Project({ tsConfigFilePath: "tsconfig.json", addFilesFromTsConfig: false }, fs);
            chai_1.expect(project.getSourceFiles().map(function (s) { return s.getFilePath(); }).sort()).to.deep.equal([]);
        });
    });
    describe("getCompilerOptions", function () {
        it("should get the default compiler options when not providing anything and no tsconfig exists", function () {
            var host = testHelpers.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project({}, host);
            chai_1.expect(project.getCompilerOptions()).to.deep.equal({});
        });
        it("should not get the compiler options from tsconfig.json when not providing anything and a tsconfig exists", function () {
            var host = testHelpers.getFileSystemHostWithFiles([{ filePath: "tsconfig.json", text: "{ \"compilerOptions\": { \"rootDir\": \"test\", \"target\": \"ES5\" } }" }]);
            var project = new Project_1.Project({}, host);
            chai_1.expect(project.getCompilerOptions()).to.deep.equal({});
        });
        it("should get empty compiler options when providing an empty compiler options object", function () {
            var host = testHelpers.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project({ compilerOptions: {} }, host);
            chai_1.expect(project.getCompilerOptions()).to.deep.equal({});
        });
        function doTsConfigTest(addFilesFromTsConfig) {
            var host = testHelpers.getFileSystemHostWithFiles([{ filePath: "tsconfig.json", text: "{ \"compilerOptions\": { \"rootDir\": \"test\", \"target\": \"ES5\" } }" }]);
            var project = new Project_1.Project({
                tsConfigFilePath: "tsconfig.json",
                compilerOptions: {
                    target: 2,
                    allowJs: true
                },
                addFilesFromTsConfig: addFilesFromTsConfig // the behaviour changes based on this value so it's good to test both of these
            }, host);
            chai_1.expect(project.getCompilerOptions()).to.deep.equal({ rootDir: "/test", target: 2, allowJs: true });
        }
        it("should override the tsconfig options when specifying to add files from tsconfig", function () {
            doTsConfigTest(true);
        });
        it("should override the tsconfig options when specifying to not add files from tsconfig", function () {
            doTsConfigTest(false);
        });
    });
    describe("addDirectoryIfExists", function () {
        it("should throw if the directory doesn't exist", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project(undefined, fileSystem);
            chai_1.expect(project.addDirectoryIfExists("someDir")).to.be.undefined;
        });
        it("should add the directory if it exists", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([], ["someDir"]);
            var project = new Project_1.Project(undefined, fileSystem);
            var dir = project.addDirectoryIfExists("someDir");
            chai_1.expect(dir).to.not.be.undefined;
        });
    });
    describe("addExistingDirectory", function () {
        it("should throw if the directory doesn't exist", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project(undefined, fileSystem);
            chai_1.expect(function () {
                project.addExistingDirectory("someDir");
            }).to.throw(errors.DirectoryNotFoundError);
        });
        it("should add the directory if it exists", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([], ["someDir"]);
            var project = new Project_1.Project(undefined, fileSystem);
            var dir = project.addExistingDirectory("someDir");
            chai_1.expect(dir).to.not.be.undefined;
        });
    });
    describe("createDirectory", function () {
        it("should create the directory when it doesn't exist", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project(undefined, fileSystem);
            var createdDir = project.createDirectory("someDir");
            chai_1.expect(createdDir).to.not.be.undefined;
            chai_1.expect(project.getDirectoryOrThrow("someDir")).to.equal(createdDir);
        });
        it("should create the parent directory if it doesn't exist", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project(undefined, fileSystem);
            project.createSourceFile("file.txt");
            var createdDir = project.createDirectory("someDir");
            chai_1.expect(createdDir).to.not.be.undefined;
            chai_1.expect(project.getDirectoryOrThrow("someDir")).to.equal(createdDir);
        });
        it("should throw when a directory already exists at the specified path", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project(undefined, fileSystem);
            var createdDir = project.createDirectory("someDir");
            chai_1.expect(function () { return project.createDirectory("someDir"); }).to.throw(errors.InvalidOperationError);
        });
        it("should throw when a directory already exists on the file system at the specified path", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([], ["childDir"]);
            var project = new Project_1.Project(undefined, fileSystem);
            chai_1.expect(function () { return project.createDirectory("childDir"); }).to.throw(errors.InvalidOperationError);
        });
    });
    describe("getDirectory", function () {
        var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
        var project = new Project_1.Project(undefined, fileSystem);
        project.createSourceFile("dir/file.ts");
        it("should get a directory if it exists", function () {
            chai_1.expect(project.getDirectory("dir")).to.not.be.undefined;
        });
        it("should not get a directory that doesn't exist", function () {
            chai_1.expect(project.getDirectory("otherDir")).to.be.undefined;
        });
    });
    describe("getDirectoryOrThrow", function () {
        var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
        var project = new Project_1.Project(undefined, fileSystem);
        project.createSourceFile("dir/file.ts");
        it("should get a directory if it exists", function () {
            chai_1.expect(project.getDirectoryOrThrow("dir")).to.not.be.undefined;
        });
        it("should throw when it doesn't exist", function () {
            chai_1.expect(function () { return project.getDirectoryOrThrow("otherDir"); }).to.throw();
        });
    });
    describe("getRootDirectories", function () {
        var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
        var project = new Project_1.Project(undefined, fileSystem);
        project.createSourceFile("dir/file.ts");
        project.createSourceFile("dir/child/file.ts");
        project.createSourceFile("dir2/file2.ts");
        project.createSourceFile("dir2/child/file2.ts");
        project.createSourceFile("dir3/child/file2.ts");
        it("should get all the directories without a parent", function () {
            chai_1.expect(project.getRootDirectories().map(function (d) { return d.getPath(); })).to.deep.equal([
                project.getDirectoryOrThrow("dir"),
                project.getDirectoryOrThrow("dir2"),
                project.getDirectoryOrThrow("dir3/child")
            ].map(function (d) { return d.getPath(); }));
        });
    });
    describe("getDirectories", function () {
        var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
        var project = new Project_1.Project(undefined, fileSystem);
        project.createSourceFile("dir/child/file.ts");
        project.createSourceFile("dir2/child/file2.ts");
        project.createSourceFile("dir3/child/file2.ts");
        project.createSourceFile("dir/file.ts");
        project.createSourceFile("dir2/file2.ts");
        it("should get all the directories in the order based on the directory structure", function () {
            chai_1.expect(project.getDirectories().map(function (d) { return d.getPath(); })).to.deep.equal([
                project.getDirectoryOrThrow("dir"),
                project.getDirectoryOrThrow("dir2"),
                project.getDirectoryOrThrow("dir3/child"),
                project.getDirectoryOrThrow("dir/child"),
                project.getDirectoryOrThrow("dir2/child")
            ].map(function (d) { return d.getPath(); }));
        });
    });
    describe("addSourceFilesFromTsConfig", function () {
        it("should throw if the tsconfig doesn't exist", function () {
            var fs = new fileSystem_1.VirtualFileSystemHost();
            var project = new Project_1.Project({}, fs);
            chai_1.expect(function () { return project.addSourceFilesFromTsConfig("tsconfig.json"); }).to.throw(errors.FileNotFoundError);
        });
        it("should add the files from tsconfig.json", function () {
            var fs = new fileSystem_1.VirtualFileSystemHost();
            fs.writeFileSync("tsconfig.json", "{ \"compilerOptions\": { \"rootDir\": \"test\", \"target\": \"ES5\" } }");
            fs.writeFileSync("/otherFile.ts", "");
            fs.writeFileSync("/test/file.ts", "");
            fs.writeFileSync("/test/test2/file2.ts", "");
            var project = new Project_1.Project({}, fs);
            chai_1.expect(project.getSourceFiles().map(function (s) { return s.getFilePath(); }).sort()).to.deep.equal([].sort());
            var returnedFiles = project.addSourceFilesFromTsConfig("tsconfig.json");
            var expectedFiles = ["/test/file.ts", "/test/test2/file2.ts"].sort();
            chai_1.expect(project.getSourceFiles().map(function (s) { return s.getFilePath(); }).sort()).to.deep.equal(expectedFiles);
            chai_1.expect(returnedFiles.map(function (s) { return s.getFilePath(); }).sort()).to.deep.equal(expectedFiles);
        });
    });
    describe("addExistingSourceFile", function () {
        it("should throw an exception if adding a source file at a non-existent path", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project(undefined, fileSystem);
            chai_1.expect(function () {
                project.addExistingSourceFile("non-existent-file.ts");
            }).to.throw(errors.FileNotFoundError, "File not found: /non-existent-file.ts");
        });
        it("should add a source file that exists", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([{ filePath: "file.ts", text: "" }]);
            var project = new Project_1.Project(undefined, fileSystem);
            var sourceFile = project.addExistingSourceFile("file.ts");
            chai_1.expect(sourceFile).to.not.be.undefined;
        });
    });
    describe("addSourceFileIfExists", function () {
        it("should return undefined if adding a source file at a non-existent path", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            chai_1.expect(project.addSourceFileIfExists("non-existent-file.ts")).to.be.undefined;
        });
        it("should add a source file that exists", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([{ filePath: "file.ts", text: "" }]);
            var project = new Project_1.Project(undefined, fileSystem);
            var sourceFile = project.addSourceFileIfExists("file.ts");
            chai_1.expect(sourceFile).to.not.be.undefined;
        });
    });
    describe("addExistingSourceFiles", function () {
        it("should add based on a string file glob", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var fs = project.getFileSystem();
            fs.writeFileSync("file1.ts", "");
            fs.writeFileSync("dir/file.ts", "");
            fs.writeFileSync("dir/subDir/file.ts", "");
            var result = project.addExistingSourceFiles("/dir/**/*.ts");
            var sourceFiles = project.getSourceFiles();
            chai_1.expect(sourceFiles.length).to.equal(2);
            chai_1.expect(result).to.deep.equal(sourceFiles);
            chai_1.expect(sourceFiles[0].getFilePath()).to.equal("/dir/file.ts");
            chai_1.expect(sourceFiles[0].isSaved()).to.be.true; // should be saved because it was read from the disk
            chai_1.expect(sourceFiles[1].getFilePath()).to.equal("/dir/subDir/file.ts");
        });
        it("should add based on multiple file globs", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var fs = project.getFileSystem();
            fs.writeFileSync("file1.ts", "");
            fs.writeFileSync("dir/file.ts", "");
            fs.writeFileSync("dir/file.d.ts", "");
            fs.writeFileSync("dir/subDir/file.ts", "");
            var result = project.addExistingSourceFiles(["/dir/**/*.ts", "!/dir/**/*.d.ts"]);
            var sourceFiles = project.getSourceFiles();
            chai_1.expect(sourceFiles.length).to.equal(2);
            chai_1.expect(result).to.deep.equal(sourceFiles);
            chai_1.expect(sourceFiles[0].getFilePath()).to.equal("/dir/file.ts");
            chai_1.expect(sourceFiles[1].getFilePath()).to.equal("/dir/subDir/file.ts");
        });
    });
    describe("createSourceFile", function () {
        it("should throw an exception if creating a source file at an existing path", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            project.createSourceFile("file.ts", "");
            chai_1.expect(function () {
                project.createSourceFile("file.ts", "");
            }).to.throw(errors.InvalidOperationError, "A source file already exists at the provided file path: /file.ts");
        });
        it("should throw an exception if creating a source file at an existing path on the disk", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([{ filePath: "file.ts", text: "" }]);
            var project = new Project_1.Project(undefined, fileSystem);
            chai_1.expect(function () { return project.createSourceFile("file.ts", ""); }).to.throw(errors.InvalidOperationError);
        });
        it("should mark the source file as having not been saved", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var sourceFile = project.createSourceFile("file.ts", "");
            chai_1.expect(sourceFile.isSaved()).to.be.false;
        });
        it("", function () {
            // todo: remove
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var sourceFile = project.createSourceFile("MyFile.ts", "enum MyEnum {\n    myMember\n}\nlet myEnum: MyEnum;\nlet myOtherEnum: MyNewEnum;");
            var enumDef = sourceFile.getEnums()[0];
            enumDef.rename("NewName");
            var addedEnum = sourceFile.addEnum({
                name: "MyNewEnum"
            });
            addedEnum.rename("MyOtherNewName");
            var enumMember = enumDef.getMembers()[0];
            enumMember.rename("myNewMemberName");
            chai_1.expect(enumMember.getValue()).to.equal(0);
            chai_1.expect(sourceFile.getFullText()).to.equal("enum NewName {\n    myNewMemberName\n}\nlet myEnum: NewName;\nlet myOtherEnum: MyOtherNewName;\n\nenum MyOtherNewName {\n}\n");
        });
    });
    describe("createSourceFile", function () {
        it("should throw an exception if creating a source file at an existing path", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            project.createSourceFile("file.ts", "");
            chai_1.expect(function () {
                project.createSourceFile("file.ts", {});
            }).to.throw(errors.InvalidOperationError, "A source file already exists at the provided file path: /file.ts");
        });
        it("should mark the source file as having not been saved", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var sourceFile = project.createSourceFile("file.ts", {});
            chai_1.expect(sourceFile.isSaved()).to.be.false;
        });
        it("should add a source file based on a structure", function () {
            // basic test
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var sourceFile = project.createSourceFile("MyFile.ts", {
                enums: [{
                        name: "MyEnum"
                    }],
                imports: [{ moduleSpecifier: "./test" }],
                exports: [{ moduleSpecifier: "./test" }]
            });
            chai_1.expect(sourceFile.getFullText()).to.equal("import \"./test\";\n\nenum MyEnum {\n}\n\nexport * from \"./test\";\n");
        });
    });
    describe("mixing real files with virtual files", function () {
        var testFilesDirPath = path.join(__dirname, "../../src/tests/testFiles");
        var project = new Project_1.Project();
        project.addExistingSourceFiles(testFilesDirPath + "/**/*.ts");
        project.createSourceFile(path.join(testFilesDirPath, "variableTestFile.ts"), "import * as testClasses from \"./testClasses\";\n\nlet var = new testClasses.TestClass().name;\n");
        it("should have 4 source files", function () {
            chai_1.expect(project.getSourceFiles().length).to.equal(4);
        });
        it("should rename a name appropriately", function () {
            var interfaceFile = project.getSourceFileOrThrow("testInterfaces.ts");
            interfaceFile.getInterfaces()[0].getProperties()[0].rename("newName");
            var variableFile = project.getSourceFileOrThrow("variableTestFile.ts");
            chai_1.expect(variableFile.getFullText()).to.equal("import * as testClasses from \"./testClasses\";\n\nlet var = new testClasses.TestClass().newName;\n");
        });
    });
    describe("removeSourceFile", function () {
        it("should remove the source file", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var sourceFile = project.createSourceFile("myFile.ts", "");
            chai_1.expect(project.removeSourceFile(sourceFile)).to.equal(true);
            chai_1.expect(project.removeSourceFile(sourceFile)).to.equal(false);
            chai_1.expect(project.getSourceFiles().length).to.equal(0);
            chai_1.expect(function () { return sourceFile.getChildCount(); }).to.throw(); // should be forgotten
        });
    });
    describe("save", function () {
        it("should save all the unsaved source files asynchronously", function () { return __awaiter(_this, void 0, void 0, function () {
            var fileSystem, project;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fileSystem = testHelpers.getFileSystemHostWithFiles([]);
                        project = new Project_1.Project(undefined, fileSystem);
                        project.createSourceFile("file1.ts", "").saveSync();
                        project.createSourceFile("file2.ts", "");
                        project.createSourceFile("file3.ts", "");
                        return [4 /*yield*/, project.save()];
                    case 1:
                        _a.sent();
                        chai_1.expect(project.getSourceFiles().map(function (f) { return f.isSaved(); })).to.deep.equal([true, true, true]);
                        chai_1.expect(fileSystem.getWriteLog().length).to.equal(2); // 2 writes
                        chai_1.expect(fileSystem.getSyncWriteLog().length).to.equal(1); // 1 write
                        return [2 /*return*/];
                }
            });
        }); });
        it("should delete any deleted source files & directories and save unsaved source files", function () { return __awaiter(_this, void 0, void 0, function () {
            var fileSystem, project, sourceFileToDelete, dirToDelete, sourceFileToUndelete;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fileSystem = testHelpers.getFileSystemHostWithFiles([]);
                        project = new Project_1.Project(undefined, fileSystem);
                        sourceFileToDelete = project.createDirectory("dir").createSourceFile("file.ts");
                        sourceFileToDelete.saveSync();
                        sourceFileToDelete.delete();
                        dirToDelete = project.createDirectory("dir2");
                        dirToDelete.createSourceFile("file.ts");
                        dirToDelete.saveSync();
                        dirToDelete.delete();
                        sourceFileToUndelete = project.createSourceFile("file.ts");
                        sourceFileToUndelete.saveSync();
                        sourceFileToUndelete.delete();
                        sourceFileToUndelete = project.createSourceFile("file.ts");
                        return [4 /*yield*/, project.save()];
                    case 1:
                        _a.sent();
                        chai_1.expect(fileSystem.getFiles().map(function (f) { return f[0]; })).to.deep.equal(["/file.ts"]);
                        chai_1.expect(fileSystem.getCreatedDirectories().sort()).to.deep.equal(["/dir", "/"].sort());
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("saveSync", function () {
        it("should save all the unsaved source files synchronously", function () {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project(undefined, fileSystem);
            project.createSourceFile("file1.ts", "").saveSync();
            project.createSourceFile("file2.ts", "");
            project.createSourceFile("file3.ts", "");
            project.saveSync();
            chai_1.expect(project.getSourceFiles().map(function (f) { return f.isSaved(); })).to.deep.equal([true, true, true]);
            chai_1.expect(fileSystem.getWriteLog().length).to.equal(0);
            chai_1.expect(fileSystem.getSyncWriteLog().length).to.equal(3); // 3 writes
        });
    });
    describe("emit", function () {
        function setup(compilerOptions) {
            var fileSystem = testHelpers.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project({ compilerOptions: compilerOptions }, fileSystem);
            project.createSourceFile("file1.ts", "const num1 = 1;");
            project.createSourceFile("file2.ts", "const num2 = 2;");
            return { fileSystem: fileSystem, project: project };
        }
        it("should emit multiple files when not specifying any options", function () {
            var _a = setup({ noLib: true, outDir: "dist" }), project = _a.project, fileSystem = _a.fileSystem;
            var result = project.emit();
            chai_1.expect(result).to.be.instanceof(compiler_1.EmitResult);
            var writeLog = fileSystem.getSyncWriteLog();
            chai_1.expect(writeLog[0].filePath).to.equal("/dist/file1.js");
            chai_1.expect(writeLog[0].fileText).to.equal("var num1 = 1;\n");
            chai_1.expect(writeLog[1].filePath).to.equal("/dist/file2.js");
            chai_1.expect(writeLog[1].fileText).to.equal("var num2 = 2;\n");
            chai_1.expect(writeLog.length).to.equal(2);
        });
        it("should emit the source file when specified", function () {
            var _a = setup({ noLib: true, outDir: "dist" }), project = _a.project, fileSystem = _a.fileSystem;
            project.emit({ targetSourceFile: project.getSourceFile("file1.ts") });
            var writeLog = fileSystem.getSyncWriteLog();
            chai_1.expect(writeLog[0].filePath).to.equal("/dist/file1.js");
            chai_1.expect(writeLog[0].fileText).to.equal("var num1 = 1;\n");
            chai_1.expect(writeLog.length).to.equal(1);
        });
        it("should only emit the declaration file when specified", function () {
            var _a = setup({ noLib: true, outDir: "dist", declaration: true }), project = _a.project, fileSystem = _a.fileSystem;
            project.emit({ emitOnlyDtsFiles: true });
            var writeLog = fileSystem.getSyncWriteLog();
            chai_1.expect(writeLog[0].filePath).to.equal("/dist/file1.d.ts");
            chai_1.expect(writeLog[0].fileText).to.equal("declare const num1 = 1;\n");
            chai_1.expect(writeLog[1].filePath).to.equal("/dist/file2.d.ts");
            chai_1.expect(writeLog[1].fileText).to.equal("declare const num2 = 2;\n");
            chai_1.expect(writeLog.length).to.equal(2);
        });
    });
    describe("getSourceFile", function () {
        it("should get the first match based on the directory structure", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            project.createSourceFile("dir/file.ts");
            var expectedFile = project.createSourceFile("file.ts");
            chai_1.expect(project.getSourceFile("file.ts").getFilePath()).to.equal(expectedFile.getFilePath());
        });
        it("should get the first match based on the directory structure when specifying a dot slash", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            project.createSourceFile("dir/file.ts");
            var expectedFile = project.createSourceFile("file.ts");
            chai_1.expect(project.getSourceFile("./file.ts").getFilePath()).to.equal(expectedFile.getFilePath());
        });
        it("should get the first match based on the directory structure when using ../", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var expectedFile = project.createSourceFile("dir/file.ts");
            project.createSourceFile("file.ts");
            chai_1.expect(project.getSourceFile("dir/../dir/file.ts").getFilePath()).to.equal(expectedFile.getFilePath());
        });
        it("should get the first match based on a file name", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            project.createSourceFile("file.ts");
            var expectedFile = project.createSourceFile("dir/file2.ts");
            chai_1.expect(project.getSourceFile("file2.ts").getFilePath()).to.equal(expectedFile.getFilePath());
        });
        it("should get when specifying an absolute path", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            project.createSourceFile("dir/file.ts");
            var expectedFile = project.createSourceFile("file.ts");
            chai_1.expect(project.getSourceFile("/file.ts").getFilePath()).to.equal(expectedFile.getFilePath());
        });
        it("should get the first match based on the directory structure when swapping the order of what was created first", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var expectedFile = project.createSourceFile("file.ts");
            project.createSourceFile("dir/file.ts");
            chai_1.expect(project.getSourceFile("file.ts").getFilePath()).to.equal(expectedFile.getFilePath());
        });
    });
    describe("getSourceFileOrThrow", function () {
        it("should throw when it can't find the source file based on a provided path", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            chai_1.expect(function () { return project.getSourceFileOrThrow("some path"); }).to.throw();
        });
        it("should throw when it can't find the source file based on a provided condition", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            chai_1.expect(function () { return project.getSourceFileOrThrow(function (s) { return false; }); }).to.throw();
        });
        it("should not throw when it finds the file", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            project.createSourceFile("myFile.ts", "");
            chai_1.expect(project.getSourceFileOrThrow("myFile.ts").getFilePath()).to.contain("myFile.ts");
        });
    });
    describe("getSourceFiles", function () {
        it("should get all the source files added to the ast sorted by directory structure", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            project.createSourceFile("dir/child/file.ts");
            project.createSourceFile("dir/file.ts");
            project.createSourceFile("file1.ts");
            project.createSourceFile("file2.ts");
            chai_1.expect(project.getSourceFiles().map(function (s) { return s.getFilePath(); })).to.deep.equal([
                "/file1.ts",
                "/file2.ts",
                "/dir/file.ts",
                "/dir/child/file.ts"
            ]);
        });
        describe("globbing", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            project.createSourceFile("file.ts", "");
            project.createSourceFile("src/file.ts", "");
            project.createSourceFile("src/test/file1.ts", "");
            project.createSourceFile("src/test/file1.d.ts", "");
            project.createSourceFile("src/test/file2.ts", "");
            project.createSourceFile("src/test/file3.ts", "");
            project.createSourceFile("src/test/file3.js", "");
            project.createSourceFile("src/test/folder/file.ts", "");
            it("should be able to do a file glob", function () {
                chai_1.expect(project.getSourceFiles("**/test/**/*.ts").map(function (s) { return s.getFilePath(); })).to.deep.equal([
                    "/src/test/file1.d.ts",
                    "/src/test/file1.ts",
                    "/src/test/file2.ts",
                    "/src/test/file3.ts",
                    "/src/test/folder/file.ts"
                ]);
            });
            it("should be able to do a file glob with a relative path", function () {
                chai_1.expect(project.getSourceFiles("src/test/folder/*.ts").map(function (s) { return s.getFilePath(); })).to.deep.equal([
                    "/src/test/folder/file.ts"
                ]);
            });
            it("should be able to do a file glob with a relative path with a dot", function () {
                chai_1.expect(project.getSourceFiles("./src/test/folder/*.ts").map(function (s) { return s.getFilePath(); })).to.deep.equal([
                    "/src/test/folder/file.ts"
                ]);
            });
            it("should be able to do a file glob with an absolute path", function () {
                chai_1.expect(project.getSourceFiles("/src/test/folder/*.ts").map(function (s) { return s.getFilePath(); })).to.deep.equal([
                    "/src/test/folder/file.ts"
                ]);
            });
            it("should be able to do a file glob with multiple patterns", function () {
                chai_1.expect(project.getSourceFiles(["**/src/**/*.ts", "!**/src/test/**/*.ts", "!**/*.d.ts"]).map(function (s) { return s.getFilePath(); })).to.deep.equal([
                    "/src/file.ts"
                ]);
            });
        });
    });
    describe("forgetNodesCreatedInBlock", function () {
        describe("synchronous", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var sourceFile;
            var sourceFileNotNavigated;
            var classNode;
            var namespaceNode;
            var namespaceKeywordNode;
            var interfaceNode1;
            var interfaceNode2;
            var interfaceNode3;
            var interfaceNode4;
            var interfaceNode5;
            project.forgetNodesCreatedInBlock(function (remember) {
                sourceFile = project.createSourceFile("test.ts", "class MyClass {} namespace MyNamespace { interface Interface1 {} interface Interface2 {} " +
                    "interface Interface3 {} interface Interface4 {} }");
                sourceFileNotNavigated = project.createSourceFile("test2.ts", "class MyClass {}");
                classNode = sourceFile.getClassOrThrow("MyClass");
                namespaceNode = sourceFile.getNamespaceOrThrow("MyNamespace");
                project.forgetNodesCreatedInBlock(function (remember2) {
                    interfaceNode2 = namespaceNode.getInterfaceOrThrow("Interface2");
                    interfaceNode3 = namespaceNode.getInterfaceOrThrow("Interface3");
                    interfaceNode4 = namespaceNode.getInterfaceOrThrow("Interface4");
                    interfaceNode5 = namespaceNode.addInterface({ name: "Interface5" });
                    remember2(interfaceNode3, interfaceNode4);
                });
                namespaceKeywordNode = namespaceNode.getFirstChildByKindOrThrow(typescript_1.SyntaxKind.NamespaceKeyword);
                interfaceNode1 = namespaceNode.getInterfaceOrThrow("Interface1");
                remember(interfaceNode1);
            });
            it("should not have forgotten the source file", function () {
                chai_1.expect(sourceFile.wasForgotten()).to.be.false;
            });
            it("should not have forgotten the not navigated source file", function () {
                chai_1.expect(sourceFileNotNavigated.wasForgotten()).to.be.false;
            });
            it("should have forgotten the class", function () {
                chai_1.expect(classNode.wasForgotten()).to.be.true;
            });
            it("should not have forgotten the namespace because one of its children was remembered", function () {
                chai_1.expect(namespaceNode.wasForgotten()).to.be.false;
            });
            it("should have forgotten the namespace keyword", function () {
                chai_1.expect(namespaceKeywordNode.wasForgotten()).to.be.true;
            });
            it("should not have forgotten the first interface because it was remembered", function () {
                chai_1.expect(interfaceNode1.wasForgotten()).to.be.false;
            });
            it("should have forgotten the second interface", function () {
                chai_1.expect(interfaceNode2.wasForgotten()).to.be.true;
            });
            it("should not have forgotten the third interface because it was remembered", function () {
                chai_1.expect(interfaceNode3.wasForgotten()).to.be.false;
            });
            it("should not have forgotten the fourth interface because it was remembered", function () {
                chai_1.expect(interfaceNode4.wasForgotten()).to.be.false;
            });
            it("should have forgotten the created fifth interface because it was not remembered", function () {
                chai_1.expect(interfaceNode5.wasForgotten()).to.be.true;
            });
            it("should not throw if removing a created node in a block", function () {
                var newSourceFile = project.createSourceFile("file3.ts", "class MyClass {}");
                project.forgetNodesCreatedInBlock(function (remember) {
                    var classDec = newSourceFile.getClassOrThrow("MyClass");
                    classDec.remove();
                });
            });
            it("should throw if attempting to remember a node that was forgotten", function () {
                var newSourceFile = project.createSourceFile("file4.ts");
                project.forgetNodesCreatedInBlock(function (remember) {
                    var classDec = newSourceFile.addClass({ name: "Class" });
                    classDec.forget();
                    chai_1.expect(function () { return remember(classDec); }).to.throw(errors.InvalidOperationError);
                });
            });
            it("should get exceptions thrown in the body", function () {
                chai_1.expect(function () { return project.forgetNodesCreatedInBlock(function () { throw new Error(""); }); }).to.throw();
            });
        });
        describe("asynchronous", function () { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            var project, sourceFile, interfaceDec, classDec;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        project = new Project_1.Project({ useVirtualFileSystem: true });
                        sourceFile = project.createSourceFile("file.ts");
                        return [4 /*yield*/, project.forgetNodesCreatedInBlock(function (remember) { return __awaiter(_this, void 0, void 0, function () {
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: 
                                        // do something to cause this code to be added to the end of the execution queue
                                        return [4 /*yield*/, new Promise(function (resolve, reject) { return resolve(); })];
                                        case 1:
                                            // do something to cause this code to be added to the end of the execution queue
                                            _a.sent();
                                            classDec = sourceFile.addClass({ name: "Class" });
                                            interfaceDec = sourceFile.addInterface({ name: "Interface" });
                                            remember(interfaceDec);
                                            return [2 /*return*/];
                                    }
                                });
                            }); })];
                    case 1:
                        _a.sent();
                        it("should have forgotten the class", function () {
                            chai_1.expect(classDec.wasForgotten()).to.be.true;
                        });
                        it("should have not forgotten the interface", function () {
                            chai_1.expect(interfaceDec.wasForgotten()).to.be.false;
                        });
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("manipulating then getting something from the type checker", function () {
        it("should not error after manipulation", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var sourceFile = project.createSourceFile("myFile.ts", "function myFunction(param: string) {}");
            var param = sourceFile.getFunctions()[0].getParameters()[0];
            chai_1.expect(param.getType().getText()).to.equal("string");
            param.setType("number");
            chai_1.expect(param.getType().getText()).to.equal("number");
        });
    });
});
