"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var compiler = require("../../compiler");
var testHelpers_1 = require("../compiler/testHelpers");
var getMixinStructureFuncs = require("../../manipulation/helpers/getMixinStructureFunctions");
describe("fromAbstractableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromAbstractableNode(firstChild)).to.deep.equal(expectedStructure);
    }
    it("should get when abstract", function () {
        doTest("abstract class MyClass {}", { isAbstract: true });
    });
    it("should get when not abstract", function () {
        doTest("class MyClass {}", { isAbstract: false });
    });
});
describe("fromAmbientableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromAmbientableNode(firstChild)).to.deep.equal(expectedStructure);
    }
    it("should get when ambient", function () {
        doTest("declare class MyClass {}", { hasDeclareKeyword: true });
    });
    it("should get when not ambient", function () {
        doTest("class MyClass {}", { hasDeclareKeyword: false });
    });
});
describe("fromAsyncableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromAsyncableNode(firstChild)).to.deep.equal(expectedStructure);
    }
    it("should get when async", function () {
        doTest("async function identifier() {}", { isAsync: true });
    });
    it("should get when not async", function () {
        doTest("function identifier() {}", { isAsync: false });
    });
});
describe("fromAwaitableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromAwaitableNode(firstChild)).to.deep.equal(expectedStructure);
    }
    it("should get when is a generator", function () {
        doTest("for await (const x of []) {}", { isAwaited: true });
    });
    it("should get when not a generator", function () {
        doTest("for (const x of []) {}", { isAwaited: false });
    });
});
describe("fromExportableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromExportableNode(firstChild)).to.deep.equal(expectedStructure);
    }
    it("should get when default export", function () {
        doTest("export default function identifier() {}", { isDefaultExport: true, isExported: true });
    });
    it("should get as not default export if default exported on a different statement", function () {
        doTest("function identifier() {}\nexport default identifier;", { isDefaultExport: false, isExported: false });
    });
    it("should get when an export", function () {
        doTest("export function identifier() {}", { isDefaultExport: false, isExported: true });
    });
    it("should get when not exported", function () {
        doTest("function identifier() {}", { isDefaultExport: false, isExported: false });
    });
});
describe("fromGeneratorableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromGeneratorableNode(firstChild)).to.deep.equal(expectedStructure);
    }
    it("should get when is a generator", function () {
        doTest("function* identifier() {}", { isGenerator: true });
    });
    it("should get when not a generator", function () {
        doTest("function identifier() {}", { isGenerator: false });
    });
});
describe("fromReturnTypedNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromReturnTypedNode(firstChild)).to.deep.equal(expectedStructure);
    }
    it("should get when has a return type", function () {
        doTest("function identifier(): string {}", { returnType: "string" });
    });
    it("should get when not has a return type", function () {
        doTest("function identifier() {}", { returnType: undefined });
    });
});
describe("fromStaticableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromStaticableNode(firstChild.getMembers()[0])).to.deep.equal(expectedStructure);
    }
    it("should get when is static", function () {
        doTest("class Identifier { static method() {} }", { isStatic: true });
    });
    it("should get when not static", function () {
        doTest("class Identifier { method() {} }", { isStatic: false });
    });
});
describe("fromScopedNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromScopedNode(firstChild.getMembers()[0])).to.deep.equal(expectedStructure);
    }
    it("should get when has scope", function () {
        doTest("class Identifier { private method() {} }", { scope: compiler.Scope.Private });
    });
    it("should get when scope is not defined", function () {
        doTest("class Identifier { method() {} }", { scope: undefined });
    });
});
describe("fromScopeableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromScopeableNode(firstChild.getConstructors()[0].getParameters()[0])).to.deep.equal(expectedStructure);
    }
    it("should get when has scope", function () {
        doTest("class Identifier { constructor(private param: string) {} }", { scope: compiler.Scope.Private });
    });
    it("should get when scope is not defined", function () {
        doTest("class Identifier { constructor(param: string) {} }", { scope: undefined });
    });
});
describe("fromExtendsClauseableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromExtendsClauseableNode(firstChild)).to.deep.equal(expectedStructure);
    }
    it("should get no extends", function () {
        doTest("interface Identifier {}", { extends: undefined });
    });
    it("should get when has extends", function () {
        doTest("interface Identifier extends First, Second<Third> { }", { extends: ["First", "Second<Third>"] });
    });
});
describe("fromImplementsClauseableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromImplementsClauseableNode(firstChild)).to.deep.equal(expectedStructure);
    }
    it("should get no implements", function () {
        doTest("class Identifier {}", { implements: undefined });
    });
    it("should get when has implements", function () {
        doTest("class Identifier implements First, Second<Third> { }", { implements: ["First", "Second<Third>"] });
    });
});
describe("fromQuestionTokenableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromQuestionTokenableNode(firstChild.getMembers()[0])).to.deep.equal(expectedStructure);
    }
    it("should get when has question token", function () {
        doTest("class Identifier { prop?: string; }", { hasQuestionToken: true });
    });
    it("should get when not has question token", function () {
        doTest("class Identifier { prop: string; }", { hasQuestionToken: false });
    });
});
describe("fromReadonlyableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromReadonlyableNode(firstChild.getMembers()[0])).to.deep.equal(expectedStructure);
    }
    it("should get when is readonly", function () {
        doTest("class Identifier { readonly prop: string; }", { isReadonly: true });
    });
    it("should get when not readonly", function () {
        doTest("class Identifier { prop: string; }", { isReadonly: false });
    });
});
describe("fromTypedNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromTypedNode(firstChild.getMembers()[0])).to.deep.equal(expectedStructure);
    }
    it("should get when has a type", function () {
        doTest("class Identifier { prop: string; }", { type: "string" });
    });
    it("should get when not has a type", function () {
        doTest("class Identifier { prop; }", { type: undefined });
    });
});
describe("fromInitializerExpressionableNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromInitializerExpressionableNode(firstChild.getMembers()[0])).to.deep.equal(expectedStructure);
    }
    it("should get when has a an initailizer", function () {
        doTest("class Identifier { prop = 'some value'; }", { initializer: "'some value'" });
    });
    it("should get when not has an initailizer", function () {
        doTest("class Identifier { prop; }", { initializer: undefined });
    });
});
describe("fromNamedNode", function () {
    function doTest(startingCode, expectedStructure) {
        var firstChild = testHelpers_1.getInfoFromText(startingCode).firstChild;
        chai_1.expect(getMixinStructureFuncs.fromNamedNode(firstChild)).to.deep.equal(expectedStructure);
    }
    it("should get the name", function () {
        doTest("class Identifier { }", { name: "Identifier" });
    });
});
