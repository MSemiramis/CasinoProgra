"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testHelpers_1 = require("../testHelpers");
describe("Decorator", function () {
    function getFirstClassDecorator(code) {
        var result = testHelpers_1.getInfoFromText(code);
        var firstDecorator = result.firstChild.getDecorators()[0];
        return __assign({}, result, { firstDecorator: firstDecorator });
    }
    describe("isDecoratorFactory", function () {
        it("should not be a decorator factory when has no call expression", function () {
            var firstDecorator = getFirstClassDecorator("@decorator\nclass Identifier {}").firstDecorator;
            chai_1.expect(firstDecorator.isDecoratorFactory()).to.equal(false);
        });
        it("should be a decorator factory when has call expression", function () {
            var firstDecorator = getFirstClassDecorator("@decorator()\nclass Identifier {}").firstDecorator;
            chai_1.expect(firstDecorator.isDecoratorFactory()).to.equal(true);
        });
        it("should be a decorator factory when has call expression with parameters", function () {
            var firstDecorator = getFirstClassDecorator("@decorator('str', 23)\nclass Identifier {}").firstDecorator;
            chai_1.expect(firstDecorator.isDecoratorFactory()).to.equal(true);
        });
    });
    describe("setIsDecoratorFactory", function () {
        function doSettingTest(startText, expectedText) {
            var _a = getFirstClassDecorator(startText), firstDecorator = _a.firstDecorator, sourceFile = _a.sourceFile;
            var expr = firstDecorator.getExpression();
            firstDecorator.setIsDecoratorFactory(true);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(function () { return expr.getFullText(); }).to.not.throw(); // should not throw when accessing this moved node
        }
        it("should set as a decorator factory when not one", function () {
            doSettingTest("@decorator\nclass Identifier {}", "@decorator()\nclass Identifier {}");
        });
        it("should set as a decorator factory when not one and is a property access expression", function () {
            doSettingTest("@dec.prop\nclass Identifier {}", "@dec.prop()\nclass Identifier {}");
        });
        function doUnSettingTest(startText, expectedText) {
            var _a = getFirstClassDecorator(startText), firstDecorator = _a.firstDecorator, sourceFile = _a.sourceFile;
            var expr = firstDecorator.getCallExpressionOrThrow().getExpression();
            firstDecorator.setIsDecoratorFactory(false);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(function () { return expr.getFullText(); }).to.not.throw(); // should not throw when accessing this moved node
        }
        it("should set as not a decorator factory when is one", function () {
            doUnSettingTest("@decorator()\nclass Identifier {}", "@decorator\nclass Identifier {}");
        });
        it("should set as not a decorator factory when is one and is a property access expression", function () {
            doUnSettingTest("@dec.prop()\nclass Identifier {}", "@dec.prop\nclass Identifier {}");
        });
    });
    describe("getNameNode", function () {
        function doTest(text, expectedName) {
            var firstDecorator = getFirstClassDecorator(text).firstDecorator;
            chai_1.expect(firstDecorator.getNameNode().getText()).to.equal(expectedName);
        }
        it("should get the name node for a non-decorator factory", function () {
            doTest("@decorator\nclass Identifier {}", "decorator");
        });
        it("should get the name node for a non-decorator factory decorator with a namespace", function () {
            doTest("@namespaceTest.decorator\nclass Identifier {}", "decorator");
        });
        it("should get the name node for a decorator factory", function () {
            doTest("@decorator()\nclass Identifier {}", "decorator");
        });
        it("should get the name node for a decorator factory decorator with a namespace", function () {
            doTest("@namespaceTest.decorator()\nclass Identifier {}", "decorator");
        });
    });
    describe("getName", function () {
        function doTest(text, expectedName) {
            var firstDecorator = getFirstClassDecorator(text).firstDecorator;
            chai_1.expect(firstDecorator.getName()).to.equal(expectedName);
        }
        it("should get the name for a non-decorator factory", function () {
            doTest("@decorator\nclass Identifier {}", "decorator");
        });
        it("should get the name for a non-decorator factory decorator with a namespace", function () {
            doTest("@namespaceTest.decorator\nclass Identifier {}", "decorator");
        });
        it("should get the name for a decorator factory", function () {
            doTest("@decorator()\nclass Identifier {}", "decorator");
        });
        it("should get the name for a decorator factory decorator with a namespace", function () {
            doTest("@namespaceTest.decorator()\nclass Identifier {}", "decorator");
        });
    });
    describe("getFullName", function () {
        function doTest(text, expectedName) {
            var firstDecorator = getFirstClassDecorator(text).firstDecorator;
            chai_1.expect(firstDecorator.getFullName()).to.equal(expectedName);
        }
        it("should get the name for a non-decorator factory", function () {
            doTest("@decorator\nclass Identifier {}", "decorator");
        });
        it("should get the name for a non-decorator factory decorator with a namespace", function () {
            doTest("@namespaceTest.decorator\nclass Identifier {}", "namespaceTest.decorator");
        });
        it("should get the name for a decorator factory", function () {
            doTest("@decorator()\nclass Identifier {}", "decorator");
        });
        it("should get the name for a decorator factory decorator with a namespace", function () {
            doTest("@namespaceTest.decorator()\nclass Identifier {}", "namespaceTest.decorator");
        });
    });
    describe("getCallExpression", function () {
        it("should return undefined when not a decorator factory", function () {
            var firstDecorator = getFirstClassDecorator("@decorator\nclass Identifier {}").firstDecorator;
            chai_1.expect(firstDecorator.getCallExpression()).to.be.undefined;
        });
        it("should get the compiler call expression when a decorator factory", function () {
            var firstDecorator = getFirstClassDecorator("@decorator('str', 4)\nclass Identifier {}").firstDecorator;
            chai_1.expect(firstDecorator.getCallExpression().getArguments().length).to.equal(2);
        });
    });
    describe("getCallExpressionOrThrow", function () {
        it("should return undefined when not a decorator factory", function () {
            var firstDecorator = getFirstClassDecorator("@decorator\nclass Identifier {}").firstDecorator;
            chai_1.expect(function () { return firstDecorator.getCallExpressionOrThrow(); }).to.throw();
        });
        it("should get the compiler call expression when a decorator factory", function () {
            var firstDecorator = getFirstClassDecorator("@decorator('str', 4)\nclass Identifier {}").firstDecorator;
            chai_1.expect(firstDecorator.getCallExpressionOrThrow().getArguments().length).to.equal(2);
        });
    });
    describe("getArguments", function () {
        it("should return an empty array when not a decorator factory", function () {
            var firstDecorator = getFirstClassDecorator("@decorator\nclass Identifier {}").firstDecorator;
            chai_1.expect(firstDecorator.getArguments()).to.deep.equal([]);
        });
        it("should get the arguments when a decorator factory", function () {
            var firstDecorator = getFirstClassDecorator("@decorator('str', 4)\nclass Identifier {}").firstDecorator;
            chai_1.expect(firstDecorator.getArguments().length).to.equal(2);
        });
    });
    describe("insertArguments", function () {
        function doTest(code, index, texts, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.getDecorators()[0].insertArguments(index, texts);
            chai_1.expect(result.map(function (t) { return t.getText(); })).to.deep.equal(texts);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert multiple args when none exist", function () {
            doTest("@dec()\nclass T {}", 0, ["5", "6", "7"], "@dec(5, 6, 7)\nclass T {}");
        });
        it("should insert multiple args at the beginning", function () {
            doTest("@dec(3)\nclass T {}", 0, ["1", "2"], "@dec(1, 2, 3)\nclass T {}");
        });
        it("should insert multiple args in the middle", function () {
            doTest("@dec(1, 4)\nclass T {}", 1, ["2", "3"], "@dec(1, 2, 3, 4)\nclass T {}");
        });
        it("should insert multiple args at the end", function () {
            doTest("@dec(1)\nclass T {}", 1, ["2", "3"], "@dec(1, 2, 3)\nclass T {}");
        });
        it("should insert args when a type argument exists", function () {
            doTest("@dec<3>(1)\nclass T {}", 1, ["2", "3"], "@dec<3>(1, 2, 3)\nclass T {}");
        });
        it("should set as decorator factory when not", function () {
            doTest("@dec\nclass T {}", 0, ["1"], "@dec(1)\nclass T {}");
        });
    });
    describe("insertArgument", function () {
        function doTest(code, index, text, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.getDecorators()[0].insertArgument(index, text);
            chai_1.expect(result.getText()).to.equal(text);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert an arg", function () {
            doTest("@dec(1, 3)\nclass T {}", 1, "2", "@dec(1, 2, 3)\nclass T {}");
        });
        it("should set as decorator factory when not", function () {
            doTest("@dec\nclass T {}", 0, "1", "@dec(1)\nclass T {}");
        });
    });
    describe("addArguments", function () {
        function doTest(code, texts, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.getDecorators()[0].addArguments(texts);
            chai_1.expect(result.map(function (t) { return t.getText(); })).to.deep.equal(texts);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add multiple args", function () {
            doTest("@dec(1)\nclass T {}", ["2", "3"], "@dec(1, 2, 3)\nclass T {}");
        });
        it("should set as decorator factory when not", function () {
            doTest("@dec\nclass T {}", ["1"], "@dec(1)\nclass T {}");
        });
    });
    describe("addArgument", function () {
        function doTest(code, text, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.getDecorators()[0].addArgument(text);
            chai_1.expect(result.getText()).to.equal(text);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add an arg", function () {
            doTest("@dec(1, 2)\nclass T {}", "3", "@dec(1, 2, 3)\nclass T {}");
        });
        it("should set as decorator factory when not", function () {
            doTest("@dec\nclass T {}", "1", "@dec(1)\nclass T {}");
        });
    });
    describe("getTypeArguments", function () {
        it("should return an empty array when not a decorator factory", function () {
            var firstDecorator = getFirstClassDecorator("@decorator\nclass Identifier {}").firstDecorator;
            chai_1.expect(firstDecorator.getTypeArguments()).to.deep.equal([]);
        });
        it("should get the type arguments when a decorator factory", function () {
            var firstDecorator = getFirstClassDecorator("@decorator<number, string>()\nclass Identifier {}").firstDecorator;
            chai_1.expect(firstDecorator.getTypeArguments().length).to.equal(2);
        });
    });
    describe("insertTypeArguments", function () {
        function doTest(code, index, texts, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.getDecorators()[0].insertTypeArguments(index, texts);
            chai_1.expect(result.map(function (t) { return t.getText(); })).to.deep.equal(texts);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        // most of these tests are in typeArgumentedNodeTests
        it("should insert multiple type args when none exist", function () {
            doTest("@dec()\nclass T {}", 0, ["5", "6", "7"], "@dec<5, 6, 7>()\nclass T {}");
        });
    });
    describe("insertTypeArgument", function () {
        function doTest(code, index, text, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.getDecorators()[0].insertTypeArgument(index, text);
            chai_1.expect(result.getText()).to.equal(text);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert a type arg", function () {
            doTest("@dec<1, 3>()\nclass T {}", 1, "2", "@dec<1, 2, 3>()\nclass T {}");
        });
    });
    describe("addTypeArguments", function () {
        function doTest(code, texts, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.getDecorators()[0].addTypeArguments(texts);
            chai_1.expect(result.map(function (t) { return t.getText(); })).to.deep.equal(texts);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add multiple type args", function () {
            doTest("@dec<1>()\nclass T {}", ["2", "3"], "@dec<1, 2, 3>()\nclass T {}");
        });
    });
    describe("addTypeArgument", function () {
        function doTest(code, text, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.getDecorators()[0].addTypeArgument(text);
            chai_1.expect(result.getText()).to.equal(text);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add a type arg", function () {
            doTest("@dec<1, 2>()\nclass T {}", "3", "@dec<1, 2, 3>()\nclass T {}");
        });
    });
    describe("removeTypeArgument", function () {
        function doRemoveTypeArgTest(code, argIndexToRemove, expectedText) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.getDecorators()[0].removeTypeArgument(argIndexToRemove);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
        }
        it("should throw when not a call expression", function () {
            var firstChild = testHelpers_1.getInfoFromText("@decorator\nclass MyClass {}").firstChild;
            chai_1.expect(function () { return firstChild.getDecorators()[0].getCallExpression().removeTypeArgument(0); }).to.throw();
        });
        it("should remove when the only type argument", function () {
            doRemoveTypeArgTest("@decorator<MyClass>(arg1, arg2)\nclass MyClass {}", 0, "@decorator(arg1, arg2)\nclass MyClass {}");
        });
    });
    describe("remove", function () {
        describe("class decorators", function () {
            function doTest(code, index, expectedText) {
                var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.getDecorators()[index].remove();
                chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            }
            it("should remove when it's the only class decorator", function () {
                doTest("@decorator(2, 5, 3)\nclass T {}", 0, "class T {}");
            });
            it("should remove when it's the first class decorator on the same line", function () {
                doTest("@dec1 @dec2 @dec3\nclass T {}", 0, "@dec2 @dec3\nclass T {}");
            });
            it("should remove when it's the middle class decorator on the same line", function () {
                doTest("@dec1 @dec2 @dec3\nclass T {}", 1, "@dec1 @dec3\nclass T {}");
            });
            it("should remove when it's the last class decorator on the same line", function () {
                doTest("@dec1 @dec2 @dec3\nclass T {}", 2, "@dec1 @dec2\nclass T {}");
            });
            it("should remove when it's the first class decorator on different lines", function () {
                doTest("@dec1\n@dec2\n@dec3\nclass T {}", 0, "@dec2\n@dec3\nclass T {}");
            });
            it("should remove when it's the middle class decorator on different lines", function () {
                doTest("@dec1\n@dec2\n@dec3\nclass T {}", 1, "@dec1\n@dec3\nclass T {}");
            });
            it("should remove when it's the last class decorator on different lines", function () {
                doTest("@dec1\n@dec2\n@dec3\nclass T {}", 2, "@dec1\n@dec2\nclass T {}");
            });
        });
        describe("parameter decorators", function () {
            function doTest(code, index, expectedText) {
                var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.getInstanceMethods()[0].getParameters()[0].getDecorators()[index].remove();
                chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            }
            it("should remove when it's the only parameter decorator", function () {
                doTest("class T { myMethod(@dec param) {} }", 0, "class T { myMethod(param) {} }");
            });
            it("should remove when it's the first parameter decorator", function () {
                doTest("class T { myMethod(@dec1 @dec2 @dec3 param) {} }", 0, "class T { myMethod(@dec2 @dec3 param) {} }");
            });
            it("should remove when it's the middle parameter decorator", function () {
                doTest("class T { myMethod(@dec1 @dec2 @dec3 param) {} }", 1, "class T { myMethod(@dec1 @dec3 param) {} }");
            });
            it("should remove when it's the last parameter decorator", function () {
                doTest("class T { myMethod(@dec1 @dec2 @dec3 param) {} }", 2, "class T { myMethod(@dec1 @dec2 param) {} }");
            });
        });
    });
    describe("removeArgument", function () {
        function doTest(text, removeIndex, expectedText) {
            var _a = testHelpers_1.getInfoFromText(text), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.getDecorators()[0].removeArgument(removeIndex);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
        }
        // most of these tests are in argumentedNodeTests
        it("should throw when removing and none exist", function () {
            var _a = testHelpers_1.getInfoFromText("@test()\nclass T {}"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            chai_1.expect(function () { return firstChild.getDecorators()[0].removeArgument(0); }).to.throw();
        });
        it("should remove a decorator argument", function () {
            doTest("@test(1, 2, 3)\nclass T {}", 2, "@test(1, 2)\nclass T {}");
        });
    });
});
