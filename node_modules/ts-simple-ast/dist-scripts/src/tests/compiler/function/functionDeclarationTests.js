"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var compiler_1 = require("../../../compiler");
var testHelpers_1 = require("../testHelpers");
describe("FunctionDeclaration", function () {
    describe("insertOverloads", function () {
        function doTest(startCode, index, structures, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.insertOverloads(index, structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert when no other overloads exist", function () {
            doTest("function identifier() {}\n", 0, [{ returnType: "number" }, {}], "function identifier(): number;\nfunction identifier();\nfunction identifier() {}\n");
        });
        it("should insert with the ambientable and exportable nodes the same as the implementation signature unless overwritten", function () {
            doTest("declare async function* identifier(param: string): string {}\n", 0, [{ returnType: "number", hasDeclareKeyword: false }, {}], "function identifier(): number;\ndeclare function identifier();\ndeclare async function* identifier(param: string): string {}\n");
        });
        it("should be able to insert at start when another overload exists", function () {
            doTest("function identifier();\nfunction identifier() {}\n", 0, [{ returnType: "string" }], "function identifier(): string;\nfunction identifier();\nfunction identifier() {}\n");
        });
        it("should be able to insert at end when another overload exists", function () {
            doTest("function identifier();\nfunction identifier() {}\n", 1, [{ returnType: "string" }], "function identifier();\nfunction identifier(): string;\nfunction identifier() {}\n");
        });
        it("should be able to insert in the middle when other overloads exists", function () {
            doTest("function identifier();\nfunction identifier();\nfunction identifier() {}\n", 1, [{ returnType: "string" }], "function identifier();\nfunction identifier(): string;\nfunction identifier();\nfunction identifier() {}\n");
        });
    });
    describe("insertOverload", function () {
        function doTest(startCode, index, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.insertOverload(index, structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.FunctionDeclaration);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert", function () {
            doTest("function identifier();\nfunction identifier();\nfunction identifier() {}\n", 1, { returnType: "number" }, "function identifier();\nfunction identifier(): number;\nfunction identifier();\nfunction identifier() {}\n");
        });
    });
    describe("addOverloads", function () {
        function doTest(startCode, structures, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.addOverloads(structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add at the end", function () {
            doTest("function identifier();\nfunction identifier() {}\n", [{ returnType: "number" }, { returnType: "string" }], "function identifier();\nfunction identifier(): number;\nfunction identifier(): string;\nfunction identifier() {}\n");
        });
    });
    describe("addOverload", function () {
        function doTest(startCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.addOverload(structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.FunctionDeclaration);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add at the end", function () {
            doTest("function identifier();\nfunction identifier() {}\n", { returnType: "number" }, "function identifier();\nfunction identifier(): number;\nfunction identifier() {}\n");
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("function identifier() {\n}", {}, "function identifier() {\n}");
        });
        it("should modify when changed", function () {
            var structure = {
                overloads: [{ returnType: "string" }]
            };
            doTest("function identifier() {\n}", structure, "function identifier(): string;\nfunction identifier() {\n}");
        });
    });
    describe("remove", function () {
        function doTest(text, index, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            sourceFile.getFunctions()[index].remove();
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
        }
        function doOverloadTest(text, index, overloadIndex, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            sourceFile.getFunctions()[index].getOverloads()[overloadIndex].remove();
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
        }
        it("should remove the function declaration", function () {
            doTest("function I() {}\n\nfunction J() {}\n\nfunction K() {}", 1, "function I() {}\n\nfunction K() {}");
        });
        it("should remove the function declaration and its overloads", function () {
            doTest("function I() {}\n\nfunction J(): void;\nfunction J() {}\n\nfunction K() {}", 1, "function I() {}\n\nfunction K() {}");
        });
        it("should remove the function declaration overload when the first", function () {
            doOverloadTest("function I() {}\n\nfunction J(): void;\nfunction J() {}\n\nfunction K() {}", 1, 0, "function I() {}\n\nfunction J() {}\n\nfunction K() {}");
        });
        it("should remove the function declaration overload when the middle", function () {
            doOverloadTest("function I() {}\n\nfunction J(first): void;\nfunction J(second): void;\nfunction J(third): void;\nfunction J() {}\n\nfunction K() {}", 1, 1, "function I() {}\n\nfunction J(first): void;\nfunction J(third): void;\nfunction J() {}\n\nfunction K() {}");
        });
        it("should remove the function declaration overload when last", function () {
            doOverloadTest("function I() {}\n\nfunction J(first): void;\nfunction J(second): void;\nfunction J() {}\n\nfunction K() {}", 1, 1, "function I() {}\n\nfunction J(first): void;\nfunction J() {}\n\nfunction K() {}");
        });
    });
});
