"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var typescript_1 = require("../../../../typescript");
var compiler_1 = require("../../../../compiler");
var testHelpers_1 = require("../../testHelpers");
describe("ObjectLiteralExpression", function () {
    function getObjectLiteralExpression(text) {
        var opts = testHelpers_1.getInfoFromText(text);
        var objectLiteralExpression = opts.sourceFile.getFirstDescendantByKindOrThrow(typescript_1.SyntaxKind.ObjectLiteralExpression);
        return __assign({ objectLiteralExpression: objectLiteralExpression }, opts);
    }
    describe("getProperties", function () {
        function doTest(text, props) {
            var objectLiteralExpression = getObjectLiteralExpression(text).objectLiteralExpression;
            chai_1.expect(objectLiteralExpression.getProperties().map(function (p) { return p.getText(); })).to.deep.equal(props);
        }
        it("should get the properties from the object literal expression", function () {
            doTest("const t = { prop: 5, prop2: 8, prop3 };", ["prop: 5", "prop2: 8", "prop3"]);
        });
    });
    describe("getProperty", function () {
        it("should return undefined when it doesn't exist", function () {
            var objectLiteralExpression = getObjectLiteralExpression("const t = { prop: 5 }").objectLiteralExpression;
            var property = objectLiteralExpression.getProperty("prop2");
            chai_1.expect(property).to.be.undefined;
        });
        it("should get the property by name", function () {
            var objectLiteralExpression = getObjectLiteralExpression("const t = { prop: 5 }").objectLiteralExpression;
            var property = objectLiteralExpression.getProperty("prop");
            chai_1.expect(property.getText()).to.equal("prop: 5");
        });
        it("should get the property by a find function", function () {
            var objectLiteralExpression = getObjectLiteralExpression("const t = { prop: 5 }").objectLiteralExpression;
            var property = objectLiteralExpression.getProperty(function (p) { return p.getKind() === typescript_1.SyntaxKind.PropertyAssignment; });
            chai_1.expect(property.getText()).to.equal("prop: 5");
        });
    });
    describe("getPropertyOrThrow", function () {
        it("should return undefined when it doesn't exist", function () {
            var objectLiteralExpression = getObjectLiteralExpression("const t = { prop: 5 }").objectLiteralExpression;
            chai_1.expect(function () { return objectLiteralExpression.getPropertyOrThrow("prop2"); }).to.throw();
        });
        it("should get the property by name", function () {
            var objectLiteralExpression = getObjectLiteralExpression("const t = { prop: 5 }").objectLiteralExpression;
            var property = objectLiteralExpression.getPropertyOrThrow("prop");
            chai_1.expect(property.getText()).to.equal("prop: 5");
        });
        it("should get the property by a find function", function () {
            var objectLiteralExpression = getObjectLiteralExpression("const t = { prop: 5 }").objectLiteralExpression;
            var property = objectLiteralExpression.getPropertyOrThrow(function (p) { return p.getKind() === typescript_1.SyntaxKind.PropertyAssignment; });
            chai_1.expect(property.getText()).to.equal("prop: 5");
        });
    });
    /* Property Assignments */
    describe("insertPropertyAssignments", function () {
        function doTest(text, index, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertPropertyAssignments(index, structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should insert the property assignments when none exist", function () {
            doTest("const t = {};", 0, [{ name: "prop1", initializer: "4" }, { name: "prop2", initializer: "5" }], "const t = {\n    prop1: 4,\n    prop2: 5\n};");
        });
        it("should insert the property assignments when none exist and there is some whitespace in the current object", function () {
            doTest("const t = {\n};", 0, [{ name: "prop", initializer: "5" }], "const t = {\n    prop: 5\n};");
        });
        it("should insert the property assignments at the beginning", function () {
            doTest("const t = {\n    prop: 5\n};", 0, [{ name: "prop1", initializer: "\"test\"" }], "const t = {\n    prop1: \"test\",\n    prop: 5\n};");
        });
        it("should insert the property assignments in the middle", function () {
            doTest("const t = {\n    prop: 5,\n    prop3\n};", 1, [{ name: "prop2", initializer: "4" }], "const t = {\n    prop: 5,\n    prop2: 4,\n    prop3\n};");
        });
        it("should insert the property assignments at the end", function () {
            doTest("const t = {\n    prop: 5\n};", 1, [{ name: "prop1", initializer: "4" }], "const t = {\n    prop: 5,\n    prop1: 4\n};");
        });
    });
    describe("insertPropertyAssignment", function () {
        function doTest(text, index, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertPropertyAssignment(index, structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.PropertyAssignment);
        }
        it("should insert a property assignment", function () {
            doTest("const t = {\n    prop2: 5\n};", 0, { name: "prop1", initializer: "4" }, "const t = {\n    prop1: 4,\n    prop2: 5\n};");
        });
    });
    describe("addPropertyAssignments", function () {
        function doTest(text, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addPropertyAssignments(structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should add property assignments", function () {
            doTest("const t = {\n    prop1: 5\n};", [{ name: "prop2", initializer: "3" }, { name: "prop3", initializer: "2" }], "const t = {\n    prop1: 5,\n    prop2: 3,\n    prop3: 2\n};");
        });
    });
    describe("addPropertyAssignment", function () {
        function doTest(text, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addPropertyAssignment(structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.PropertyAssignment);
        }
        it("should add a property assignment", function () {
            doTest("const t = {\n    prop1: 5\n};", { name: "prop2", initializer: "2" }, "const t = {\n    prop1: 5,\n    prop2: 2\n};");
        });
    });
    /* Shorthand Property Assignments */
    describe("insertShorthandPropertyAssignments", function () {
        function doTest(text, index, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertShorthandPropertyAssignments(index, structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should insert the shorthand property assignments in the middle", function () {
            doTest("const t = {\n    prop: 5,\n    prop4\n};", 1, [{ name: "prop2" }, { name: "prop3" }], "const t = {\n    prop: 5,\n    prop2,\n    prop3,\n    prop4\n};");
        });
    });
    describe("insertShorthandPropertyAssignment", function () {
        function doTest(text, index, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertShorthandPropertyAssignment(index, structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ShorthandPropertyAssignment);
        }
        it("should insert a shorthand property assignment", function () {
            doTest("const t = {\n    prop2: 5\n};", 0, { name: "prop1" }, "const t = {\n    prop1,\n    prop2: 5\n};");
        });
    });
    describe("addShorthandPropertyAssignments", function () {
        function doTest(text, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addShorthandPropertyAssignments(structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should add shorthand property assignments", function () {
            doTest("const t = {\n    prop1: 5\n};", [{ name: "prop2" }, { name: "prop3" }], "const t = {\n    prop1: 5,\n    prop2,\n    prop3\n};");
        });
    });
    describe("addShorthandPropertyAssignment", function () {
        function doTest(text, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addShorthandPropertyAssignment(structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ShorthandPropertyAssignment);
        }
        it("should add a shorthand property assignment", function () {
            doTest("const t = {\n    prop1: 5\n};", { name: "prop2" }, "const t = {\n    prop1: 5,\n    prop2\n};");
        });
    });
    /* Spread Assignments */
    describe("insertSpreadAssignments", function () {
        function doTest(text, index, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertSpreadAssignments(index, structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should insert the spread assignments in the middle", function () {
            doTest("const t = {\n    prop: 5,\n    prop4\n};", 1, [{ expression: "prop2" }, { expression: "prop3" }], "const t = {\n    prop: 5,\n    ...prop2,\n    ...prop3,\n    prop4\n};");
        });
    });
    describe("insertSpreadAssignment", function () {
        function doTest(text, index, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertSpreadAssignment(index, structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.SpreadAssignment);
        }
        it("should insert a spread assignment", function () {
            doTest("const t = {\n    prop2: 5\n};", 0, { expression: "prop1" }, "const t = {\n    ...prop1,\n    prop2: 5\n};");
        });
    });
    describe("addSpreadAssignments", function () {
        function doTest(text, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addSpreadAssignments(structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should add spread assignments", function () {
            doTest("const t = {\n    prop1: 5\n};", [{ expression: "prop2" }, { expression: "prop3" }], "const t = {\n    prop1: 5,\n    ...prop2,\n    ...prop3\n};");
        });
    });
    describe("addSpreadAssignment", function () {
        function doTest(text, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addSpreadAssignment(structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.SpreadAssignment);
        }
        it("should add a spread assignment", function () {
            doTest("const t = {\n    prop1: 5\n};", { expression: "prop2" }, "const t = {\n    prop1: 5,\n    ...prop2\n};");
        });
    });
    /* Methods */
    describe("insertMethods", function () {
        function doTest(text, index, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertMethods(index, structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should insert the methods in the middle", function () {
            doTest("const t = {\n    prop: 5,\n    prop4\n};", 1, [{ name: "prop2" }, { name: "prop3" }], "const t = {\n    prop: 5,\n    prop2() {\n    },\n    prop3() {\n    },\n    prop4\n};");
        });
    });
    describe("insertMethod", function () {
        function doTest(text, index, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertMethod(index, structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.MethodDeclaration);
        }
        it("should insert a method", function () {
            doTest("const t = {\n    prop2: 5\n};", 0, { name: "prop1" }, "const t = {\n    prop1() {\n    },\n    prop2: 5\n};");
        });
    });
    describe("addMethods", function () {
        function doTest(text, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addMethods(structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should add methods", function () {
            doTest("const t = {\n    prop1: 5\n};", [{ name: "prop2" }, { name: "prop3" }], "const t = {\n    prop1: 5,\n    prop2() {\n    },\n    prop3() {\n    }\n};");
        });
    });
    describe("addMethod", function () {
        function doTest(text, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addMethod(structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.MethodDeclaration);
        }
        it("should add a method", function () {
            doTest("const t = {\n    prop1: 5\n};", { name: "prop2" }, "const t = {\n    prop1: 5,\n    prop2() {\n    }\n};");
        });
    });
    /* Get Accessor */
    describe("insertGetAccessors", function () {
        function doTest(text, index, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertGetAccessors(index, structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should insert the get accessors in the middle", function () {
            doTest("const t = {\n    prop: 5,\n    prop4\n};", 1, [{ name: "prop2" }, { name: "prop3" }], "const t = {\n    prop: 5,\n    get prop2() {\n    },\n    get prop3() {\n    },\n    prop4\n};");
        });
    });
    describe("insertGetAccessor", function () {
        function doTest(text, index, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertGetAccessor(index, structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.GetAccessorDeclaration);
        }
        it("should insert a get accessor", function () {
            doTest("const t = {\n    prop2: 5\n};", 0, { name: "prop1" }, "const t = {\n    get prop1() {\n    },\n    prop2: 5\n};");
        });
    });
    describe("addGetAccessors", function () {
        function doTest(text, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addGetAccessors(structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should add get accessors", function () {
            doTest("const t = {\n    prop1: 5\n};", [{ name: "prop2" }, { name: "prop3" }], "const t = {\n    prop1: 5,\n    get prop2() {\n    },\n    get prop3() {\n    }\n};");
        });
    });
    describe("addGetAccessor", function () {
        function doTest(text, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addGetAccessor(structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.GetAccessorDeclaration);
        }
        it("should add a get accessor", function () {
            doTest("const t = {\n    prop1: 5\n};", { name: "prop2" }, "const t = {\n    prop1: 5,\n    get prop2() {\n    }\n};");
        });
    });
    /* Set Accessor */
    describe("insertSetAccessors", function () {
        function doTest(text, index, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertSetAccessors(index, structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should insert the set accessors in the middle", function () {
            doTest("const t = {\n    prop: 5,\n    prop4\n};", 1, [{ name: "prop2" }, { name: "prop3" }], "const t = {\n    prop: 5,\n    set prop2() {\n    },\n    set prop3() {\n    },\n    prop4\n};");
        });
    });
    describe("insertSetAccessor", function () {
        function doTest(text, index, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.insertSetAccessor(index, structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.SetAccessorDeclaration);
        }
        it("should insert a set accessor", function () {
            doTest("const t = {\n    prop2: 5\n};", 0, { name: "prop1" }, "const t = {\n    set prop1() {\n    },\n    prop2: 5\n};");
        });
    });
    describe("addSetAccessors", function () {
        function doTest(text, structures, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addSetAccessors(structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.deep.equal(structures.length);
        }
        it("should add set accessors", function () {
            doTest("const t = {\n    prop1: 5\n};", [{ name: "prop2" }, { name: "prop3" }], "const t = {\n    prop1: 5,\n    set prop2() {\n    },\n    set prop3() {\n    }\n};");
        });
    });
    describe("addSetAccessor", function () {
        function doTest(text, structure, expectedText) {
            var _a = getObjectLiteralExpression(text), sourceFile = _a.sourceFile, objectLiteralExpression = _a.objectLiteralExpression;
            var result = objectLiteralExpression.addSetAccessor(structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.SetAccessorDeclaration);
        }
        it("should add a set accessor", function () {
            doTest("const t = {\n    prop1: 5\n};", { name: "prop2" }, "const t = {\n    prop1: 5,\n    set prop2() {\n    }\n};");
        });
    });
});
