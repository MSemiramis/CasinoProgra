"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var typescript_1 = require("../../../typescript");
var testHelpers_1 = require("../testHelpers");
describe("TypeReferenceNode", function () {
    function getTypeReferenceNode(text) {
        var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
        return sourceFile.getVariableDeclarations()[0].getTypeNodeOrThrow();
    }
    describe("getTypeName", function () {
        function doTest(text, expectedSyntaxKind, expectedTypeName) {
            var typeRefNode = getTypeReferenceNode(text);
            chai_1.expect(typeRefNode.getTypeName().getKind()).to.equal(expectedSyntaxKind);
            chai_1.expect(typeRefNode.getTypeName().getText()).to.equal(expectedTypeName);
        }
        it("should get the type name when an identifier", function () {
            doTest("const myVariable: Class<string>;", typescript_1.SyntaxKind.Identifier, "Class");
        });
        it("should get the type name when a fully qualified name", function () {
            doTest("const myVariable: Class.Tests<string>;", typescript_1.SyntaxKind.QualifiedName, "Class.Tests");
        });
    });
    describe("getTypeArguments", function () {
        function doTest(text, expectedArgs) {
            var typeRefNode = getTypeReferenceNode(text);
            chai_1.expect(typeRefNode.getTypeArguments().map(function (t) { return t.getText(); })).to.deep.equal(expectedArgs);
        }
        it("should return empty an empty array when there are no type args", function () {
            doTest("const myVariable: Class.Tests;", []);
        });
        it("should get the type args when an identifier", function () {
            doTest("const myVariable: Class<string>;", ["string"]);
        });
        it("should get the type args when a fully qualified name", function () {
            doTest("const myVariable: Class.Tests<string>;", ["string"]);
        });
    });
});
