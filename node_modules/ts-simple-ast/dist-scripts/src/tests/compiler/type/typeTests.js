"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var typescript_1 = require("../../../typescript");
var fileSystem_1 = require("../../../fileSystem");
var testHelpers_1 = require("../testHelpers");
describe("Type", function () {
    function getInfoFromTextWithTypeChecking(text) {
        return testHelpers_1.getInfoFromText(text, { host: new fileSystem_1.VirtualFileSystemHost(), includeLibDts: true, compilerOptions: { strictNullChecks: true } });
    }
    function getTypeFromText(text) {
        var result = getInfoFromTextWithTypeChecking(text);
        return __assign({}, result, { firstType: result.firstChild.getDeclarations()[0].getType() });
    }
    function getTypeAliasTypeFromText(text) {
        var result = getInfoFromTextWithTypeChecking(text);
        return __assign({}, result, { firstType: result.firstChild.getTypeNodeOrThrow().getType() });
    }
    describe("compilerType", function () {
        it("should get the compiler type", function () {
            var firstType = getTypeFromText("let myType: string;").firstType;
            chai_1.expect(firstType.compilerType.flags).to.equal(typescript_1.TypeFlags.String);
        });
    });
    describe("getText", function () {
        var longType = "string | number | Date | { reallyReallyLooooooonnnnnnnnnnnnggggggggggggggggNnnnnnnaaaaaaaaammmmmmmmmmmeeeeee: string; }";
        it("should get the text", function () {
            var firstType = getTypeFromText("let myType: string[];").firstType;
            chai_1.expect(firstType.getText()).to.equal("string[]");
        });
        it("should get the text when providing the enclosing node", function () {
            var _a = getTypeFromText("let myType: " + longType + ";"), firstChild = _a.firstChild, firstType = _a.firstType;
            chai_1.expect(firstType.getText(firstChild)).to.equal(longType);
        });
        it("should use the type format flags", function () {
            var _a = getTypeFromText("let myType: " + longType + ";"), firstChild = _a.firstChild, firstType = _a.firstType;
            chai_1.expect(firstType.getText(firstChild, typescript_1.TypeFormatFlags.None)).to.equal(longType.substring(0, 97) + "...");
        });
    });
    describe("getProperties", function () {
        it("should get the properties when there are none", function () {
            var firstType = getTypeFromText("let myType: {};").firstType;
            chai_1.expect(firstType.getProperties().length).to.equal(0);
        });
        it("should get the properties of a non-object type", function () {
            var firstType = getTypeFromText("let myType: 1;").firstType;
            chai_1.expect(firstType.getProperties().length).to.equal(6);
        });
        it("should get the properties when some exist", function () {
            var firstType = getTypeFromText("let myType: { str: string; };").firstType;
            var props = firstType.getProperties();
            chai_1.expect(props.length).to.equal(1);
            chai_1.expect(props[0].getName()).to.equal("str");
        });
    });
    describe("getProperty", function () {
        it("should get the property by name", function () {
            var firstType = getTypeFromText("let myType: { str: string; other: number; };").firstType;
            var prop = firstType.getProperty("other");
            chai_1.expect(prop.getName()).to.equal("other");
        });
        it("should get the property by function", function () {
            var firstType = getTypeFromText("let myType: { str: string; other: number; };").firstType;
            var prop = firstType.getProperty(function (p) { return p.getName() === "other"; });
            chai_1.expect(prop.getName()).to.equal("other");
        });
    });
    describe("getApparentProperties", function () {
        it("should return the apparent properties of a type", function () {
            var firstType = getTypeFromText("let myType: 1;").firstType;
            chai_1.expect(firstType.getApparentProperties().length).to.equal(6);
        });
    });
    describe("getApparentProperty", function () {
        it("should get the property by name", function () {
            var firstType = getTypeFromText("let myType: { str: string; other: number; };").firstType;
            var prop = firstType.getApparentProperty("other");
            chai_1.expect(prop.getName()).to.equal("other");
        });
        it("should get the property by function", function () {
            var firstType = getTypeFromText("let myType: { str: string; other: number; };").firstType;
            var prop = firstType.getApparentProperty(function (p) { return p.getName() === "other"; });
            chai_1.expect(prop.getName()).to.equal("other");
        });
    });
    describe("getUnionTypes", function () {
        it("should get the union types when there aren't any", function () {
            var firstType = getTypeFromText("let myType: string;").firstType;
            chai_1.expect(firstType.getUnionTypes().length).to.equal(0);
        });
        it("should get the union types when they exist", function () {
            var firstType = getTypeFromText("let myType: string | number;").firstType;
            chai_1.expect(firstType.getUnionTypes().length).to.equal(2);
            chai_1.expect(firstType.getUnionTypes()[0].getFlags()).to.equal(typescript_1.TypeFlags.String);
            chai_1.expect(firstType.getUnionTypes()[1].getFlags()).to.equal(typescript_1.TypeFlags.Number);
        });
        it("should not return anything for an intersection type", function () {
            var firstType = getTypeFromText("let myType: string & number;").firstType;
            chai_1.expect(firstType.getUnionTypes().length).to.equal(0);
        });
    });
    describe("getIntersectionTypes", function () {
        it("should get the union types when there aren't any", function () {
            var firstType = getTypeFromText("let myType: string;").firstType;
            chai_1.expect(firstType.getIntersectionTypes().length).to.equal(0);
        });
        it("should get the union types when they exist", function () {
            var firstType = getTypeFromText("let myType: string & number;").firstType;
            chai_1.expect(firstType.getIntersectionTypes().length).to.equal(2);
            chai_1.expect(firstType.getIntersectionTypes()[0].getFlags()).to.equal(typescript_1.TypeFlags.String);
            chai_1.expect(firstType.getIntersectionTypes()[1].getFlags()).to.equal(typescript_1.TypeFlags.Number);
        });
        it("should not return anything for a union type", function () {
            var firstType = getTypeFromText("let myType: string | number;").firstType;
            chai_1.expect(firstType.getIntersectionTypes().length).to.equal(0);
        });
    });
    describe("isAnonymousType", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.isAnonymousType()).to.equal(expected);
        }
        it("should get when it is an anonymous type", function () {
            doTest("let myType: { str: string; };", true);
        });
        it("should get when it's not an anonymous type", function () {
            doTest("let myType: string;", false);
        });
    });
    describe("isBooleanType", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.isBooleanType()).to.equal(expected);
        }
        it("should get when it is a boolean type", function () {
            doTest("let myType: boolean;", true);
        });
        it("should get when it's not a boolean type", function () {
            doTest("let myType: string;", false);
        });
    });
    describe("isStringType", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.isStringType()).to.equal(expected);
        }
        it("should get when it is a string type", function () {
            doTest("let myType: string;", true);
        });
        it("should get when it's not a string type", function () {
            doTest("let myType: boolean;", false);
        });
    });
    describe("isNumberType", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.isNumberType()).to.equal(expected);
        }
        it("should get when it is a number type", function () {
            doTest("let myType: number;", true);
        });
        it("should get when it's not a number type", function () {
            doTest("let myType: boolean;", false);
        });
    });
    describe("isEnumType", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.isEnumType()).to.equal(expected);
        }
        it("should get when it is an enum type", function () {
            doTest("let myType: MyEnum; enum MyEnum {}", true);
        });
        it("should get when it's not an enum type", function () {
            doTest("let myType: string;", false);
        });
    });
    describe("isInterfaceType", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.isInterfaceType()).to.equal(expected);
        }
        it("should get when it is an interface type", function () {
            doTest("let myType: MyInterface; interface MyInterface {}", true);
        });
        it("should get when it's not an enum type", function () {
            doTest("let myType: string;", false);
        });
    });
    describe("isIntersectionType", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.isIntersectionType()).to.equal(expected);
        }
        it("should get when it is an intersection type", function () {
            doTest("let myType: number & string;", true);
        });
        it("should get when it's not an intersection type", function () {
            doTest("let myType: number | string;", false);
        });
    });
    describe("isObjectType", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.isObjectType()).to.equal(expected);
        }
        it("should get when it is an object type", function () {
            doTest("let myType: { str: string; };", true);
        });
        it("should get when it's not an object type", function () {
            doTest("let myType: number;", false);
        });
    });
    describe("isUnionType", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.isUnionType()).to.equal(expected);
        }
        it("should get when it is a union type", function () {
            doTest("let myType: number | string;", true);
        });
        it("should get when it's not a union type", function () {
            doTest("let myType: number & string;", false);
        });
    });
    describe("isTupleType", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.isTupleType()).to.equal(expected);
        }
        it("should be when tuple and one element", function () {
            doTest("let myType: [string];", true);
        });
        it("should be when tuple and multiple", function () {
            doTest("let myType: [string, number];", true);
        });
        it("should not be when not an array", function () {
            doTest("let myType: string[];", false);
        });
        it("should not be when not an array of tuples", function () {
            doTest("let myType: [string][];", false);
        });
        it("should not be when not tuple", function () {
            doTest("let myType: string;", false);
        });
    });
    describe("isUndefinedType", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.isUndefinedType()).to.equal(expected);
        }
        it("should be when undefined", function () {
            doTest("let myType: undefined;", true);
        });
        it("should not be when not undefined", function () {
            doTest("let myType: string;", false);
        });
    });
    describe("getFlags", function () {
        it("should get the type flags", function () {
            var firstType = getTypeFromText("let myType: number;").firstType;
            chai_1.expect(firstType.getFlags()).to.equal(typescript_1.TypeFlags.Number);
        });
    });
    describe("getObjectFlags", function () {
        it("should get the object flags when not an object", function () {
            var firstType = getTypeFromText("let myType: number;").firstType;
            chai_1.expect(firstType.getObjectFlags()).to.equal(0);
        });
        it("should get the object flags when an object", function () {
            var firstType = getTypeFromText("let myType: MyInterface; interface MyInterface {}").firstType;
            chai_1.expect(firstType.getObjectFlags()).to.equal(typescript_1.ObjectFlags.Interface);
        });
    });
    describe("getSymbol", function () {
        it("should get symbol when it has one", function () {
            var firstType = getTypeFromText("let myType: MyClass; class MyClass {}").firstType;
            chai_1.expect(firstType.getSymbol().getName()).to.equal("MyClass");
        });
        it("should return undefined when it doesn't have one", function () {
            var firstType = getTypeFromText("let myType: string;").firstType;
            chai_1.expect(firstType.getSymbol()).to.be.undefined;
        });
    });
    describe("getSymbolOrThrow", function () {
        it("should get symbol when it has one", function () {
            var firstType = getTypeFromText("let myType: MyClass; class MyClass {}").firstType;
            chai_1.expect(firstType.getSymbolOrThrow().getName()).to.equal("MyClass");
        });
        it("should return undefined when it doesn't have one", function () {
            var firstType = getTypeFromText("let myType: string;").firstType;
            chai_1.expect(function () { return firstType.getSymbolOrThrow(); }).to.throw();
        });
    });
    describe("getApparentType", function () {
        it("should get the apparent type", function () {
            var firstType = getTypeFromText("const myType = 4;").firstType;
            chai_1.expect(firstType.getApparentType().getText()).to.equal("Number");
        });
    });
    describe("getCallSignatures", function () {
        it("should return no call signatures when none exist", function () {
            var firstType = getTypeFromText("let myType: string;").firstType;
            chai_1.expect(firstType.getCallSignatures().length).to.equal(0);
        });
        it("should return the call signatures of a type", function () {
            var firstType = getTypeFromText("let myType: () => string;").firstType;
            chai_1.expect(firstType.getCallSignatures().length).to.equal(1);
        });
    });
    describe("getConstructSignatures", function () {
        it("should return no construct signatures when none exist", function () {
            var firstType = getTypeFromText("let myType: string;").firstType;
            chai_1.expect(firstType.getConstructSignatures().length).to.equal(0);
        });
        it("should return the construct signatures of a type", function () {
            var firstType = getTypeFromText("let myType: { new(): MyClass; };").firstType;
            chai_1.expect(firstType.getConstructSignatures().length).to.equal(1);
        });
    });
    describe("getConstraint", function () {
        function doTest(text, expected) {
            var firstType = getTypeAliasTypeFromText(text).firstType;
            if (expected == null)
                chai_1.expect(firstType.getConstraint()).to.be.undefined;
            else
                chai_1.expect(firstType.getConstraint().getText()).to.equal(expected);
        }
        it("should get the constraint when it exists", function () {
            doTest("type t<T extends string> = T;", "string");
        });
        it("should be undefined when it doesn't have a constraint", function () {
            doTest("type t<T> = T;", undefined);
        });
    });
    describe("getConstraintOrThrow", function () {
        function doTest(text, expected) {
            var firstType = getTypeAliasTypeFromText(text).firstType;
            if (expected == null)
                chai_1.expect(function () { return firstType.getConstraintOrThrow(); }).to.throw();
            else
                chai_1.expect(firstType.getConstraintOrThrow().getText()).to.equal(expected);
        }
        it("should get the constraint when it exists", function () {
            doTest("type t<T extends string> = T;", "string");
        });
        it("should be undefined when it doesn't have a constraint", function () {
            doTest("type t<T> = T;", undefined);
        });
    });
    describe("getDefault", function () {
        function doTest(text, expected) {
            var firstType = getTypeAliasTypeFromText(text).firstType;
            if (expected == null)
                chai_1.expect(firstType.getDefault()).to.be.undefined;
            else
                chai_1.expect(firstType.getDefault().getText()).to.equal(expected);
        }
        it("should get the default when it exists", function () {
            doTest("type t<T = string> = T;", "string");
        });
        it("should be undefined when it doesn't have a default", function () {
            doTest("type t<T> = T;", undefined);
        });
    });
    describe("getDefaultOrThrow", function () {
        function doTest(text, expected) {
            var firstType = getTypeAliasTypeFromText(text).firstType;
            if (expected == null)
                chai_1.expect(function () { return firstType.getDefaultOrThrow(); }).to.throw();
            else
                chai_1.expect(firstType.getDefaultOrThrow().getText()).to.equal(expected);
        }
        it("should get the default when it exists", function () {
            doTest("type t<T = string> = T;", "string");
        });
        it("should be undefined when it doesn't have a default", function () {
            doTest("type t<T> = T;", undefined);
        });
    });
    describe("getBaseTypes", function () {
        it("should return the base types of a type", function () {
            var firstType = getTypeFromText("let myType: MyInterface; interface MyInterface extends OtherInterface {}\ninterface OtherInterface").firstType;
            var baseTypes = firstType.getBaseTypes();
            chai_1.expect(baseTypes.length).to.equal(1);
            chai_1.expect(baseTypes[0].getText()).to.equal("OtherInterface");
        });
    });
    describe("getStringIndexType", function () {
        it("should return undefined when no string index type", function () {
            var firstType = getTypeFromText("let myType: { };").firstType;
            var stringIndexType = firstType.getStringIndexType();
            chai_1.expect(stringIndexType).to.be.undefined;
        });
        it("should return the string index type", function () {
            var firstType = getTypeFromText("let myType: { [index: string]: object; [index: number]: Date; };").firstType;
            var stringIndexType = firstType.getStringIndexType();
            chai_1.expect(stringIndexType.getText()).to.equal("object");
        });
    });
    describe("getNumberIndexType", function () {
        it("should return undefined when no number index type", function () {
            var firstType = getTypeFromText("let myType: { };").firstType;
            var numberIndexType = firstType.getNumberIndexType();
            chai_1.expect(numberIndexType).to.be.undefined;
        });
        it("should return the number index type", function () {
            var firstType = getTypeFromText("let myType: { [index: string]: object; [index: number]: Date; };").firstType;
            var numberIndexType = firstType.getNumberIndexType();
            chai_1.expect(numberIndexType.getText()).to.equal("Date");
        });
    });
    describe("getNonNullableType", function () {
        function doTest(typeStr, expected) {
            var firstType = getTypeFromText("let myType: " + typeStr + ";").firstType;
            var nonNullableType = firstType.getNonNullableType();
            chai_1.expect(nonNullableType.getText()).to.equal(expected);
        }
        it("should return the original type for a type that's already non-nullable", function () {
            doTest("string", "string");
        });
        it("should return the non-nullable type for undefined", function () {
            doTest("string | undefined", "string");
        });
        it("should return the non-nullable type for null", function () {
            doTest("string | null", "string");
        });
        it("should return the non-nullable type for null and undefined", function () {
            doTest("string | null | undefined", "string");
        });
    });
    describe("isNullable", function () {
        function doTest(typeStr, expected) {
            var firstType = getTypeFromText("let myType: " + typeStr + ";").firstType;
            chai_1.expect(firstType.isNullable()).to.equal(expected);
        }
        it("should return false for a non-nullable type", function () {
            doTest("string", false);
        });
        it("should return true for undefined", function () {
            doTest("string | undefined", true);
        });
        it("should return true for null", function () {
            doTest("string | null", true);
        });
        it("should return true for null and undefined", function () {
            doTest("string | null | undefined", true);
        });
        it("should return true for an optional property", function () {
            var firstChild = getInfoFromTextWithTypeChecking("function test(param?: string) {}").firstChild;
            chai_1.expect(firstChild.getParameters()[0].getType().isNullable()).to.equal(true);
        });
    });
    describe("getAliasSymbol", function () {
        it("should return the alias symbol when it exists", function () {
            var firstType = getTypeFromText("let myType: MyAlias; type MyAlias = {str: string;};").firstType;
            chai_1.expect(firstType.getAliasSymbol().getFlags()).to.equal(typescript_1.SymbolFlags.TypeAlias);
        });
        it("should return undefined when not exists", function () {
            var firstType = getTypeFromText("let myType: string;").firstType;
            chai_1.expect(firstType.getAliasSymbol()).to.be.undefined;
        });
    });
    describe("getAliasSymbolOrThrow", function () {
        it("should return the alias symbol when it exists", function () {
            var firstType = getTypeFromText("let myType: MyAlias; type MyAlias = {str: string;};").firstType;
            chai_1.expect(firstType.getAliasSymbolOrThrow().getFlags()).to.equal(typescript_1.SymbolFlags.TypeAlias);
        });
        it("should throw when not exists", function () {
            var firstType = getTypeFromText("let myType: string;").firstType;
            chai_1.expect(function () { return firstType.getAliasSymbolOrThrow(); }).to.throw();
        });
    });
    describe("getAliasTypeArguments", function () {
        it("should not have any when none exist", function () {
            var firstType = getTypeFromText("let myType: string;").firstType;
            chai_1.expect(firstType.getAliasTypeArguments().length).to.equal(0);
        });
        it("should return the type args when they exist", function () {
            var firstType = getTypeFromText("let myType: MyAlias<string>; type MyAlias<T> = {str: T;};").firstType;
            var typeArgs = firstType.getAliasTypeArguments();
            chai_1.expect(typeArgs.length).to.equal(1);
            chai_1.expect(typeArgs[0].getText()).to.equal("string");
        });
    });
    describe("getTupleElements", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.getTupleElements().map(function (t) { return t.getText(); })).to.deep.equal(expected);
        }
        it("should get the tuple type's types", function () {
            doTest("let t: [string, number]", ["string", "number"]);
        });
        it("should get nothing when not a tuple", function () {
            doTest("let t: string;", []);
        });
        it("should get nothing for an array type that has type arguments", function () {
            doTest("let t: Array<string>;", []);
        });
    });
    describe("getTypeArguments", function () {
        function doTest(text, expected) {
            var firstType = getTypeFromText(text).firstType;
            chai_1.expect(firstType.getTypeArguments().map(function (t) { return t.getText(); })).to.deep.equal(expected);
        }
        it("should get the type arguments for an array", function () {
            doTest("let t: Array<string>;", ["string"]);
        });
        it("should get them for a tuple", function () {
            doTest("let t: [string, number]", ["string", "number"]);
        });
        it("should get nothing when no type args", function () {
            doTest("let t: string;", []);
        });
    });
});
