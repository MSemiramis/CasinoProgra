"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testHelpers_1 = require("../testHelpers");
describe("TypeParameterDeclaration", function () {
    function getTypeParameterFromText(text, index) {
        if (index === void 0) { index = 0; }
        var firstChild = testHelpers_1.getInfoFromText(text).firstChild;
        return firstChild.getTypeParameters()[index];
    }
    describe("getName", function () {
        it("should get the name", function () {
            var typeParameterDeclaration = getTypeParameterFromText("function func<T>() {}\n");
            chai_1.expect(typeParameterDeclaration.getName()).to.equal("T");
        });
    });
    describe("getConstraintNode", function () {
        it("should return undefined when there's no constraint", function () {
            var typeParameterDeclaration = getTypeParameterFromText("function func<T>() {}\n");
            chai_1.expect(typeParameterDeclaration.getConstraintNode()).to.be.undefined;
        });
        it("should return the constraint type node when there's a constraint", function () {
            var typeParameterDeclaration = getTypeParameterFromText("function func<T extends string>() {}\n");
            chai_1.expect(typeParameterDeclaration.getConstraintNode().getText()).to.equal("string");
        });
    });
    describe("getDefaultNode", function () {
        it("should return undefined when there's no default node", function () {
            var typeParameterDeclaration = getTypeParameterFromText("function func<T>() {}\n");
            chai_1.expect(typeParameterDeclaration.getDefaultNode()).to.be.undefined;
        });
        it("should return the default type node when there's a default", function () {
            var typeParameterDeclaration = getTypeParameterFromText("function func<T = string>() {}\n");
            chai_1.expect(typeParameterDeclaration.getDefaultNode().getText()).to.equal("string");
        });
    });
    describe("remove", function () {
        function doTest(startText, indexToRemove, expectedText) {
            var typeParameterDeclaration = getTypeParameterFromText(startText, indexToRemove);
            var sourceFile = typeParameterDeclaration.sourceFile;
            typeParameterDeclaration.remove();
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
        }
        it("should remove when its the only type parameter", function () {
            doTest("function func<T>() {}", 0, "function func() {}");
        });
        it("should remove when it's the first type parameter", function () {
            doTest("function func<T, U>() {}", 0, "function func<U>() {}");
        });
        it("should remove when it's the middle type parameter", function () {
            doTest("function func<T, U, V>() {}", 1, "function func<T, V>() {}");
        });
        it("should remove when it's the last type parameter", function () {
            doTest("function func<T, U>() {}", 1, "function func<T>() {}");
        });
        it("should remove when it has a constraint", function () {
            doTest("function func<T extends Other, U>() {}", 0, "function func<U>() {}");
        });
    });
});
