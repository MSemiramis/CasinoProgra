"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var compiler_1 = require("../../../compiler");
var testHelpers_1 = require("../testHelpers");
describe("ConstructorDeclaration", function () {
    describe("insertOverloads", function () {
        function doTest(startCode, index, structures, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var methodDeclaration = firstChild.getConstructors()[0];
            var result = methodDeclaration.insertOverloads(index, structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert when no other overloads exist", function () {
            doTest("class Identifier {\n    constructor() {}\n }", 0, [{ parameters: [{ name: "param" }] }, {}], "class Identifier {\n    constructor(param);\n    constructor();\n    constructor() {}\n }");
        });
        it("should copy over the scope keyword", function () {
            doTest("class Identifier {\n    protected constructor(p) {}\n }", 0, [{ parameters: [{ name: "param" }] }, {}], "class Identifier {\n    protected constructor(param);\n    protected constructor();\n    protected constructor(p) {}\n }");
        });
        it("should be able to insert at start when another overload exists", function () {
            doTest("class Identifier {\n    constructor();\n    constructor() {}\n }", 0, [{ parameters: [{ name: "param" }] }], "class Identifier {\n    constructor(param);\n    constructor();\n    constructor() {}\n }");
        });
        it("should be able to insert at end when another overload exists", function () {
            doTest("class Identifier {\n    constructor();\n    constructor() {}\n }", 1, [{ parameters: [{ name: "param" }] }], "class Identifier {\n    constructor();\n    constructor(param);\n    constructor() {}\n }");
        });
        it("should be able to insert in the middle when other overloads exists", function () {
            doTest("class Identifier {\n    constructor();\n    constructor();\n    constructor() {}\n }", 1, [{ parameters: [{ name: "param" }] }], "class Identifier {\n    constructor();\n    constructor(param);\n    constructor();\n    constructor() {}\n }");
        });
    });
    describe("insertOverload", function () {
        function doTest(startCode, index, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var methodDeclaration = firstChild.getMembers()[0];
            var result = methodDeclaration.insertOverload(index, structure);
            chai_1.expect(result).to.be.instanceof(compiler_1.ConstructorDeclaration);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should be able to insert in the middle when other overloads exists", function () {
            doTest("class Identifier {\n    constructor();\n    constructor();\n    constructor() {}\n }", 1, { parameters: [{ name: "param" }] }, "class Identifier {\n    constructor();\n    constructor(param);\n    constructor();\n    constructor() {}\n }");
        });
    });
    describe("addOverloads", function () {
        function doTest(startCode, structures, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var methodDeclaration = firstChild.getMembers()[0];
            var result = methodDeclaration.addOverloads(structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should be able to add multiple", function () {
            doTest("class Identifier {\n    constructor();\n    constructor() {}\n }", [{ parameters: [{ name: "param" }] }, { parameters: [{ name: "param2" }] }], "class Identifier {\n    constructor();\n    constructor(param);\n    constructor(param2);\n    constructor() {}\n }");
        });
    });
    describe("addOverload", function () {
        function doTest(startCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var methodDeclaration = firstChild.getMembers()[0];
            var result = methodDeclaration.addOverload(structure);
            chai_1.expect(result).to.be.instanceof(compiler_1.ConstructorDeclaration);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should be able to add an overload", function () {
            doTest("class Identifier {\n    constructor();\n    constructor() {}\n }", { parameters: [{ name: "param" }] }, "class Identifier {\n    constructor();\n    constructor(param);\n    constructor() {}\n }");
        });
    });
    describe("remove", function () {
        function doTest(startCode, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), sourceFile = _a.sourceFile, firstChild = _a.firstChild;
            firstChild.getConstructors()[0].remove();
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should remove when only member", function () {
            doTest("class MyClass {\n    constructor() {\n    }\n}", "class MyClass {\n}");
        });
        it("should remove when between other members", function () {
            doTest("class MyClass {\n    prop: string;\n\n    constructor() {\n    }\n\n    m() {\n    }\n}", "class MyClass {\n    prop: string;\n\n    m() {\n    }\n}");
        });
        it("should remove when at start", function () {
            doTest("class MyClass {\n    constructor() {\n    }\n\n    prop: string;\n}", "class MyClass {\n    prop: string;\n}");
        });
        it("should remove when at end", function () {
            doTest("class MyClass {\n    prop: string;\n\n    constructor() {\n    }\n}", "class MyClass {\n    prop: string;\n}");
        });
        it("should remove when there are overloads", function () {
            doTest("class MyClass {\n    constructor();constructor() {\n    }\n}", "class MyClass {\n}");
        });
        it("should only remove the overload when calling remove on the overload", function () {
            var startCode = "class MyClass {\n    constructor();\n    constructor() {\n    }\n}";
            var _a = testHelpers_1.getInfoFromText(startCode), sourceFile = _a.sourceFile, firstChild = _a.firstChild;
            firstChild.getConstructors()[0].getOverloads()[0].remove();
            chai_1.expect(sourceFile.getFullText()).to.equal("class MyClass {\n    constructor() {\n    }\n}");
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var ctor = firstChild.getConstructors()[0];
            ctor.fill(structure);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("class identifier {\n    constructor() {}\n}", {}, "class identifier {\n    constructor() {}\n}");
        });
        it("should modify when changed", function () {
            var structure = {
                overloads: [{ parameters: [{ name: "param" }] }]
            };
            doTest("class identifier {\n    constructor() {}\n}", structure, "class identifier {\n    constructor(param);\n    constructor() {}\n}");
        });
    });
});
