"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var compiler_1 = require("../../../compiler");
var testHelpers_1 = require("../testHelpers");
var utils_1 = require("../../../utils");
describe("ClassDeclaration", function () {
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
        }
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("class Identifier {\n}", {}, "class Identifier {\n}");
        });
        it("should modify when changed", function () {
            var structure = {
                extends: "Other",
                ctor: {},
                properties: [{ name: "p" }],
                getAccessors: [{ name: "g" }],
                setAccessors: [{ name: "s", parameters: [{ name: "value", type: "string" }] }],
                methods: [{ name: "m" }]
            };
            doTest("class Identifier {\n}", structure, "class Identifier extends Other {\n    constructor() {\n    }\n\n    p;\n\n    get g() {\n    }" +
                "\n\n    set s(value: string) {\n    }\n\n    m() {\n    }\n}");
        });
    });
    describe("getExtends", function () {
        it("should return undefined when no extends clause exists", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier { }").firstChild;
            chai_1.expect(firstChild.getExtends()).to.be.undefined;
        });
        it("should return a heritage clause when an extends clause exists", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier extends Base { }").firstChild;
            chai_1.expect(firstChild.getExtends()).to.be.instanceOf(compiler_1.ExpressionWithTypeArguments);
        });
    });
    describe("getExtendsOrThrow", function () {
        it("should throw when no extends clause exists", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier { }").firstChild;
            chai_1.expect(function () { return firstChild.getExtendsOrThrow(); }).to.throw();
        });
        it("should return a heritage clause when an extends clause exists", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier extends Base { }").firstChild;
            chai_1.expect(firstChild.getExtendsOrThrow()).to.be.instanceOf(compiler_1.ExpressionWithTypeArguments);
        });
    });
    describe("setExtends", function () {
        function doTest(startCode, extendsText, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.setExtends(extendsText);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should set an extends", function () {
            doTest("  class Identifier {}  ", "Base", "  class Identifier extends Base {}  ");
        });
        it("should set an extends when an implements exists", function () {
            doTest("class Identifier implements IBase {}", "Base", "class Identifier extends Base implements IBase {}");
        });
        it("should set an extends when the brace is right beside the identifier", function () {
            doTest("  class Identifier{}  ", "Base", "  class Identifier extends Base {}  ");
        });
        it("should set an extends when an extends already exists", function () {
            doTest("class Identifier extends Base1 {}", "Base2", "class Identifier extends Base2 {}");
        });
        it("should remove when providing an empty string", function () {
            doTest("class Identifier extends Base1 {}", "", "class Identifier {}");
        });
        it("should remove when providing whitespace string", function () {
            doTest("class Identifier extends Base1 {}", "    ", "class Identifier {}");
        });
    });
    describe("removeExtends", function () {
        function doTest(startCode, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.removeExtends();
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should not do anything when there's no thing to remove", function () {
            doTest("class Identifier {}", "class Identifier {}");
        });
        it("should remove when there is an extends", function () {
            doTest("class Identifier extends Base1 {}", "class Identifier {}");
        });
        it("should remove when there is an extends and implements", function () {
            doTest("class Identifier extends Base1 implements T {}", "class Identifier implements T {}");
        });
    });
    describe("insertConstructor", function () {
        function doTest(startCode, insertIndex, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertConstructor(insertIndex, structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ConstructorDeclaration);
        }
        it("should insert when none exists", function () {
            doTest("class c {\n}", 0, {}, "class c {\n    constructor() {\n    }\n}");
        });
        it("should remove the previous when one exists", function () {
            doTest("class c {\n    constructor() {\n    }\n}", 0, { scope: compiler_1.Scope.Private }, "class c {\n    private constructor() {\n    }\n}");
        });
        it("should insert multiple into other members", function () {
            doTest("class c {\n    prop1;\n    prop2;\n}", 1, {}, "class c {\n    prop1;\n\n    constructor() {\n    }\n\n    prop2;\n}");
        });
    });
    describe("addConstructor", function () {
        function doTest(startCode, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addConstructor(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ConstructorDeclaration);
        }
        it("should add at the end", function () {
            doTest("class c {\n    prop1;\n}", {}, "class c {\n    prop1;\n\n    constructor() {\n    }\n}");
        });
    });
    describe("getConstructors", function () {
        it("should return undefined when no constructor exists", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier { }").firstChild;
            chai_1.expect(firstChild.getConstructors().length).to.equal(0);
        });
        it("should return the constructor when it exists", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier { constructor() { } }").firstChild;
            chai_1.expect(firstChild.getConstructors()[0].getText()).to.equal("constructor() { }");
        });
        it("should return the implementation constructor if not in an ambient context", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier { constructor(str: string);constructor(str: any) { } }").firstChild;
            var constructors = firstChild.getConstructors();
            chai_1.expect(constructors.length).to.equal(1);
            chai_1.expect(constructors[0].getText()).to.equal("constructor(str: any) { }");
        });
        it("should return both constructors in an ambient context", function () {
            var firstChild = testHelpers_1.getInfoFromText("declare class Identifier { constructor(str: string);constructor(str: any);}").firstChild;
            var constructors = firstChild.getConstructors();
            chai_1.expect(constructors.length).to.equal(2);
            chai_1.expect(constructors[0].getText()).to.equal("constructor(str: string);");
            chai_1.expect(constructors[1].getText()).to.equal("constructor(str: any);");
        });
    });
    describe("insertGetAccessors", function () {
        function doTest(startCode, insertIndex, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertGetAccessors(insertIndex, structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert when none exists", function () {
            doTest("class c {\n}", 0, [{ name: "identifier" }], "class c {\n    get identifier() {\n    }\n}");
        });
        it("should insert multiple into other methods", function () {
            doTest("class c {\n    m1() {\n    }\n\n    m4() {\n    }\n}", 1, [{ isStatic: true, name: "m2", returnType: "string" }, { name: "m3" }], "class c {\n    m1() {\n    }\n\n    static get m2(): string {\n    }\n\n    get m3() {\n    }\n\n    m4() {\n    }\n}");
        });
    });
    describe("insertGetAccessor", function () {
        function doTest(startCode, insertIndex, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertGetAccessor(insertIndex, structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.GetAccessorDeclaration);
        }
        it("should insert", function () {
            doTest("class c {\n    m1() {\n    }\n\n    m3() {\n    }\n}", 1, { name: "m2" }, "class c {\n    m1() {\n    }\n\n    get m2() {\n    }\n\n    m3() {\n    }\n}");
        });
    });
    describe("addGetAccessors", function () {
        function doTest(startCode, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addGetAccessors(structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add multiple", function () {
            doTest("class c {\n    m1() {\n    }\n}", [{ name: "m2" }, { name: "m3" }], "class c {\n    m1() {\n    }\n\n    get m2() {\n    }\n\n    get m3() {\n    }\n}");
        });
    });
    describe("addGetAccessor", function () {
        function doTest(startCode, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addGetAccessor(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.GetAccessorDeclaration);
        }
        it("should insert", function () {
            doTest("class c {\n    m1() {\n    }\n}", { name: "m2" }, "class c {\n    m1() {\n    }\n\n    get m2() {\n    }\n}");
        });
    });
    describe("insertProperties", function () {
        function doTest(startCode, insertIndex, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertProperties(insertIndex, structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert when none exists", function () {
            doTest("class c {\n}", 0, [{ name: "prop" }], "class c {\n    prop;\n}");
        });
        it("should insert multiple into other properties", function () {
            doTest("class c {\n    prop1;\n    prop4;\n}", 1, [{ name: "prop2", hasQuestionToken: true, type: "string" }, { name: "prop3" }], "class c {\n    prop1;\n    prop2?: string;\n    prop3;\n    prop4;\n}");
        });
        it("should add an extra newline if inserting before non-property", function () {
            doTest("class c {\n    myMethod() {}\n}", 0, [{ name: "prop" }], "class c {\n    prop;\n\n    myMethod() {}\n}");
        });
        it("should add an extra newline if inserting ater non-property", function () {
            doTest("class c {\n    myMethod() {}\n}", 1, [{ name: "prop" }], "class c {\n    myMethod() {}\n\n    prop;\n}");
        });
    });
    describe("insertProperty", function () {
        function doTest(startCode, insertIndex, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertProperty(insertIndex, structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.PropertyDeclaration);
        }
        it("should insert at index", function () {
            doTest("class c {\n    prop1;\n    prop3;\n}", 1, { name: "prop2" }, "class c {\n    prop1;\n    prop2;\n    prop3;\n}");
        });
    });
    describe("addProperties", function () {
        function doTest(startCode, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addProperties(structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add multiple at end", function () {
            doTest("class c {\n    prop1;\n}", [{ name: "prop2" }, { name: "prop3" }], "class c {\n    prop1;\n    prop2;\n    prop3;\n}");
        });
    });
    describe("addProperty", function () {
        function doTest(startCode, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addProperty(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.PropertyDeclaration);
        }
        it("should add at end", function () {
            doTest("class c {\n    prop1;\n}", { name: "prop2" }, "class c {\n    prop1;\n    prop2;\n}");
        });
    });
    describe("getProperty", function () {
        var code = "class Identifier { member() {} get member() {} set member() {} static member: string; member2: string; }\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a member when it exists", function () {
            chai_1.expect(firstChild.getProperty("member").getText()).to.equal("static member: string;");
        });
        it("should return undefined when it doesn't exists", function () {
            chai_1.expect(firstChild.getProperty("member3")).to.be.undefined;
        });
    });
    describe("getPropertyOrThrow", function () {
        var code = "class Identifier { member() {} get member() {} set member() {} static member: string; member2: string; }\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a member when it exists", function () {
            chai_1.expect(firstChild.getPropertyOrThrow("member2").getText()).to.equal("member2: string;");
        });
        it("should throw when it doesn't exists", function () {
            chai_1.expect(function () { return firstChild.getPropertyOrThrow("member3"); }).to.throw();
        });
    });
    describe("getGetAccessor", function () {
        var code = "class Identifier { member() {} get member() {} set member() {} static member: string; member2: string; }\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a member when it exists", function () {
            chai_1.expect(firstChild.getGetAccessor("member").getText()).to.equal("get member() {}");
        });
        it("should return undefined when it doesn't exists", function () {
            chai_1.expect(firstChild.getGetAccessor("member3")).to.be.undefined;
        });
    });
    describe("getGetAccessorOrThrow", function () {
        var code = "class Identifier { member() {} get member() {} set member() {} static member: string; member2: string; }\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a member when it exists", function () {
            chai_1.expect(firstChild.getGetAccessorOrThrow("member").getText()).to.equal("get member() {}");
        });
        it("should throw when it doesn't exists", function () {
            chai_1.expect(function () { return firstChild.getGetAccessorOrThrow("member3"); }).to.throw();
        });
    });
    describe("getSetAccessor", function () {
        var code = "class Identifier { member() {} get member() {} set member() {} static member: string; member2: string; }\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a member when it exists", function () {
            chai_1.expect(firstChild.getSetAccessor("member").getText()).to.equal("set member() {}");
        });
        it("should return undefined when it doesn't exists", function () {
            chai_1.expect(firstChild.getSetAccessor("member3")).to.be.undefined;
        });
    });
    describe("getSetAccessorOrThrow", function () {
        var code = "class Identifier { member() {} get member() {} set member() {} static member: string; member2: string; }\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a member when it exists", function () {
            chai_1.expect(firstChild.getSetAccessorOrThrow("member").getText()).to.equal("set member() {}");
        });
        it("should throw when it doesn't exists", function () {
            chai_1.expect(function () { return firstChild.getSetAccessorOrThrow("member3"); }).to.throw();
        });
    });
    describe("getInstanceProperties", function () {
        describe("no properties", function () {
            it("should not have any properties", function () {
                var firstChild = testHelpers_1.getInfoFromText("class Identifier {\n}\n").firstChild;
                chai_1.expect(firstChild.getInstanceProperties().length).to.equal(0);
            });
        });
        describe("has properties", function () {
            var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
                "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
                "instanceProp: string;\nprop2: number;method1() {}\n" +
                "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
            var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
            it("should get the right number of properties", function () {
                chai_1.expect(firstChild.getInstanceProperties().length).to.equal(6);
            });
            it("should get a property of the right instance of for parameter with a scope", function () {
                chai_1.expect(firstChild.getInstanceProperties()[0]).to.be.instanceOf(compiler_1.ParameterDeclaration);
                chai_1.expect(firstChild.getInstanceProperties()[0].getName()).to.equal("param2");
            });
            it("should get a property of the right instance of for parameter with readonly keyword", function () {
                chai_1.expect(firstChild.getInstanceProperties()[1]).to.be.instanceOf(compiler_1.ParameterDeclaration);
                chai_1.expect(firstChild.getInstanceProperties()[1].getName()).to.equal("param3");
            });
            it("should get a property of the right instance of", function () {
                chai_1.expect(firstChild.getInstanceProperties()[2]).to.be.instanceOf(compiler_1.PropertyDeclaration);
            });
            it("should get a property of the right instance of for the get accessor", function () {
                chai_1.expect(firstChild.getInstanceProperties()[4]).to.be.instanceOf(compiler_1.GetAccessorDeclaration);
            });
            it("should get a property of the right instance of for the set accessor", function () {
                chai_1.expect(firstChild.getInstanceProperties()[5]).to.be.instanceOf(compiler_1.SetAccessorDeclaration);
            });
        });
    });
    describe("getInstanceProperty", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method1() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a property by name", function () {
            var prop = firstChild.getInstanceProperty("prop2");
            chai_1.expect(prop.getName()).to.equal("prop2");
            chai_1.expect(prop.isStatic()).to.equal(false);
        });
        it("should get a property by function", function () {
            var prop = firstChild.getInstanceProperty(function (p) { return p.getName() === "prop2"; });
            chai_1.expect(prop.getName()).to.equal("prop2");
            chai_1.expect(prop.isStatic()).to.equal(false);
        });
    });
    describe("getInstancePropertyOrThrow", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method1() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a property by name", function () {
            var prop = firstChild.getInstancePropertyOrThrow("prop2");
            chai_1.expect(prop.getName()).to.equal("prop2");
            chai_1.expect(prop.isStatic()).to.equal(false);
        });
        it("should get a property by function", function () {
            var prop = firstChild.getInstancePropertyOrThrow(function (p) { return p.getName() === "prop2"; });
            chai_1.expect(prop.getName()).to.equal("prop2");
            chai_1.expect(prop.isStatic()).to.equal(false);
        });
        it("should throw when not found", function () {
            chai_1.expect(function () { return firstChild.getInstancePropertyOrThrow(function (p) { return p.getName() === "prop9"; }); }).to.throw();
        });
    });
    describe("getStaticProperty", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method1() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a property by name", function () {
            var prop = firstChild.getStaticProperty("prop2");
            chai_1.expect(prop.getName()).to.equal("prop2");
            chai_1.expect(prop.isStatic()).to.equal(true);
        });
        it("should get a property by function", function () {
            var prop = firstChild.getStaticProperty(function (p) { return p.getName() === "prop2"; });
            chai_1.expect(prop.getName()).to.equal("prop2");
            chai_1.expect(prop.isStatic()).to.equal(true);
        });
    });
    describe("getStaticPropertyOrThrow", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method1() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a property by name", function () {
            var prop = firstChild.getStaticPropertyOrThrow("prop2");
            chai_1.expect(prop.getName()).to.equal("prop2");
            chai_1.expect(prop.isStatic()).to.equal(true);
        });
        it("should get a property by function", function () {
            var prop = firstChild.getStaticPropertyOrThrow(function (p) { return p.getName() === "prop2"; });
            chai_1.expect(prop.getName()).to.equal("prop2");
            chai_1.expect(prop.isStatic()).to.equal(true);
        });
        it("should throw when not found", function () {
            chai_1.expect(function () { return firstChild.getStaticPropertyOrThrow(function (p) { return p.getName() === "prop9"; }); }).to.throw();
        });
    });
    describe("getStaticProperties", function () {
        describe("no static properties", function () {
            it("should not have any properties", function () {
                var firstChild = testHelpers_1.getInfoFromText("class Identifier {\n}\n").firstChild;
                chai_1.expect(firstChild.getStaticProperties().length).to.equal(0);
            });
        });
        describe("has static properties", function () {
            var code = "class Identifier {\nconstructor(public p: string) {}\nstatic prop2: string;\nstatic method() {}\nprop: string;\nprop2: number;method1() {}\n" +
                "\nstatic get prop(): string { return ''; }\nstatic set prop(val: string) {}\n}";
            var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
            it("should get the right number of static properties", function () {
                chai_1.expect(firstChild.getStaticProperties().length).to.equal(3);
            });
            it("should get a property of the right instance of", function () {
                chai_1.expect(firstChild.getStaticProperties()[0]).to.be.instanceOf(compiler_1.PropertyDeclaration);
            });
            it("should get a property of the right instance of for the get accessor", function () {
                chai_1.expect(firstChild.getStaticProperties()[1]).to.be.instanceOf(compiler_1.GetAccessorDeclaration);
            });
            it("should get a property of the right instance of for the set accessor", function () {
                chai_1.expect(firstChild.getStaticProperties()[2]).to.be.instanceOf(compiler_1.SetAccessorDeclaration);
            });
        });
    });
    describe("insertMethods", function () {
        function doTest(startCode, insertIndex, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertMethods(insertIndex, structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert when none exists", function () {
            doTest("class c {\n}", 0, [{ name: "myMethod" }], "class c {\n    myMethod() {\n    }\n}");
        });
        it("should insert multiple into other methods", function () {
            doTest("class c {\n    m1() {\n    }\n\n    m4() {\n    }\n}", 1, [{ isStatic: true, name: "m2", returnType: "string" }, { name: "m3" }], "class c {\n    m1() {\n    }\n\n    static m2(): string {\n    }\n\n    m3() {\n    }\n\n    m4() {\n    }\n}");
        });
        it("should insert when the structure has everything the writer supports", function () {
            var getJsDoc = function (desc) { return "    /**\n     * " + desc + "\n     */\n"; };
            doTest("class Identifier {\n}", 0, [{
                    docs: [{ description: "First." }, { description: "Second." }],
                    name: "m1",
                    parameters: [{ name: "p1" }, { name: "p2" }], returnType: "number"
                }], "class Identifier {\n" + getJsDoc("First.") + getJsDoc("Second.") + "    m1(p1, p2): number {\n    }\n}");
        });
    });
    describe("insertMethod", function () {
        function doTest(startCode, insertIndex, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertMethod(insertIndex, structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.MethodDeclaration);
        }
        it("should insert", function () {
            doTest("class c {\n    m1() {\n    }\n\n    m3() {\n    }\n}", 1, { name: "m2" }, "class c {\n    m1() {\n    }\n\n    m2() {\n    }\n\n    m3() {\n    }\n}");
        });
    });
    describe("addMethods", function () {
        function doTest(startCode, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addMethods(structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add multiple", function () {
            doTest("class c {\n    m1() {\n    }\n}", [{ name: "m2" }, { name: "m3" }], "class c {\n    m1() {\n    }\n\n    m2() {\n    }\n\n    m3() {\n    }\n}");
        });
    });
    describe("addMethod", function () {
        function doTest(startCode, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addMethod(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.MethodDeclaration);
        }
        it("should insert", function () {
            doTest("class c {\n    m1() {\n    }\n}", { name: "m2" }, "class c {\n    m1() {\n    }\n\n    m2() {\n    }\n}");
        });
    });
    describe("getMethod", function () {
        var code = "class Identifier { get member() {} set member() {} static member: string; member() {} }\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a member when it exists", function () {
            chai_1.expect(firstChild.getMethod("member").getText()).to.equal("member() {}");
        });
        it("should return undefined when it doesn't exists", function () {
            chai_1.expect(firstChild.getMethod("member3")).to.be.undefined;
        });
    });
    describe("getMethodOrThrow", function () {
        var code = "class Identifier { get member() {} set member() {} static member: string; member() {} }\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a member when it exists", function () {
            chai_1.expect(firstChild.getMethodOrThrow("member").getText()).to.equal("member() {}");
        });
        it("should throw when it doesn't exists", function () {
            chai_1.expect(function () { return firstChild.getMethodOrThrow("member3"); }).to.throw();
        });
    });
    describe("getInstanceMethods", function () {
        describe("no methods", function () {
            it("should not have any methods", function () {
                var firstChild = testHelpers_1.getInfoFromText("class Identifier {\n}\n").firstChild;
                chai_1.expect(firstChild.getInstanceMethods().length).to.equal(0);
            });
        });
        describe("has methods", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier {\n    static prop2: string;\n    static method() {}\n    prop: string;\n    method1() {}\n    method2() {}\n    abstract method3(): void;\n}\n").firstChild;
            it("should get the right number of methods", function () {
                chai_1.expect(firstChild.getInstanceMethods().length).to.equal(3);
            });
            it("should get a method of the right instance of", function () {
                chai_1.expect(firstChild.getInstanceMethods()[0]).to.be.instanceOf(compiler_1.MethodDeclaration);
            });
        });
    });
    describe("getInstanceMethod", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a method by name", function () {
            var method = firstChild.getInstanceMethod("method");
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(false);
        });
        it("should get a method by function", function () {
            var method = firstChild.getInstanceMethod(function (m) { return m.getName() === "method"; });
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(false);
        });
    });
    describe("getInstanceMethodOrThrow", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a method by name", function () {
            var method = firstChild.getInstanceMethodOrThrow("method");
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(false);
        });
        it("should get a method by function", function () {
            var method = firstChild.getInstanceMethodOrThrow(function (m) { return m.getName() === "method"; });
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(false);
        });
        it("should throw when not found", function () {
            chai_1.expect(function () { return firstChild.getInstanceMethodOrThrow(function (m) { return m.getName() === "method9"; }); }).to.throw();
        });
    });
    describe("getStaticMethods", function () {
        describe("no static methods", function () {
            it("should not have any static methods", function () {
                var firstChild = testHelpers_1.getInfoFromText("class Identifier {\n}\n").firstChild;
                chai_1.expect(firstChild.getStaticMethods().length).to.equal(0);
            });
        });
        describe("has static methods", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier {\nstatic prop2: string;\nstatic method() {}\nprop: string;\nmethod1() {}\nmethod2() {}\n}\n").firstChild;
            it("should get the right number of static methods", function () {
                chai_1.expect(firstChild.getStaticMethods().length).to.equal(1);
            });
            it("should get a method of the right instance of", function () {
                chai_1.expect(firstChild.getStaticMethods()[0]).to.be.instanceOf(compiler_1.MethodDeclaration);
            });
        });
    });
    describe("getStaticMethod", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a method by name", function () {
            var method = firstChild.getStaticMethod("method");
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(true);
        });
        it("should get a property by function", function () {
            var method = firstChild.getStaticMethod(function (m) { return m.getName() === "method"; });
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(true);
        });
    });
    describe("getStaticMethodOrThrow", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a method by name", function () {
            var method = firstChild.getStaticMethodOrThrow("method");
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(true);
        });
        it("should get a property by function", function () {
            var method = firstChild.getStaticMethodOrThrow(function (m) { return m.getName() === "method"; });
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(true);
        });
        it("should throw when not found", function () {
            chai_1.expect(function () { return firstChild.getStaticMethodOrThrow(function (m) { return m.getName() === "method9"; }); }).to.throw();
        });
    });
    describe("getInstanceMembers", function () {
        var firstChild = testHelpers_1.getInfoFromText("class Identifier {\nconstructor(public p: string) {}\nstatic prop2: string;\nstatic method() {}\nprop: string;\n" +
            "prop2: number;method1() {}\n}\n").firstChild;
        it("should get the right number of instance members", function () {
            chai_1.expect(firstChild.getInstanceMembers().length).to.equal(4);
        });
    });
    describe("getInstanceMember", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a method by name", function () {
            var method = firstChild.getInstanceMember("method");
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(false);
        });
        it("should get a parameter property by name", function () {
            var method = firstChild.getInstanceMember("param3");
            chai_1.expect(method.getName()).to.equal("param3");
        });
        it("should get a method by function", function () {
            var method = firstChild.getInstanceMember(function (m) { return m.getName() === "method"; });
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(false);
        });
    });
    describe("getInstanceMemberOrThrow", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a method by name", function () {
            var method = firstChild.getInstanceMemberOrThrow("method");
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(false);
        });
        it("should get a method by function", function () {
            var method = firstChild.getInstanceMemberOrThrow(function (m) { return m.getName() === "method"; });
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(false);
        });
        it("should throw when not found", function () {
            chai_1.expect(function () { return firstChild.getInstanceMemberOrThrow(function (m) { return m.getName() === "method9"; }); }).to.throw();
        });
    });
    describe("getStaticMembers", function () {
        var firstChild = testHelpers_1.getInfoFromText("class Identifier {\nconstructor(public p: string) {}\nstatic prop2: string;\nstatic method() {}\nprop: string;\n" +
            "prop2: number;method1() {}\n}\n").firstChild;
        it("should get the right number of static members", function () {
            chai_1.expect(firstChild.getStaticMembers().length).to.equal(2);
        });
    });
    describe("getStaticMember", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a method by name", function () {
            var method = firstChild.getStaticMember("method");
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(true);
        });
        it("should get a property by function", function () {
            var method = firstChild.getStaticMember(function (m) { return m.getName() === "method"; });
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(true);
        });
    });
    describe("getStaticMemberOrThrow", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a method by name", function () {
            var method = firstChild.getStaticMemberOrThrow("method");
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(true);
        });
        it("should get a property by function", function () {
            var method = firstChild.getStaticMemberOrThrow(function (m) { return m.getName() === "method"; });
            chai_1.expect(method.getName()).to.equal("method");
            chai_1.expect(method.isStatic()).to.equal(true);
        });
        it("should throw when not found", function () {
            chai_1.expect(function () { return firstChild.getStaticMemberOrThrow(function (m) { return m.getName() === "method9"; }); }).to.throw();
        });
    });
    describe("getMembers", function () {
        it("should get the right number of instance, static, and constructor members in a non-ambient context", function () {
            var code = "class Identifier {\nconstructor();constructor(public param) {}\nstatic prop2: string;\nstatic method();" +
                "static method() { }\nabstract abstractMethod(): void; \n" +
                "prop: string;\nprop2: number;method1(str);method1() {}\n}\n";
            var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
            chai_1.expect(firstChild.getMembers().length).to.equal(7);
        });
        it("should get the right number of instance, static, and constructor members in an ambient context", function () {
            var code = "declare class Identifier {\nconstructor();constructor();\nstatic prop2: string;\nstatic method();static method();\n" +
                "prop: string;\nprop2: number;method1(str);method1();\n}\n";
            var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
            chai_1.expect(firstChild.getMembers().length).to.equal(9);
        });
    });
    describe("inserting members", function () {
        it("should insert methods and properties in the correct location when constructor parameters and overload signatures exist", function () {
            var _a = testHelpers_1.getInfoFromText("\nclass c {\n    constructor();\n    constructor(public param: string) {}\n\n    myMethod(): void;\n    myMethod(): void {\n    }\n}\n"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.insertProperty(1, { name: "prop2" });
            firstChild.insertMethod(1, { name: "method" });
            firstChild.insertProperty(0, { name: "prop1" });
            chai_1.expect(sourceFile.getFullText()).to.equal("\nclass c {\n    prop1;\n\n    constructor();\n    constructor(public param: string) {}\n\n    method() {\n    }\n\n    prop2;\n\n    myMethod(): void;\n    myMethod(): void {\n    }\n}\n");
        });
        it("should insert a constructor in the correct location when constructor parameters and overload signatures exist", function () {
            var _a = testHelpers_1.getInfoFromText("\nclass c {\n    constructor();\n    constructor(public param: string) {}\n\n    myMethod(): void;\n    myMethod(): void {\n    }\n}\n"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.insertConstructor(1, {}); // todo: should this be 2? A little iffy because it removes the previous constructor before inserting
            chai_1.expect(sourceFile.getFullText()).to.equal("\nclass c {\n    myMethod(): void;\n    myMethod(): void {\n    }\n\n    constructor() {\n    }\n}\n");
        });
    });
    describe("getMember", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a method by name", function () {
            var method = firstChild.getMember("method");
            chai_1.expect(method.getName()).to.equal("method");
        });
        it("should get a property by function", function () {
            var method = firstChild.getMember(function (m) { return utils_1.TypeGuards.isMethodDeclaration(m) && m.getName() === "method"; });
            chai_1.expect(method.getName()).to.equal("method");
        });
    });
    describe("getMemberOrThrow", function () {
        var code = "class Identifier {\nstatic prop2: string;\nstatic method() {}\n" +
            "constructor(param: string, public param2: string, readonly param3: string) {}\n" +
            "instanceProp: string;\nprop2: number;method() {}\n" +
            "get prop(): string {return '';}\nset prop(val: string) {}\n}\n";
        var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
        it("should get a method by name", function () {
            var method = firstChild.getMemberOrThrow("method");
            chai_1.expect(method.getName()).to.equal("method");
        });
        it("should get a property by function", function () {
            var method = firstChild.getMemberOrThrow(function (m) { return utils_1.TypeGuards.isMethodDeclaration(m) && m.getName() === "method"; });
            chai_1.expect(method.getName()).to.equal("method");
        });
        it("should throw when not found", function () {
            chai_1.expect(function () { return firstChild.getMemberOrThrow(function (m) { return utils_1.TypeGuards.isMethodDeclaration(m) && m.getName() === "method9"; }); }).to.throw();
        });
    });
    describe("getType", function () {
        it("should get the class' type", function () {
            var sourceFile = testHelpers_1.getInfoFromText("class Identifier { prop: string; }").sourceFile;
            chai_1.expect(sourceFile.getClassOrThrow("Identifier").getType().getText()).to.deep.equal("Identifier");
        });
    });
    describe("getBaseTypes", function () {
        function doTest(text, className, expectedNames) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            var types = sourceFile.getClassOrThrow(className).getBaseTypes();
            chai_1.expect(types.map(function (c) { return c.getText(); })).to.deep.equal(expectedNames);
        }
        it("should get the base when it's a class", function () {
            doTest("class Base {} class Child extends Base {}", "Child", ["Base"]);
        });
        it("should be empty when there is no base class", function () {
            doTest("class Class {}", "Class", []);
        });
        it("should be empty when it implements a class", function () {
            doTest("class Base { name: string; } class Child implements Base {}", "Child", []);
        });
        it("should get the mixin type", function () {
            doTest("\ntype Constructor<T> = new (...args: any[]) => T;\nclass Base {}\ninterface Mixin {}\n\nfunction Mixin<T extends Constructor<{}>>(Base: T): Constructor<Mixin> & T {\n    return class extends Base implements Mixin {}\n}\n\nclass Child extends Mixin(Base) {}\n", "Child", ["Mixin & Base"]);
        });
    });
    describe("getBaseClass", function () {
        function doTest(text, className, expectedName) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            var c = sourceFile.getClassOrThrow(className).getBaseClass();
            if (typeof expectedName === "undefined")
                chai_1.expect(c).to.be.undefined;
            else {
                chai_1.expect(c).to.not.be.undefined;
                chai_1.expect(c.getName()).to.equal(expectedName);
            }
        }
        it("should get the base when it's a class", function () {
            doTest("class Base {} class Child extends Base {}", "Child", "Base");
        });
        it("should be undefined when there is no base class", function () {
            doTest("class Class {}", "Class", undefined);
        });
        it("should be undefined when it implements a class", function () {
            doTest("class Base {} class Child implements Base {}", "Child", undefined);
        });
        it("should get the base class that's mixined", function () {
            doTest("\ntype Constructor<T> = new (...args: any[]) => T;\nclass Base {}\n\nfunction Mixin<T extends Constructor<{}>>(Base: T) {\n    return class extends Base {}\n}\n\nclass Child extends Mixin(Base) {}\n", "Child", "Base");
        });
    });
    describe("getBaseClassOrThrow", function () {
        function doTest(text, className, expectedName) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            if (typeof expectedName === "undefined")
                chai_1.expect(function () { return sourceFile.getClassOrThrow(className).getBaseClassOrThrow(); }).to.throw();
            else {
                chai_1.expect(sourceFile.getClassOrThrow(className).getBaseClassOrThrow().getName()).to.equal(expectedName);
            }
        }
        it("should get the base when it's a class", function () {
            doTest("class Base {} class Child extends Base {}", "Child", "Base");
        });
        it("should throw when there is no base class", function () {
            doTest("class Class {}", "Class", undefined);
        });
    });
    describe("getDerivedClasses", function () {
        function doTest(text, className, expectedNames) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            var classes = sourceFile.getClassOrThrow(className).getDerivedClasses();
            chai_1.expect(classes.map(function (c) { return c.getName(); })).to.deep.equal(expectedNames);
        }
        it("should get the class descendants", function () {
            doTest("class Base {} class Child1 extends Base {} class Child2 extends Base {} class Grandchild1<T> extends Child1 {} class GreatGrandChild1<T> extends Grandchild1<T> {}", "Base", ["Child1", "Child2", "Grandchild1", "GreatGrandChild1"]);
        });
        it("should not blow up for a circular references", function () {
            doTest("class Base extends GreatGrandChild1 {} class Child1 extends Base {} class Child2 extends Base {} class Grandchild1 extends Child1 {} " +
                "class GreatGrandChild1 extends Grandchild1 {}", "Base", ["Child1", "Child2", "Grandchild1", "GreatGrandChild1"]);
        });
        it("should get the class descendants when there are none", function () {
            doTest("class Base {} class Child1 extends Base {} class Child2 extends Base {} class Grandchild1 extends Child1 {}", "Grandchild1", []);
        });
    });
    describe("remove", function () {
        function doTest(text, index, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            sourceFile.getClasses()[index].remove();
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
        }
        it("should remove the class declaration", function () {
            doTest("class I {}\n\nclass J {}\n\nclass K {}", 1, "class I {}\n\nclass K {}");
        });
    });
});
