"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var compiler_1 = require("../../../compiler");
var testHelpers_1 = require("../testHelpers");
describe("MethodDeclaration", function () {
    describe("insertOverloads", function () {
        function doTest(startCode, index, structures, expectedCode, methodIndex) {
            if (methodIndex === void 0) { methodIndex = 0; }
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var methodDeclaration = firstChild.getMembers()[methodIndex];
            var result = methodDeclaration.insertOverloads(index, structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert when no other overloads exist", function () {
            doTest("class Identifier {\n    identifier() {}\n }", 0, [{ returnType: "number" }, {}], "class Identifier {\n    identifier(): number;\n    identifier();\n    identifier() {}\n }");
        });
        it("should insert when a JSDoc exists", function () {
            doTest("class Identifier {\n    otherMethod(): string {}\n\n    /** Test */\n    identifier() {}\n }", 0, [{ returnType: "number" }], "class Identifier {\n    otherMethod(): string {}\n\n    identifier(): number;\n    /** Test */\n    identifier() {}\n }", 1);
        });
        it("should copy over the static, abstract, and scope keywords", function () {
            doTest("class Identifier {\n    protected abstract static async *identifier() {}\n }", 0, [{ isStatic: false }, {}], "class Identifier {\n    protected abstract identifier();\n    protected abstract static identifier();\n    protected abstract static async *identifier() {}\n }");
        });
        it("should be able to insert at start when another overload exists", function () {
            doTest("class Identifier {\n    identifier();\n    identifier() {}\n }", 0, [{ returnType: "string" }], "class Identifier {\n    identifier(): string;\n    identifier();\n    identifier() {}\n }");
        });
        it("should be able to insert at end when another overload exists", function () {
            doTest("class Identifier {\n    identifier();\n    identifier() {}\n }", 1, [{ returnType: "string" }], "class Identifier {\n    identifier();\n    identifier(): string;\n    identifier() {}\n }");
        });
        it("should be able to insert in the middle when other overloads exists", function () {
            doTest("class Identifier {\n    identifier();\n    identifier();\n    identifier() {}\n }", 1, [{ returnType: "string" }], "class Identifier {\n    identifier();\n    identifier(): string;\n    identifier();\n    identifier() {}\n }");
        });
    });
    describe("insertOverload", function () {
        function doTest(startCode, index, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var methodDeclaration = firstChild.getMembers()[0];
            var result = methodDeclaration.insertOverload(index, structure);
            chai_1.expect(result).to.be.instanceof(compiler_1.MethodDeclaration);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should be able to insert in the middle when other overloads exists", function () {
            doTest("class Identifier {\n    identifier();\n    identifier();\n    identifier() {}\n }", 1, { returnType: "string" }, "class Identifier {\n    identifier();\n    identifier(): string;\n    identifier();\n    identifier() {}\n }");
        });
    });
    describe("addOverloads", function () {
        function doTest(startCode, structures, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var methodDeclaration = firstChild.getMembers()[0];
            var result = methodDeclaration.addOverloads(structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should be able to add multiple", function () {
            doTest("class Identifier {\n    identifier();\n    identifier() {}\n}", [{ returnType: "string" }, { returnType: "number" }], "class Identifier {\n    identifier();\n    identifier(): string;\n    identifier(): number;\n    identifier() {}\n}");
        });
    });
    describe("addOverload", function () {
        function doTest(startCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var methodDeclaration = firstChild.getMembers()[0];
            var result = methodDeclaration.addOverload(structure);
            chai_1.expect(result).to.be.instanceof(compiler_1.MethodDeclaration);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should be able to add an overload", function () {
            doTest("class Identifier {\n    identifier();\n    identifier() {}\n }", { returnType: "string" }, "class Identifier {\n    identifier();\n    identifier(): string;\n    identifier() {}\n }");
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var method = firstChild.getInstanceMethods()[0];
            method.fill(structure);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("class identifier {\n    method() {}\n}", {}, "class identifier {\n    method() {}\n}");
        });
        it("should modify when changed", function () {
            var structure = {
                overloads: [{ parameters: [{ name: "param" }] }]
            };
            doTest("class identifier {\n    method() {}\n}", structure, "class identifier {\n    method(param);\n    method() {}\n}");
        });
    });
    describe("remove", function () {
        describe("no overload", function () {
            function doTest(code, nameToRemove, expectedCode) {
                var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.getInstanceMethod(nameToRemove).remove();
                chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
            }
            it("should remove when it's the only method", function () {
                doTest("class Identifier {\n    method() {}\n}", "method", "class Identifier {\n}");
            });
            it("should remove when it's the first method", function () {
                doTest("class Identifier {\n    method() {}\n\n    method2() {}\n}", "method", "class Identifier {\n    method2() {}\n}");
            });
            it("should remove when it's the middle method", function () {
                doTest("class Identifier {\n    method1(){}\n\n    method2(){}\n\n    method3() {}\n}", "method2", "class Identifier {\n    method1(){}\n\n    method3() {}\n}");
            });
            it("should remove when the nodes all have js docs", function () {
                doTest("class Identifier {\n    /** Method1 */\n    method1(){}\n\n    /** Method2 */\n    method2(){}\n\n    /** Method3 */\n    method3() {}\n}", "method2", "class Identifier {\n    /** Method1 */\n    method1(){}\n\n    /** Method3 */\n    method3() {}\n}");
            });
            it("should remove when it's the last method", function () {
                doTest("class Identifier {\n    method() {}\n\n    method2() {}\n}", "method2", "class Identifier {\n    method() {}\n}");
            });
            it("should remove when it's beside a property ", function () {
                doTest("class Identifier {\n    method(){}\n\n    prop: string;\n}", "method", "class Identifier {\n    prop: string;\n}");
            });
            it("should remove when it's in an ambient class", function () {
                doTest("declare class Identifier {\n    method(): void;\n\n    prop: string;\n\n    method2(): void;\n}", "method", "declare class Identifier {\n    prop: string;\n\n    method2(): void;\n}");
            });
        });
        describe("overloads", function () {
            function doTest(code, nameToRemove, index, expectedCode) {
                var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                var method = firstChild.getInstanceMethod(nameToRemove);
                __spread(method.getOverloads(), [method])[index].remove();
                chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
            }
            it("should remove when surrounded by other members", function () {
                doTest("class Identifier {\n    prop: string;\n\nmethod(str): void;\n    method(param) {}\n\nprop2: string;\n}", "method", 1, "class Identifier {\n    prop: string;\nprop2: string;\n}");
            });
            it("should remove the method and all its overloads when calling on the body", function () {
                doTest("class Identifier {\n    method(str): void;\n    method(param) {}\n}", "method", 1, "class Identifier {\n}");
            });
            it("should remove only the specified overload", function () {
                doTest("class Identifier {\n    method(str): void;\n    method(param) {}\n}", "method", 0, "class Identifier {\n    method(param) {}\n}");
            });
            it("should remove when the first overload", function () {
                doTest("class Identifier {\n    method(first): void;\n    method(second): void;\n    method(param) {}\n}", "method", 0, "class Identifier {\n    method(second): void;\n    method(param) {}\n}");
            });
            it("should remove when the middle overload", function () {
                doTest("class Identifier {\n    method(first): void;\n    method(second): void;\n    method(third): void;\n    method(param) {}\n}", "method", 1, "class Identifier {\n    method(first): void;\n    method(third): void;\n    method(param) {}\n}");
            });
            it("should remove when the last overload", function () {
                doTest("class Identifier {\n    method(first): void;\n    method(last): void;\n    method(param) {}\n}", "method", 1, "class Identifier {\n    method(first): void;\n    method(param) {}\n}");
            });
            it("should remove only the specified overload and its jsdoc", function () {
                doTest("class Identifier {\n    /** Test */\n    method(str): void;\n    method(param) {}\n}", "method", 0, "class Identifier {\n    method(param) {}\n}");
            });
            it("should remove only the specified signature when it's in an ambient class", function () {
                doTest("declare class Identifier {\n    method(): void;\n    method(): void;\n}", "method", 1, "declare class Identifier {\n    method(): void;\n}");
            });
        });
    });
});
