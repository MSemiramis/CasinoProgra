"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = require("fs");
var path = require("path");
var Project_1 = require("../../../Project");
var fileSystem_1 = require("../../../fileSystem");
function getTextForLibFile(fileName) {
    return {
        filePath: path.join("node_modules/typescript/lib", fileName),
        text: fs.readFileSync(path.join(__dirname, "../../../../node_modules/typescript/lib", fileName), "utf-8")
    };
}
var libFileNames = [
    "lib.d.ts",
    "lib.es2017.full.d.ts",
    "lib.es2017.object.d.ts",
    "lib.es2017.sharedmemory.d.ts",
    "lib.es2017.string.d.ts",
    "lib.es2017.intl.d.ts",
    "lib.es2016.d.ts",
    "lib.es2015.d.ts",
    "lib.es2015.core.d.ts",
    "lib.es2015.collection.d.ts",
    "lib.es2015.generator.d.ts",
    "lib.es2015.promise.d.ts",
    "lib.es2015.iterable.d.ts",
    "lib.es2015.proxy.d.ts",
    "lib.es2015.reflect.d.ts",
    "lib.es2015.symbol.d.ts",
    "lib.es2015.symbol.wellknown.d.ts",
    "lib.es5.d.ts"
];
var libFiles = libFileNames.map(function (name) { return getTextForLibFile(name); });
/** @internal */
function getInfoFromText(text, opts) {
    var info = getInfoFromTextInternal(text, opts);
    return __assign({}, info, { firstChild: info.sourceFile.getChildSyntaxListOrThrow().getChildren()[0] });
}
exports.getInfoFromText = getInfoFromText;
function getInfoFromTextWithDescendant(text, descendantKind, opts) {
    var info = getInfoFromTextInternal(text, opts);
    return __assign({}, info, { descendant: info.sourceFile.getFirstDescendantByKindOrThrow(descendantKind) });
}
exports.getInfoFromTextWithDescendant = getInfoFromTextWithDescendant;
function getInfoFromTextInternal(text, opts) {
    // tslint:disable-next-line:no-unnecessary-initializer -- tslint not realizing undefined is required
    var _a = opts || {}, _b = _a.isDefinitionFile, isDefinitionFile = _b === void 0 ? false : _b, _c = _a.isJsx, isJsx = _c === void 0 ? false : _c, _d = _a.filePath, filePath = _d === void 0 ? undefined : _d, _e = _a.host, host = _e === void 0 ? new fileSystem_1.VirtualFileSystemHost() : _e, _f = _a.disableErrorCheck, disableErrorCheck = _f === void 0 ? false : _f, _g = _a.compilerOptions, compilerOptions = _g === void 0 ? undefined : _g, _h = _a.includeLibDts, includeLibDts = _h === void 0 ? false : _h;
    if (includeLibDts) {
        try {
            for (var libFiles_1 = __values(libFiles), libFiles_1_1 = libFiles_1.next(); !libFiles_1_1.done; libFiles_1_1 = libFiles_1.next()) {
                var libFile = libFiles_1_1.value;
                host.writeFileSync(libFile.filePath, libFile.text);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (libFiles_1_1 && !libFiles_1_1.done && (_j = libFiles_1.return)) _j.call(libFiles_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    var project = new Project_1.Project({ compilerOptions: compilerOptions }, host);
    var sourceFile = project.createSourceFile(getFilePath(), text);
    // disabled because the tests will run out of memory (I believe this is a ts compiler issue)
    /*
    if (!disableErrorCheck)
        ensureNoCompileErrorsInSourceFile(sourceFile);
    */
    return { project: project, sourceFile: sourceFile };
    function getFilePath() {
        if (filePath != null)
            return filePath;
        if (isJsx)
            return "testFile.tsx";
        return isDefinitionFile ? "testFile.d.ts" : "testFile.ts";
    }
    var e_1, _j;
}
function ensureNoCompileErrorsInSourceFile(sourceFile) {
    var diagnostics = sourceFile.getDiagnostics().filter(checkAllowDiagnostic);
    if (diagnostics.length === 0)
        return;
    console.log("SOURCE FILE");
    console.log("===========");
    console.log(sourceFile.getText());
    console.log("===========");
    try {
        for (var diagnostics_1 = __values(diagnostics), diagnostics_1_1 = diagnostics_1.next(); !diagnostics_1_1.done; diagnostics_1_1 = diagnostics_1.next()) {
            var diagnostic = diagnostics_1_1.value;
            console.log(diagnostic.getCode());
            console.log(diagnostic.getMessageText());
        }
    }
    catch (e_2_1) { e_2 = { error: e_2_1 }; }
    finally {
        try {
            if (diagnostics_1_1 && !diagnostics_1_1.done && (_a = diagnostics_1.return)) _a.call(diagnostics_1);
        }
        finally { if (e_2) throw e_2.error; }
    }
    throw new Error("Compile error!");
    var e_2, _a;
}
function checkAllowDiagnostic(diagnostic) {
    switch (diagnostic.getCode()) {
        case 7005: // no implicit any
        case 7025: // no implicit any
        case 2304: // cannot find name
        case 4020: // extends clause is using private name
        case 4019:// implements clause is using private name
            return false;
        default:
            return true;
    }
}
