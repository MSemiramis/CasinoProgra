"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var main_1 = require("../../../main");
var typescript_1 = require("../../../typescript");
var utils_1 = require("../../../utils");
var testHelpers_1 = require("../testHelpers");
describe("ExportSpecifier", function () {
    function getProject() {
        return new main_1.default({ useVirtualFileSystem: true });
    }
    describe("getNameNode", function () {
        function doTest(text, name) {
            var firstChild = testHelpers_1.getInfoFromText(text).firstChild;
            var namedExport = firstChild.getNamedExports()[0];
            chai_1.expect(namedExport.getNameNode().getText()).to.equal(name);
        }
        it("should get the name when there is no alias", function () {
            doTest("export {name} from \"./test\";", "name");
        });
        it("should get the name when there is an alias", function () {
            doTest("export {name as alias} from \"./test\";", "name");
        });
        it("should get the identifier when it's a default keyword", function () {
            doTest("export {default as alias} from \"./test\";", "default");
        });
    });
    describe("setName", function () {
        it("should change what's imported, but not change anything in the other files", function () {
            var project = getProject();
            var myClassFile = project.createSourceFile("MyClass.ts", {
                classes: [{ name: "MyClass", isExported: true }]
            });
            var exportsFile = project.createSourceFile("Exports.ts", {
                exports: [{ namedExports: ["MyClass"], moduleSpecifier: "./MyClass" }]
            });
            var mainFile = project.createSourceFile("Main.ts", "import {MyClass} from \"./Exports\";\n\nconst t = MyClass;\n");
            exportsFile.getExportDeclarations()[0].getNamedExports()[0].setName("MyNewName");
            chai_1.expect(myClassFile.getFullText()).to.equal("export class MyClass {\n}\n");
            chai_1.expect(exportsFile.getFullText()).to.equal("export {MyNewName} from \"./MyClass\";\n");
            chai_1.expect(mainFile.getFullText()).to.equal("import {MyClass} from \"./Exports\";\n\nconst t = MyClass;\n");
        });
        it("should change it when there's an alias", function () {
            var project = getProject();
            var exportsFile = project.createSourceFile("Exports.ts", {
                exports: [{ namedExports: [{ name: "MyClass", alias: "MyAlias" }], moduleSpecifier: "./MyClass" }]
            });
            exportsFile.getExportDeclarations()[0].getNamedExports()[0].setName("MyNewName");
            chai_1.expect(exportsFile.getFullText()).to.equal("export {MyNewName as MyAlias} from \"./MyClass\";\n");
        });
        it("should rename in current file if exporting from current file", function () {
            var project = getProject();
            var myClassFile = project.createSourceFile("MyClass.ts", {
                classes: [{ name: "MyClass" }],
                exports: [{ namedExports: ["MyClass"] }]
            });
            myClassFile.getExportDeclarations()[0].getNamedExports()[0].setName("Identifier");
            chai_1.expect(myClassFile.getFullText()).to.equal("class MyClass {\n}\n\nexport {Identifier};\n");
        });
    });
    describe("renameName", function () {
        it("should rename in current file if exporting from current file", function () {
            var project = getProject();
            var myClassFile = project.createSourceFile("MyClass.ts", {
                classes: [{ name: "MyClass" }],
                exports: [{ namedExports: ["MyClass"] }]
            });
            myClassFile.getExportDeclarations()[0].getNamedExports()[0].renameName("Identifier");
            chai_1.expect(myClassFile.getFullText()).to.equal("class Identifier {\n}\n\nexport {Identifier};\n");
        });
    });
    describe("getAliasIdentifier", function () {
        function doTest(text, alias) {
            var firstChild = testHelpers_1.getInfoFromText(text).firstChild;
            var namedExport = firstChild.getNamedExports()[0];
            if (alias == null)
                chai_1.expect(namedExport.getAliasIdentifier()).to.equal(undefined);
            else
                chai_1.expect(namedExport.getAliasIdentifier().getText()).to.equal(alias);
        }
        it("should be undefined there is no alias", function () {
            doTest("export {name} from \"./test\";", undefined);
        });
        it("should get the alias when there is an alias", function () {
            doTest("export {name as alias} from \"./test\";", "alias");
        });
        it("should get the alias when there is a default keyword", function () {
            doTest("export {default as alias} from \"./test\";", "alias");
        });
    });
    describe("setAlias", function () {
        it("should rename existing alias", function () {
            var project = getProject();
            var myClassFile = project.createSourceFile("MyClass.ts", {
                classes: [{ name: "MyClass", isExported: true }]
            });
            var exportsFile = project.createSourceFile("Exports.ts", {
                exports: [{ namedExports: [{ name: "MyClass", alias: "MyAlias" }], moduleSpecifier: "./MyClass" }]
            });
            var mainFile = project.createSourceFile("Main.ts", "import {MyAlias} from \"./Exports\";\n\nconst t = MyAlias;\n");
            exportsFile.getExportDeclarations()[0].getNamedExports()[0].setAlias("MyNewAlias");
            chai_1.expect(exportsFile.getFullText()).to.equal("export {MyClass as MyNewAlias} from \"./MyClass\";\n");
            chai_1.expect(mainFile.getFullText()).to.equal("import {MyNewAlias} from \"./Exports\";\n\nconst t = MyNewAlias;\n");
        });
        it("should add new alias and update all usages to the new alias", function () {
            var project = getProject();
            var myClassFile = project.createSourceFile("MyClass.ts", {
                classes: [{ name: "MyClass", isExported: true }]
            });
            var exportsFile = project.createSourceFile("Exports.ts", {
                exports: [{ namedExports: ["MyClass"], moduleSpecifier: "./MyClass" }]
            });
            var mainFile = project.createSourceFile("Main.ts", "import {MyClass} from \"./Exports\";\n\nconst t = MyClass;\n");
            exportsFile.getExportDeclarations()[0].getNamedExports()[0].setAlias("MyNewAlias");
            chai_1.expect(myClassFile.getFullText()).to.equal("export class MyClass {\n}\n");
            chai_1.expect(exportsFile.getFullText()).to.equal("export {MyClass as MyNewAlias} from \"./MyClass\";\n");
            chai_1.expect(mainFile.getFullText()).to.equal("import {MyNewAlias} from \"./Exports\";\n\nconst t = MyNewAlias;\n");
        });
    });
    function setupLocalTargetSymbolTest() {
        var project = getProject();
        var mainFile = project.createSourceFile("main.ts", "export {MyClass, OtherClass} from \"./MyClass\";");
        var myClassFile = project.createSourceFile("MyClass.ts", "export class MyClass {}");
        return mainFile.getExportDeclarations()[0].getNamedExports();
    }
    describe("getLocalTargetSymbol", function () {
        it("should get the local target symbol when it exists", function () {
            var myClassExportSpecifier = setupLocalTargetSymbolTest()[0];
            chai_1.expect(myClassExportSpecifier.getLocalTargetSymbol().getDeclarations()[0].getKind()).to.equal(typescript_1.SyntaxKind.ClassDeclaration);
        });
        it("should returned undefined when it doesn't exist", function () {
            var otherClassExportSpecifier = setupLocalTargetSymbolTest()[1];
            chai_1.expect(otherClassExportSpecifier.getLocalTargetSymbol()).to.be.undefined;
        });
    });
    describe("getLocalTargetSymbolOrThrow", function () {
        it("should get the local target symbol when it exists", function () {
            var myClassExportSpecifier = setupLocalTargetSymbolTest()[0];
            chai_1.expect(myClassExportSpecifier.getLocalTargetSymbolOrThrow().getDeclarations()[0].getKind()).to.equal(typescript_1.SyntaxKind.ClassDeclaration);
        });
        it("should throw when it doesn't exist", function () {
            var otherClassExportSpecifier = setupLocalTargetSymbolTest()[1];
            chai_1.expect(function () { return otherClassExportSpecifier.getLocalTargetSymbolOrThrow(); }).to.throw();
        });
    });
    describe("getLocalTargetDeclarations", function () {
        it("should get the local target declarations when they exist", function () {
            var myClassExportSpecifier = setupLocalTargetSymbolTest()[0];
            chai_1.expect(myClassExportSpecifier.getLocalTargetDeclarations().map(function (d) { return d.getKind(); })).to.deep.equal([typescript_1.SyntaxKind.ClassDeclaration]);
        });
        it("should returned an empty array when they don't exist", function () {
            var otherClassExportSpecifier = setupLocalTargetSymbolTest()[1];
            chai_1.expect(otherClassExportSpecifier.getLocalTargetDeclarations()).to.deep.equal([]);
        });
    });
    describe("getExportDeclaration", function () {
        it("should get the parent export declaration", function () {
            var firstChild = testHelpers_1.getInfoFromText("export {name} from \"./test\";").firstChild;
            var namedExport = firstChild.getNamedExports()[0];
            chai_1.expect(namedExport.getExportDeclaration()).to.equal(firstChild);
        });
    });
    describe("remove", function () {
        function doTest(text, nameToRemove, expectedText) {
            var _a = testHelpers_1.getInfoFromText(text), sourceFile = _a.sourceFile, firstChild = _a.firstChild;
            var namedExport = utils_1.ArrayUtils.find(firstChild.getNamedExports(), function (e) { return e.getNameNode().getText() === nameToRemove; });
            namedExport.remove();
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
        }
        it("should change to a namespace import when there's only one to remove and a module specifier exists", function () {
            doTest("export {name} from \"./test\";", "name", "export * from \"./test\";");
        });
        it("should remove the export declaration when there's only one to remove and no module specifier exists", function () {
            doTest("export {name};", "name", "");
        });
        it("should remove the named import when it's the first", function () {
            doTest("export {name1, name2} from \"./test\";", "name1", "export {name2} from \"./test\";");
        });
        it("should remove the named import when it's in the middle", function () {
            doTest("export {name1, name2, name3} from \"./test\";", "name2", "export {name1, name3} from \"./test\";");
        });
        it("should remove the named import when it's the last", function () {
            doTest("export {name1, name2} from \"./test\";", "name2", "export {name1} from \"./test\";");
        });
    });
});
