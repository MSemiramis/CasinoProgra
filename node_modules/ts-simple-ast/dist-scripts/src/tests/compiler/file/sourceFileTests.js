"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var errors = require("../../../errors");
var typescript_1 = require("../../../typescript");
var compiler_1 = require("../../../compiler");
var ManipulationSettings_1 = require("../../../ManipulationSettings");
var testHelpers_1 = require("../testHelpers");
var testHelpers_2 = require("../../testHelpers");
var Project_1 = require("../../../Project");
describe("SourceFile", function () {
    describe("copy", function () {
        describe("general", function () {
            var fileText = "    interface Identifier {}    ";
            var _a = testHelpers_1.getInfoFromText(fileText, { filePath: "Folder/File.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var relativeSourceFile = sourceFile.copy("../NewFolder/NewFile.ts");
            var absoluteSourceFile = sourceFile.copy("/NewFile.ts");
            var testFile = sourceFile.copy("/TestFile.ts");
            it("should throw if the file already exists", function () {
                chai_1.expect(function () { return sourceFile.copy("/TestFile.ts"); }).to.throw(errors.InvalidOperationError, "Did you mean to provide the overwrite option? A source file already exists at the provided file path: /TestFile.ts");
            });
            it("should overwrite if specifying to overwrite", function () {
                var newText = "const t = 5;";
                sourceFile.replaceWithText(newText);
                var copiedFile = sourceFile.copy("/TestFile.ts", { overwrite: true });
                chai_1.expect(copiedFile).to.equal(testFile);
                chai_1.expect(copiedFile.getFullText()).to.equal(newText);
                chai_1.expect(testFile.getFullText()).to.equal(newText);
            });
            describe("project", function () {
                it("should include the copied source files", function () {
                    chai_1.expect(project.getSourceFiles().length).to.equal(4);
                });
            });
            describe("relative source file", function () {
                it("should not be saved", function () {
                    chai_1.expect(relativeSourceFile.isSaved()).to.be.false;
                });
                it("should have have the same text", function () {
                    chai_1.expect(relativeSourceFile.getFullText()).to.equal(fileText);
                });
                it("should have the expected path", function () {
                    chai_1.expect(relativeSourceFile.getFilePath()).to.equal("/NewFolder/NewFile.ts");
                });
            });
            describe("absolute source file", function () {
                it("should not be saved", function () {
                    chai_1.expect(absoluteSourceFile.isSaved()).to.be.false;
                });
                it("should have have the same text", function () {
                    chai_1.expect(absoluteSourceFile.getFullText()).to.equal(fileText);
                });
                it("should have the expected path", function () {
                    chai_1.expect(absoluteSourceFile.getFilePath()).to.equal("/NewFile.ts");
                });
            });
        });
        it("should return the existing source file when copying to the same path", function () {
            var _a = testHelpers_1.getInfoFromText("", { filePath: "/Folder/File.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var copiedSourceFile = sourceFile.copy(sourceFile.getFilePath());
            chai_1.expect(copiedSourceFile).to.equal(sourceFile);
        });
        it("should update the imports and exports in the copied source file", function () {
            var originalText = "import {MyInterface} from \"./MyInterface\";\nexport * from \"./MyInterface\";";
            var _a = testHelpers_1.getInfoFromText(originalText, { filePath: "/dir/File.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var otherFile = project.createSourceFile("/dir/MyInterface.ts", "export interface MyInterface {}");
            var copiedSourceFile = sourceFile.copy("../NewFile");
            chai_1.expect(sourceFile.getFullText()).to.equal(originalText);
            chai_1.expect(copiedSourceFile.getFullText()).to.equal("import {MyInterface} from \"./dir/MyInterface\";\nexport * from \"./dir/MyInterface\";");
        });
        it("should not update the imports and exports if copying to the same directory", function () {
            // module specifiers are this way to check if they change
            var originalText = "import {MyInterface} from \"../dir/MyInterface\";\nexport * from \"../dir/MyInterface\";";
            var _a = testHelpers_1.getInfoFromText(originalText, { filePath: "/dir/File.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var otherFile = project.createSourceFile("/dir/MyInterface.ts", "export interface MyInterface {}");
            var copiedSourceFile = sourceFile.copy("NewFile");
            chai_1.expect(sourceFile.getFullText()).to.equal(originalText);
            chai_1.expect(copiedSourceFile.getFullText()).to.equal(originalText);
        });
    });
    describe("copyImmediately", function () {
        it("should copy the source file and update the file system", function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, sourceFile, project, fileSystem, newSourceFile;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = testHelpers_1.getInfoFromText("", { filePath: "/File.ts" }), sourceFile = _a.sourceFile, project = _a.project;
                        fileSystem = project.getFileSystem();
                        project.saveSync();
                        return [4 /*yield*/, sourceFile.copyImmediately("NewFile.ts")];
                    case 1:
                        newSourceFile = _b.sent();
                        chai_1.expect(fileSystem.fileExistsSync("/File.ts")).to.be.true;
                        chai_1.expect(fileSystem.fileExistsSync("/NewFile.ts")).to.be.true;
                        chai_1.expect(sourceFile.getFilePath()).to.equal("/File.ts");
                        chai_1.expect(newSourceFile.getFilePath()).to.equal("/NewFile.ts");
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("copyImmediatelySync", function () {
        it("should copy the source file and update the file system", function () {
            var _a = testHelpers_1.getInfoFromText("", { filePath: "/File.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var fileSystem = project.getFileSystem();
            project.saveSync();
            var newSourceFile = sourceFile.copyImmediatelySync("NewFile.ts");
            chai_1.expect(fileSystem.fileExistsSync("/File.ts")).to.be.true;
            chai_1.expect(fileSystem.fileExistsSync("/NewFile.ts")).to.be.true;
            chai_1.expect(sourceFile.getFilePath()).to.equal("/File.ts");
            chai_1.expect(newSourceFile.getFilePath()).to.equal("/NewFile.ts");
        });
    });
    describe("move", function () {
        function doTest(filePath, newFilePath, absoluteNewFilePath, overwrite) {
            var fileText = "    interface Identifier {}    ";
            var _a = testHelpers_1.getInfoFromText(fileText, { filePath: filePath }), sourceFile = _a.sourceFile, project = _a.project;
            var fileSystem = project.getFileSystem();
            var existingFile = project.createSourceFile("/existingFile.ts");
            project.saveSync();
            var interfaceDec = sourceFile.getInterfaceOrThrow("Identifier");
            var newFile = sourceFile.move(newFilePath, { overwrite: overwrite });
            var isRemovingExisting = overwrite && newFilePath === "/existingFile.ts";
            if (isRemovingExisting)
                chai_1.expect(existingFile.wasForgotten()).to.be.true;
            chai_1.expect(newFile).to.equal(sourceFile);
            chai_1.expect(sourceFile.getFilePath()).to.equal(absoluteNewFilePath || newFilePath);
            chai_1.expect(sourceFile.getFullText()).to.equal(fileText);
            chai_1.expect(project.getSourceFile(filePath)).to.be.undefined;
            chai_1.expect(project.getSourceFile(absoluteNewFilePath || newFilePath)).to.not.be.undefined;
            chai_1.expect(interfaceDec.wasForgotten()).to.be.false;
            chai_1.expect(project.getSourceFiles().length).to.equal(isRemovingExisting ? 1 : 2);
            project.saveSync();
            chai_1.expect(fileSystem.fileExistsSync(absoluteNewFilePath || newFilePath)).to.be.true;
            chai_1.expect(fileSystem.fileExistsSync(filePath)).to.be.false;
        }
        it("should throw if the file already exists", function () {
            chai_1.expect(function () { return doTest("/file.ts", "/existingFile.ts"); }).to.throw(errors.InvalidOperationError, "Did you mean to provide the overwrite option? A source file already exists at the provided file path: /existingFile.ts");
        });
        it("should not throw if the file already exists and the overwrite option was provided", function () {
            doTest("/file.ts", "/existingFile.ts", undefined, true);
        });
        it("should not throw if the file does not exists and the overwrite option was provided", function () {
            doTest("/file.ts", "/newFile.ts", undefined, true);
        });
        it("should move to a relative file path", function () {
            doTest("/dir/file.ts", "../subDir/existingFile.ts", "/subDir/existingFile.ts");
        });
        it("should change the module specifiers in other files when moving", function () {
            var fileText = "export interface MyInterface {}\nexport class MyClass {};";
            var _a = testHelpers_1.getInfoFromText(fileText, { filePath: "/MyInterface.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var file1 = project.createSourceFile("/file.ts", "import {MyInterface} from \"./MyInterface\";\nasync function t() { const test = await import('./MyInterface'); }");
            var file2 = project.createSourceFile("/sub/file2.ts", "import * as interfaces from \"../MyInterface\";\nimport \"./../MyInterface\";");
            var file3 = project.createSourceFile("/sub/file3.ts", "export * from \"../MyInterface\";\nimport t = require(\"./../MyInterface\");");
            var file4Text = "export * from \"./sub/MyInterface\";\nimport \"MyOtherFile\";";
            var file4 = project.createSourceFile("/file4.ts", file4Text);
            sourceFile.move("/dir/NewFile.ts");
            chai_1.expect(file1.getFullText()).to.equal("import {MyInterface} from \"./dir/NewFile\";\nasync function t() { const test = await import('./dir/NewFile'); }");
            chai_1.expect(file2.getFullText()).to.equal("import * as interfaces from \"../dir/NewFile\";\nimport \"../dir/NewFile\";");
            chai_1.expect(file3.getFullText()).to.equal("export * from \"../dir/NewFile\";\nimport t = require(\"../dir/NewFile\");");
            chai_1.expect(file4.getFullText()).to.equal(file4Text);
        });
        it("should change the module specifiers in other files when moving an index file", function () {
            var fileText = "export interface MyInterface {}";
            var _a = testHelpers_1.getInfoFromText(fileText, { filePath: "/sub/index.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var file1 = project.createSourceFile("/file.ts", "import * as test from \"./sub\";");
            var file2 = project.createSourceFile("/file2.ts", "import \"./sub/index\";");
            sourceFile.move("/dir/index.ts");
            chai_1.expect(file1.getFullText()).to.equal("import * as test from \"./dir\";");
            chai_1.expect(file2.getFullText()).to.equal("import \"./dir\";");
        });
        it("should change the module specifiers in the current file when moving", function () {
            var fileText = "import {OtherInterface} from \"./OtherInterface\";\nexport interface MyInterface {}\nexport * from \"./OtherInterface\";";
            var _a = testHelpers_1.getInfoFromText(fileText, { filePath: "/MyInterface.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var otherFile = project.createSourceFile("/OtherInterface.ts", "import {MyInterface} from \"./MyInterface\";\nexport interface OtherInterface {}");
            sourceFile.move("/dir/NewFile.ts");
            chai_1.expect(sourceFile.getFullText()).to.equal("import {OtherInterface} from \"../OtherInterface\";\nexport interface MyInterface {}\nexport * from \"../OtherInterface\";");
            chai_1.expect(otherFile.getFullText()).to.equal("import {MyInterface} from \"./dir/NewFile\";\nexport interface OtherInterface {}");
        });
        it("should not change the module specifiers in the current file when moving to the same directory", function () {
            // using a weird module specifier to make sure it doesn't update automatically
            var fileText = "import {OtherInterface} from \"../dir/OtherInterface\";\nexport interface MyInterface {}\nexport * from \"../dir/OtherInterface\";";
            var _a = testHelpers_1.getInfoFromText(fileText, { filePath: "/dir/MyInterface.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var otherFile = project.createSourceFile("/dir/OtherInterface.ts", "import {MyInterface} from \"./MyInterface\";\nexport interface OtherInterface {}");
            sourceFile.move("NewFile.ts");
            chai_1.expect(sourceFile.getFullText()).to.equal("import {OtherInterface} from \"../dir/OtherInterface\";\n" +
                "export interface MyInterface {}\n" +
                "export * from \"../dir/OtherInterface\";");
            chai_1.expect(otherFile.getFullText()).to.equal("import {MyInterface} from \"./NewFile\";\nexport interface OtherInterface {}");
        });
    });
    describe("moveImmediately", function () {
        it("should move the source file and update the file system", function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, sourceFile, project, fileSystem;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = testHelpers_1.getInfoFromText("", { filePath: "/File.ts" }), sourceFile = _a.sourceFile, project = _a.project;
                        fileSystem = project.getFileSystem();
                        project.saveSync();
                        return [4 /*yield*/, sourceFile.moveImmediately("NewFile.ts")];
                    case 1:
                        _b.sent();
                        chai_1.expect(fileSystem.fileExistsSync("/File.ts")).to.be.false;
                        chai_1.expect(fileSystem.fileExistsSync("/NewFile.ts")).to.be.true;
                        return [2 /*return*/];
                }
            });
        }); });
        it("should only save source file when moving to the same path", function () { return __awaiter(_this, void 0, void 0, function () {
            var filePath, host, _a, sourceFile, project, fileSystem;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        filePath = "/File.ts";
                        host = testHelpers_2.getFileSystemHostWithFiles([]);
                        _a = testHelpers_1.getInfoFromText("", { filePath: filePath, host: host }), sourceFile = _a.sourceFile, project = _a.project;
                        fileSystem = project.getFileSystem();
                        project.saveSync();
                        return [4 /*yield*/, sourceFile.moveImmediately(filePath)];
                    case 1:
                        _b.sent();
                        chai_1.expect(fileSystem.fileExistsSync(filePath)).to.be.true;
                        chai_1.expect(host.getDeleteLog().length).to.equal(0);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("moveImmediatelySync", function () {
        it("should move the source file and update the file system", function () {
            var _a = testHelpers_1.getInfoFromText("", { filePath: "/File.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var fileSystem = project.getFileSystem();
            project.saveSync();
            sourceFile.moveImmediatelySync("NewFile.ts");
            chai_1.expect(fileSystem.fileExistsSync("/File.ts")).to.be.false;
            chai_1.expect(fileSystem.fileExistsSync("/NewFile.ts")).to.be.true;
        });
        it("should only save source file when moving to the same path", function () {
            var filePath = "/File.ts";
            var host = testHelpers_2.getFileSystemHostWithFiles([]);
            var _a = testHelpers_1.getInfoFromText("", { filePath: filePath, host: host }), sourceFile = _a.sourceFile, project = _a.project;
            var fileSystem = project.getFileSystem();
            project.saveSync();
            sourceFile.moveImmediatelySync(filePath);
            chai_1.expect(fileSystem.fileExistsSync(filePath)).to.be.true;
            chai_1.expect(host.getDeleteLog().length).to.equal(0);
        });
    });
    describe("save", function () {
        var fileText = "    interface Identifier {}    ";
        var filePath = "/Folder/File.ts";
        var host = testHelpers_2.getFileSystemHostWithFiles([]);
        var sourceFile = testHelpers_1.getInfoFromText(fileText, { filePath: filePath, host: host }).sourceFile;
        it("should save the file", function () { return __awaiter(_this, void 0, void 0, function () {
            var writeLog, entry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        chai_1.expect(sourceFile.isSaved()).to.be.false;
                        return [4 /*yield*/, sourceFile.save()];
                    case 1:
                        _a.sent();
                        chai_1.expect(sourceFile.isSaved()).to.be.true;
                        writeLog = host.getWriteLog();
                        entry = writeLog[0];
                        chai_1.expect(entry.filePath).to.equal(filePath);
                        chai_1.expect(entry.fileText).to.equal(fileText);
                        chai_1.expect(writeLog.length).to.equal(1);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("delete", function () {
        it("should delete the file once save changes is called", function () { return __awaiter(_this, void 0, void 0, function () {
            var filePath, host, _a, sourceFile, project, entry;
            return __generator(this, function (_b) {
                filePath = "/Folder/File.ts";
                host = testHelpers_2.getFileSystemHostWithFiles([]);
                _a = testHelpers_1.getInfoFromText("", { filePath: filePath, host: host }), sourceFile = _a.sourceFile, project = _a.project;
                sourceFile.saveSync();
                sourceFile.delete();
                chai_1.expect(sourceFile.wasForgotten()).to.be.true;
                chai_1.expect(host.getDeleteLog().length).to.equal(0);
                project.saveSync();
                entry = host.getDeleteLog()[0];
                chai_1.expect(entry.path).to.equal(filePath);
                chai_1.expect(host.getDeleteLog().length).to.equal(1);
                chai_1.expect(host.getFiles()).to.deep.equal([]);
                return [2 /*return*/];
            });
        }); });
    });
    describe("deleteImmediately", function () {
        var filePath = "/Folder/File.ts";
        var host = testHelpers_2.getFileSystemHostWithFiles([]);
        var sourceFile = testHelpers_1.getInfoFromText("", { filePath: filePath, host: host }).sourceFile;
        sourceFile.saveSync();
        it("should delete the file", function () { return __awaiter(_this, void 0, void 0, function () {
            var deleteLog, entry;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, sourceFile.deleteImmediately()];
                    case 1:
                        _a.sent();
                        chai_1.expect(sourceFile.wasForgotten()).to.be.true;
                        deleteLog = host.getDeleteLog();
                        entry = deleteLog[0];
                        chai_1.expect(entry.path).to.equal(filePath);
                        chai_1.expect(deleteLog.length).to.equal(1);
                        chai_1.expect(host.getFiles()).to.deep.equal([]);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("deleteImmediatelySync", function () {
        var filePath = "/Folder/File.ts";
        var host = testHelpers_2.getFileSystemHostWithFiles([]);
        var sourceFile = testHelpers_1.getInfoFromText("", { filePath: filePath, host: host }).sourceFile;
        sourceFile.saveSync();
        it("should delete the file", function () {
            sourceFile.deleteImmediatelySync();
            chai_1.expect(sourceFile.wasForgotten()).to.be.true;
            var deleteLog = host.getDeleteLog();
            var entry = deleteLog[0];
            chai_1.expect(entry.path).to.equal(filePath);
            chai_1.expect(deleteLog.length).to.equal(1);
            chai_1.expect(host.getFiles()).to.deep.equal([]);
        });
    });
    describe("isSaved", function () {
        var filePath = "/Folder/File.ts";
        it("should not be saved after doing an action that will replace the tree", function () {
            var host = testHelpers_2.getFileSystemHostWithFiles([]);
            var sourceFile = testHelpers_1.getInfoFromText("class MyClass {}", { filePath: filePath, host: host }).sourceFile;
            chai_1.expect(sourceFile.isSaved()).to.be.false;
            sourceFile.saveSync();
            chai_1.expect(sourceFile.isSaved()).to.be.true;
            sourceFile.addClass({ name: "NewClass" });
            chai_1.expect(sourceFile.isSaved()).to.be.false;
        });
        it("should not be saved after doing an action that changes only the text", function () {
            var host = testHelpers_2.getFileSystemHostWithFiles([]);
            var sourceFile = testHelpers_1.getInfoFromText("class MyClass {}", { filePath: filePath, host: host }).sourceFile;
            chai_1.expect(sourceFile.isSaved()).to.be.false;
            sourceFile.saveSync();
            chai_1.expect(sourceFile.isSaved()).to.be.true;
            sourceFile.getClasses()[0].rename("NewClassName");
            chai_1.expect(sourceFile.isSaved()).to.be.false;
        });
    });
    describe("saveSync", function () {
        var fileText = "    interface Identifier {}    ";
        var filePath = "/Folder/File.ts";
        var host = testHelpers_2.getFileSystemHostWithFiles([]);
        var sourceFile = testHelpers_1.getInfoFromText(fileText, { filePath: filePath, host: host }).sourceFile;
        it("should save the file", function () {
            chai_1.expect(sourceFile.isSaved()).to.be.false;
            sourceFile.saveSync();
            chai_1.expect(sourceFile.isSaved()).to.be.true;
            var writeLog = host.getSyncWriteLog();
            var entry = writeLog[0];
            chai_1.expect(entry.filePath).to.equal(filePath);
            chai_1.expect(entry.fileText).to.equal(fileText);
            chai_1.expect(writeLog.length).to.equal(1);
        });
    });
    describe("isDeclarationFile", function () {
        it("should be a source file when the file name ends with .d.ts", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var sourceFile = project.createSourceFile("MyFile.d.ts", "");
            chai_1.expect(sourceFile.isDeclarationFile()).to.be.true;
        });
        it("should not be a source file when the file name ends with .ts", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var sourceFile = project.createSourceFile("MyFile.ts", "");
            chai_1.expect(sourceFile.isDeclarationFile()).to.be.false;
        });
    });
    describe("insertImportDeclarations", function () {
        function doTest(startCode, index, structures, expectedCode, useSingleQuotes) {
            if (useSingleQuotes === void 0) { useSingleQuotes = false; }
            var _a = testHelpers_1.getInfoFromText(startCode), sourceFile = _a.sourceFile, project = _a.project;
            if (useSingleQuotes)
                project.manipulationSettings.set({ quoteType: compiler_1.QuoteType.Single });
            var result = sourceFile.insertImportDeclarations(index, structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should insert the different kinds of imports", function () {
            doTest("", 0, [
                { moduleSpecifier: "./test" },
                { defaultImport: "identifier", moduleSpecifier: "./test" },
                { defaultImport: "identifier", namespaceImport: "name", moduleSpecifier: "./test" },
                { defaultImport: "identifier", namedImports: ["name1", { name: "name" }, { name: "name", alias: "alias" }], moduleSpecifier: "./test" },
                { namedImports: ["name"], moduleSpecifier: "./test" },
                { namespaceImport: "name", moduleSpecifier: "./test" }
            ], [
                "import \"./test\";",
                "import identifier from \"./test\";",
                "import identifier, * as name from \"./test\";",
                "import identifier, {name1, name, name as alias} from \"./test\";",
                "import {name} from \"./test\";",
                "import * as name from \"./test\";"
            ].join("\n") + "\n");
        });
        it("should throw when specifying a namespace import and named imports", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(function () {
                sourceFile.insertImportDeclarations(0, [{ namespaceImport: "name", namedImports: ["name"], moduleSpecifier: "file" }]);
            }).to.throw();
        });
        it("should insert at the beginning and use single quotes when specified", function () {
            doTest("export class Class {}\n", 0, [{ moduleSpecifier: "./test" }], "import './test';\n\nexport class Class {}\n", true);
        });
        it("should insert in the middle", function () {
            doTest("import \"./file1\";\nimport \"./file3\";\n", 1, [{ moduleSpecifier: "./file2" }], "import \"./file1\";\nimport \"./file2\";\nimport \"./file3\";\n");
        });
        it("should insert at the end", function () {
            doTest("export class Class {}\n", 1, [{ moduleSpecifier: "./test" }], "export class Class {}\n\nimport \"./test\";\n");
        });
    });
    describe("insertImportDeclaration", function () {
        function doTest(startCode, index, structure, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.insertImportDeclaration(index, structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ImportDeclaration);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should insert at the specified position", function () {
            doTest("import \"./file1\";\nimport \"./file3\";\n", 1, { moduleSpecifier: "./file2" }, "import \"./file1\";\nimport \"./file2\";\nimport \"./file3\";\n");
        });
    });
    describe("addImportDeclaration", function () {
        function doTest(startCode, structure, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addImportDeclaration(structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ImportDeclaration);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should add at the last import if one exists", function () {
            doTest("import \"./file1\";\nimport \"./file2\";\n\nexport class MyClass {}\n", { moduleSpecifier: "./file3" }, "import \"./file1\";\nimport \"./file2\";\nimport \"./file3\";\n\nexport class MyClass {}\n");
        });
        it("should add at the start if no imports exists", function () {
            doTest("export class MyClass {}\n", { moduleSpecifier: "./file" }, "import \"./file\";\n\nexport class MyClass {}\n");
        });
    });
    describe("addImportDeclarations", function () {
        function doTest(startCode, structures, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addImportDeclarations(structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should add at the last import if one exists", function () {
            doTest("import \"./file1\";\n\nexport class MyClass {}\n", [{ moduleSpecifier: "./file2" }, { moduleSpecifier: "./file3" }], "import \"./file1\";\nimport \"./file2\";\nimport \"./file3\";\n\nexport class MyClass {}\n");
        });
        it("should add at the start if no imports exists", function () {
            doTest("export class MyClass {}\n", [{ moduleSpecifier: "./file1" }, { moduleSpecifier: "./file2" }], "import \"./file1\";\nimport \"./file2\";\n\nexport class MyClass {}\n");
        });
    });
    describe("getImportDeclarations", function () {
        it("should get the import declarations", function () {
            var sourceFile = testHelpers_1.getInfoFromText("import myImport from 'test'; import {next} from './test';").sourceFile;
            chai_1.expect(sourceFile.getImportDeclarations().length).to.equal(2);
            chai_1.expect(sourceFile.getImportDeclarations()[0]).to.be.instanceOf(compiler_1.ImportDeclaration);
        });
    });
    describe("getImportDeclaration", function () {
        it("should get the import declaration", function () {
            var sourceFile = testHelpers_1.getInfoFromText("import myImport from 'test'; import {next} from './test';").sourceFile;
            chai_1.expect(sourceFile.getImportDeclaration(function (i) { return i.getDefaultImport() != null; }).getText()).to.equal("import myImport from 'test';");
        });
        it("should return undefined when not exists", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(sourceFile.getImportDeclaration(function (e) { return false; })).to.be.undefined;
        });
    });
    describe("getImportDeclarationOrThrow", function () {
        it("should get the import declaration", function () {
            var sourceFile = testHelpers_1.getInfoFromText("import myImport from 'test'; import {next} from './test';").sourceFile;
            chai_1.expect(sourceFile.getImportDeclarationOrThrow(function (i) { return i.getDefaultImport() != null; }).getText()).to.equal("import myImport from 'test';");
        });
        it("should throw when not exists", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(function () { return sourceFile.getImportDeclarationOrThrow(function (e) { return false; }); }).to.throw();
        });
    });
    describe("insertExportDeclarations", function () {
        function doTest(startCode, index, structures, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.insertExportDeclarations(index, structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should insert the different kinds of exports", function () {
            doTest("", 0, [
                { moduleSpecifier: "./test" },
                { namedExports: ["name1", { name: "name" }, { name: "name", alias: "alias" }], moduleSpecifier: "./test" },
                { namedExports: ["name"] },
                {}
            ], [
                "export * from \"./test\";",
                "export {name1, name, name as alias} from \"./test\";",
                "export {name};",
                "export {};"
            ].join("\n") + "\n");
        });
        it("should insert at the beginning", function () {
            doTest("export class Class {}\n", 0, [{ moduleSpecifier: "./test" }], "export * from \"./test\";\n\nexport class Class {}\n");
        });
        it("should insert in the middle", function () {
            doTest("export * from \"./file1\";\nexport * from \"./file3\";\n", 1, [{ moduleSpecifier: "./file2" }], "export * from \"./file1\";\nexport * from \"./file2\";\nexport * from \"./file3\";\n");
        });
        it("should insert at the end", function () {
            doTest("export class Class {}\n", 1, [{ moduleSpecifier: "./test" }], "export class Class {}\n\nexport * from \"./test\";\n");
        });
    });
    describe("insertExportDeclaration", function () {
        function doTest(startCode, index, structure, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.insertExportDeclaration(index, structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ExportDeclaration);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should insert at the specified position", function () {
            doTest("export * from \"./file1\";\nexport * from \"./file3\";\n", 1, { moduleSpecifier: "./file2" }, "export * from \"./file1\";\nexport * from \"./file2\";\nexport * from \"./file3\";\n");
        });
    });
    describe("addExportDeclaration", function () {
        function doTest(startCode, structure, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addExportDeclaration(structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ExportDeclaration);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should always add at the end of the file", function () {
            doTest("export class MyClass {}\n", { moduleSpecifier: "./file" }, "export class MyClass {}\n\nexport * from \"./file\";\n");
        });
    });
    describe("addExportDeclarations", function () {
        function doTest(startCode, structures, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addExportDeclarations(structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should add multiple", function () {
            doTest("export class MyClass {}\n", [{ moduleSpecifier: "./file1" }, { moduleSpecifier: "./file2" }], "export class MyClass {}\n\nexport * from \"./file1\";\nexport * from \"./file2\";\n");
        });
    });
    describe("getExportDeclarations", function () {
        it("should get the export declarations", function () {
            var sourceFile = testHelpers_1.getInfoFromText("export * from 'test'; export {next} from './test';").sourceFile;
            chai_1.expect(sourceFile.getExportDeclarations().length).to.equal(2);
            chai_1.expect(sourceFile.getExportDeclarations()[0]).to.be.instanceOf(compiler_1.ExportDeclaration);
        });
    });
    describe("getExportDeclaration", function () {
        it("should get the export declaration", function () {
            var sourceFile = testHelpers_1.getInfoFromText("export * from 'test'; export {next} from './test';").sourceFile;
            chai_1.expect(sourceFile.getExportDeclaration(function (e) { return e.isNamespaceExport(); }).getText()).to.equal("export * from 'test';");
        });
    });
    describe("getExportDeclarationOrThrow", function () {
        it("should get the export declaration", function () {
            var sourceFile = testHelpers_1.getInfoFromText("export * from 'test'; export {next} from './test';").sourceFile;
            chai_1.expect(sourceFile.getExportDeclarationOrThrow(function (e) { return e.isNamespaceExport(); }).getText()).to.equal("export * from 'test';");
        });
        it("should throw when not exists", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(function () { return sourceFile.getExportDeclarationOrThrow(function (e) { return false; }); }).to.throw();
        });
    });
    describe("getExportedDeclarations", function () {
        it("should get the exported declarations", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var mainSourceFile = project.createSourceFile("main.ts", "export * from \"./class\";\nexport {OtherClass} from \"./otherClass\";\nexport * from \"./barrel\";\n" +
                "export class MainFileClass {}\nexport default MainFileClass;");
            project.createSourceFile("class.ts", "export class Class {} export class MyClass {}");
            project.createSourceFile("otherClass.ts", "export class OtherClass {}\nexport class InnerClass {}");
            project.createSourceFile("barrel.ts", "export * from \"./subBarrel\";");
            project.createSourceFile("subBarrel.ts", "export * from \"./subFile\";\nexport {SubClass2 as Test} from \"./subFile2\";\n" +
                "export {default as SubClass3} from \"./subFile3\"");
            project.createSourceFile("subFile.ts", "export class SubClass {}");
            project.createSourceFile("subFile2.ts", "export class SubClass2 {}");
            project.createSourceFile("subFile3.ts", "class SubClass3 {}\nexport default SubClass3;");
            chai_1.expect(mainSourceFile.getExportedDeclarations().map(function (d) { return d.getName(); }).sort())
                .to.deep.equal(["MainFileClass", "OtherClass", "Class", "MyClass", "SubClass", "SubClass2", "SubClass3"].sort());
        });
        it("should get the exported declaration when there's only a default export using an export assignment", function () {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var mainSourceFile = project.createSourceFile("main.ts", "class MainFileClass {}\nexport default MainFileClass;");
            chai_1.expect(mainSourceFile.getExportedDeclarations().map(function (d) { return d.getName(); }).sort())
                .to.deep.equal(["MainFileClass"].sort());
        });
    });
    describe("insertExportAssignments", function () {
        function doTest(startCode, index, structures, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.insertExportAssignments(index, structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should insert the different kinds of exports", function () {
            doTest("", 0, [
                { expression: "5" },
                { isEqualsExport: true, expression: function (writer) { return writer.write("6"); } },
                { isEqualsExport: false, expression: "name" }
            ], [
                "export = 5;",
                "export = 6;",
                "export default name;"
            ].join("\n") + "\n");
        });
        it("should insert at the beginning", function () {
            doTest("export class Class {}\n", 0, [{ expression: "5" }], "export = 5;\n\nexport class Class {}\n");
        });
        it("should insert in the middle", function () {
            doTest("export * from \"./file1\";\nexport = 6;\n", 1, [{ expression: "5" }], "export * from \"./file1\";\n\nexport = 5;\nexport = 6;\n");
        });
        it("should insert at the end", function () {
            doTest("export class Class {}\n", 1, [{ expression: "5" }], "export class Class {}\n\nexport = 5;\n");
        });
    });
    describe("insertExportAssignment", function () {
        function doTest(startCode, index, structure, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.insertExportAssignment(index, structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ExportAssignment);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should insert at the specified position", function () {
            doTest("export * from \"./file1\";\nexport = 6;\n", 1, { expression: "5" }, "export * from \"./file1\";\n\nexport = 5;\nexport = 6;\n");
        });
    });
    describe("addExportAssignment", function () {
        function doTest(startCode, structure, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addExportAssignment(structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ExportAssignment);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should always add at the end of the file", function () {
            doTest("export class MyClass {}\n", { expression: "5" }, "export class MyClass {}\n\nexport = 5;\n");
        });
    });
    describe("addExportAssignments", function () {
        function doTest(startCode, structures, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addExportAssignments(structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should add multiple", function () {
            doTest("export class MyClass {}\n", [{ expression: "5" }, { expression: "6" }], "export class MyClass {}\n\nexport = 5;\nexport = 6;\n");
        });
    });
    describe("getExportAssignments", function () {
        it("should get the export declarations", function () {
            var sourceFile = testHelpers_1.getInfoFromText("export = 5; export = 6;").sourceFile;
            chai_1.expect(sourceFile.getExportAssignments().length).to.equal(2);
            chai_1.expect(sourceFile.getExportAssignments()[0]).to.be.instanceOf(compiler_1.ExportAssignment);
        });
    });
    describe("getExportAssignment", function () {
        it("should get the export declaration", function () {
            var sourceFile = testHelpers_1.getInfoFromText("export = 5; export default 6;").sourceFile;
            chai_1.expect(sourceFile.getExportAssignment(function (e) { return !e.isExportEquals(); }).getText()).to.equal("export default 6;");
        });
    });
    describe("getExportAssignmentOrThrow", function () {
        it("should get the export declaration", function () {
            var sourceFile = testHelpers_1.getInfoFromText("export = 5; export default 6;").sourceFile;
            chai_1.expect(sourceFile.getExportAssignmentOrThrow(function (e) { return !e.isExportEquals(); }).getText()).to.equal("export default 6;");
        });
        it("should throw when not exists", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(function () { return sourceFile.getExportAssignmentOrThrow(function (e) { return false; }); }).to.throw();
        });
    });
    describe("getDefaultExportSymbol", function () {
        it("should return undefined when there's no default export", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(sourceFile.getDefaultExportSymbol()).to.be.undefined;
        });
        it("should return the default export symbol when one exists", function () {
            var sourceFile = testHelpers_1.getInfoFromText("export default class Identifier {}").sourceFile;
            var defaultExportSymbol = sourceFile.getDefaultExportSymbol();
            chai_1.expect(defaultExportSymbol.getName()).to.equal("default");
        });
        it("should return the default export symbol when default exported on a separate statement", function () {
            var sourceFile = testHelpers_1.getInfoFromText("class Identifier {}\nexport default Identifier;").sourceFile;
            var defaultExportSymbol = sourceFile.getDefaultExportSymbol();
            chai_1.expect(defaultExportSymbol.getName()).to.equal("default");
        });
    });
    describe("getDefaultExportSymbolOrThrow", function () {
        it("should throw when there's no default export", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(function () { return sourceFile.getDefaultExportSymbolOrThrow(); }).to.throw();
        });
        it("should return the default export symbol when one exists", function () {
            var sourceFile = testHelpers_1.getInfoFromText("export default class Identifier {}").sourceFile;
            chai_1.expect(sourceFile.getDefaultExportSymbolOrThrow().getName()).to.equal("default");
        });
    });
    describe("removeDefaultExport", function () {
        it("should do nothing when there's no default export", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            sourceFile.removeDefaultExport();
            chai_1.expect(sourceFile.getFullText()).to.equal("");
        });
        it("should return the default export symbol when one exists", function () {
            var sourceFile = testHelpers_1.getInfoFromText("export default class Identifier {}").sourceFile;
            sourceFile.removeDefaultExport();
            chai_1.expect(sourceFile.getFullText()).to.equal("class Identifier {}");
        });
        it("should return the default export symbol when default exported on a separate statement", function () {
            var sourceFile = testHelpers_1.getInfoFromText("namespace Identifier {}\nclass Identifier {}\nexport default Identifier;\n").sourceFile;
            sourceFile.removeDefaultExport();
            chai_1.expect(sourceFile.getFullText()).to.equal("namespace Identifier {}\nclass Identifier {}\n");
        });
    });
    describe("getLanguageVariant", function () {
        it("should return standard when in a ts file", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(sourceFile.getLanguageVariant()).to.equal(typescript_1.LanguageVariant.Standard);
        });
        it("should return jsx when in a tsx file", function () {
            var sourceFile = testHelpers_1.getInfoFromText("", { filePath: "file.tsx" }).sourceFile;
            chai_1.expect(sourceFile.getLanguageVariant()).to.equal(typescript_1.LanguageVariant.JSX);
        });
    });
    describe("emit", function () {
        it("should emit the source file", function () {
            var fileSystem = testHelpers_2.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project({ compilerOptions: { noLib: true, outDir: "dist" } }, fileSystem);
            var sourceFile = project.createSourceFile("file1.ts", "const num1 = 1;");
            project.createSourceFile("file2.ts", "const num2 = 2;");
            var result = sourceFile.emit();
            chai_1.expect(result).to.be.instanceof(compiler_1.EmitResult);
            var writeLog = fileSystem.getSyncWriteLog();
            chai_1.expect(writeLog[0].filePath).to.equal("/dist/file1.js");
            chai_1.expect(writeLog[0].fileText).to.equal("var num1 = 1;\n");
            chai_1.expect(writeLog.length).to.equal(1);
        });
    });
    describe("getEmitOutput", function () {
        it("should get the emit output for the source file", function () {
            var project = new Project_1.Project({ compilerOptions: { noLib: true, outDir: "dist", target: typescript_1.ScriptTarget.ES5 }, useVirtualFileSystem: true });
            var sourceFile = project.createSourceFile("file1.ts", "const num1 = 1;");
            var result = sourceFile.getEmitOutput();
            chai_1.expect(result.getEmitSkipped()).to.be.false;
            chai_1.expect(result.getOutputFiles().length).to.equal(1);
            var outputFile = result.getOutputFiles()[0];
            chai_1.expect(outputFile.getText()).to.equal("var num1 = 1;\n");
            chai_1.expect(outputFile.getFilePath()).to.equal("/dist/file1.js");
        });
        it("should only emit the declaration file when specified", function () {
            var project = new Project_1.Project({ compilerOptions: { noLib: true, declaration: true, outDir: "dist", target: typescript_1.ScriptTarget.ES5 }, useVirtualFileSystem: true });
            var sourceFile = project.createSourceFile("file1.ts", "const num1 = 1;");
            var result = sourceFile.getEmitOutput({ emitOnlyDtsFiles: true });
            chai_1.expect(result.getEmitSkipped()).to.be.false;
            chai_1.expect(result.getOutputFiles().length).to.equal(1);
            var outputFile = result.getOutputFiles()[0];
            chai_1.expect(outputFile.getFilePath()).to.equal("/dist/file1.d.ts");
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startingCode).sourceFile;
            sourceFile.fill(structure);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("", {}, "");
        });
        it("should modify when changed", function () {
            var structure = {
                imports: [{ moduleSpecifier: "module" }],
                exports: [{ moduleSpecifier: "export-module" }]
            };
            doTest("", structure, "import \"module\";\n\nexport * from \"export-module\";\n");
        });
    });
    describe("formatText", function () {
        function doTest(startingCode, expectedCode, manipulationSettings, settings) {
            if (manipulationSettings === void 0) { manipulationSettings = {}; }
            if (settings === void 0) { settings = {}; }
            var _a = testHelpers_1.getInfoFromText(startingCode), project = _a.project, sourceFile = _a.sourceFile;
            project.manipulationSettings.set(manipulationSettings);
            sourceFile.formatText(settings);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should format the text when it contains different spacing", function () {
            doTest("class     MyClass{}", "class MyClass {}\n");
        });
        it("should not add a newline when specifying not to ensure", function () {
            doTest("class MyClass{}", "class MyClass {}", {}, { ensureNewLineAtEndOfFile: false });
        });
        it("should not by default add spaces immediately within named import braces", function () {
            doTest("import {name, name2} from 'test';", "import {name, name2} from 'test';\n");
        });
        it("should format the text with eight spaces", function () {
            doTest("class MyClass {\n    myMethod() {\n    }\n}", "class MyClass {\n        myMethod() {\n        }\n}\n", { indentationText: ManipulationSettings_1.IndentationText.EightSpaces });
        });
        it("should format the text with four spaces", function () {
            doTest("class MyClass {\n    myMethod() {\n    }\n}", "class MyClass {\n    myMethod() {\n    }\n}\n", { indentationText: ManipulationSettings_1.IndentationText.FourSpaces });
        });
        it("should format the text with two spaces", function () {
            doTest("class MyClass {\n    myMethod() {\n        console.log(t);\n    }\n}", "class MyClass {\n  myMethod() {\n    console.log(t);\n  }\n}\n", { indentationText: ManipulationSettings_1.IndentationText.TwoSpaces });
        });
        it("should format the text with tabs", function () {
            doTest("class MyClass {\n    myMethod() {\n    }\n}", "class MyClass {\n\tmyMethod() {\n\t}\n}\n", { indentationText: ManipulationSettings_1.IndentationText.Tab });
        });
        it("should format the text to spaces when using tabs", function () {
            doTest("class MyClass {\n\tmyMethod() {\n\t}\n}", "class MyClass {\n  myMethod() {\n  }\n}\n", { indentationText: ManipulationSettings_1.IndentationText.TwoSpaces });
        });
        it("should format the text with slash r slash n newlines", function () {
            doTest("class MyClass {\n    myMethod() {\n    }\n}", "class MyClass {\r\n\tmyMethod() {\r\n\t}\r\n}\r\n", { indentationText: ManipulationSettings_1.IndentationText.Tab, newLineKind: typescript_1.NewLineKind.CarriageReturnLineFeed });
        });
        it("should format the text with slash n newlines", function () {
            doTest("class MyClass {\r\n    myMethod() {\r\n    }\r\n}", "class MyClass {\n\tmyMethod() {\n\t}\n}\n", { indentationText: ManipulationSettings_1.IndentationText.Tab, newLineKind: typescript_1.NewLineKind.LineFeed });
        });
        it("should format and not indent within strings", function () {
            doTest("class MyClass {\n    myMethod() {\n        const t = `\nt`;\n    }\n}", "class MyClass {\n  myMethod() {\n    const t = `\nt`;\n  }\n}\n", { indentationText: ManipulationSettings_1.IndentationText.TwoSpaces });
        });
        it("should format and not format within strings", function () {
            doTest("class MyClass {\n    myMethod() {\n        const t = `\n    t`;\n    }\n}", "class MyClass {\n\tmyMethod() {\n\t\tconst t = `\n    t`;\n\t}\n}\n", { indentationText: ManipulationSettings_1.IndentationText.Tab });
        });
        it("should format the text when it contains multiple semi colons", function () {
            doTest("var myTest: string;;;;", "var myTest: string;;;;\n");
        });
        it("should format the text when it contains syntax errors", function () {
            doTest("function myTest(}{{{{}}) {}", "function myTest(}{{{{}}) {}\n");
        });
        it("should format the text in the documentation as described", function () {
            doTest("var myVariable     :      string |    number;\nfunction myFunction(param    : MyClass){\nreturn \"\";\n}\n", "var myVariable: string | number;\nfunction myFunction(param: MyClass) {\n    return \"\";\n}\n");
        });
    });
    describe("indent", function () {
        function doTest(startingCode, rangeOrPos, times, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startingCode).sourceFile;
            sourceFile.indent(rangeOrPos, times);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should throw when the range is outside the lower bound of the file", function () {
            var sourceFile = testHelpers_1.getInfoFromText(" ").sourceFile;
            chai_1.expect(function () { return sourceFile.indent([-1, 0]); }).to.throw();
        });
        it("should throw when the range is outside the upper bound of the file", function () {
            var sourceFile = testHelpers_1.getInfoFromText(" ").sourceFile;
            chai_1.expect(function () { return sourceFile.indent([0, 2]); }).to.throw();
        });
        it("should throw when the range is flipped", function () {
            var sourceFile = testHelpers_1.getInfoFromText("     ").sourceFile;
            chai_1.expect(function () { return sourceFile.indent([2, 1]); }).to.throw();
        });
        it("should indent the specified pos", function () {
            doTest("//testing\n//testing\n//testing", 11, 1, "//testing\n    //testing\n//testing");
        });
        it("should do nothing when specifying a times of 0", function () {
            doTest("//testing\n//testing\n//testing", 11, 0, "//testing\n//testing\n//testing");
        });
        it("should indent the specified text based on the lines provided", function () {
            var sourceFileLines = ["class MyClass {", "    test;", "}"];
            doTest(sourceFileLines.join("\n"), [sourceFileLines[0].length + 1, sourceFileLines[0].length + 1 + sourceFileLines[1].length], 3, "class MyClass {\n                test;\n}");
        });
        it("should indent the line when specifying the end of it for the start of the range", function () {
            var sourceFileLines = ["class MyClass {", "    test;", "}"];
            doTest(sourceFileLines.join("\n"), [sourceFileLines[0].length, sourceFileLines[0].length + 1], 1, "    class MyClass {\n        test;\n}");
        });
        it("should not indent within a multiline string", function () {
            doTest("\"somestring \\\notherstring\";", 17, 1, "\"somestring \\\notherstring\";");
        });
        it("should not indent within a template string", function () {
            doTest("`testingthiso\ntestingmore${here}testing`;", 17, 1, "`testingthiso\ntestingmore${here}testing`;");
        });
        it("should indent when string starts on line", function () {
            doTest("\"somestring\";", 0, 1, "    \"somestring\";");
        });
        it("should indent when only specifying two spaces", function () {
            var sourceFile = testHelpers_1.getInfoFromText("//code").sourceFile;
            sourceFile.global.manipulationSettings.set({ indentationText: ManipulationSettings_1.IndentationText.TwoSpaces });
            sourceFile.indent(0);
            chai_1.expect(sourceFile.getFullText()).to.equal("  //code");
        });
        it("should indent when specifying tabs", function () {
            var sourceFile = testHelpers_1.getInfoFromText("//code").sourceFile;
            sourceFile.global.manipulationSettings.set({ indentationText: ManipulationSettings_1.IndentationText.Tab });
            sourceFile.indent(0);
            chai_1.expect(sourceFile.getFullText()).to.equal("\t//code");
        });
    });
    describe("unindent", function () {
        // most of the tests are in indent
        function doTest(startingCode, rangeOrPos, times, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startingCode).sourceFile;
            sourceFile.unindent(rangeOrPos, times);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should do nothing when already unindented to the end of the line", function () {
            doTest("//testing\n//testing\n//testing", 11, 1, "//testing\n//testing\n//testing");
        });
        it("should unindent when indented", function () {
            doTest("//testing\n    //testing\n//testing", 11, 1, "//testing\n//testing\n//testing");
        });
        it("should unindent when the line doesn't have the unindent number of spaces", function () {
            doTest("//testing\n //testing\n//testing", 11, 1, "//testing\n//testing\n//testing");
            doTest("//testing\n  //testing\n//testing", 11, 1, "//testing\n//testing\n//testing");
            doTest("//testing\n   //testing\n//testing", 11, 1, "//testing\n//testing\n//testing");
        });
        it("should unindent when using tabs", function () {
            doTest("//testing\n\t\t\t//testing\n//testing", 11, 1, "//testing\n\t\t//testing\n//testing");
        });
        it("should unindent when mixing tabs and spaces", function () {
            doTest("//testing\n\t\t    //testing\n//testing", 11, 3, "//testing\n//testing\n//testing");
        });
        it("should unindent multiple times", function () {
            doTest("//testing\n\t\t\t//testing\n//testing", 11, 2, "//testing\n\t//testing\n//testing");
        });
    });
    describe("refreshFromFileSystemSync", function () {
        it("should update the text", function () {
            var filePath = "/File.ts";
            var newText = "let t: string;";
            var host = testHelpers_2.getFileSystemHostWithFiles([]);
            var _a = testHelpers_1.getInfoFromText("class MyClass {}", { filePath: filePath, host: host }), sourceFile = _a.sourceFile, firstChild = _a.firstChild;
            sourceFile.saveSync();
            chai_1.expect(sourceFile.refreshFromFileSystemSync()).to.equal(compiler_1.FileSystemRefreshResult.NoChange);
            host.writeFileSync(filePath, newText);
            chai_1.expect(sourceFile.refreshFromFileSystemSync()).to.equal(compiler_1.FileSystemRefreshResult.Updated);
            chai_1.expect(firstChild.wasForgotten()).to.be.true;
            chai_1.expect(sourceFile.isSaved()).to.be.true;
            chai_1.expect(sourceFile.getFullText()).to.equal(newText);
            host.deleteSync(filePath);
            chai_1.expect(sourceFile.refreshFromFileSystemSync()).to.equal(compiler_1.FileSystemRefreshResult.Deleted);
            chai_1.expect(sourceFile.wasForgotten()).to.be.true;
        });
        it("should throw when the read file throws an error other than file not found", function () {
            var filePath = "/File.ts";
            var host = testHelpers_2.getFileSystemHostWithFiles([]);
            var sourceFile = testHelpers_1.getInfoFromText("class MyClass {}", { filePath: filePath, host: host }).sourceFile;
            sourceFile.saveSync();
            var error = new Error("");
            host.readFileSync = function (path) {
                throw error;
            };
            chai_1.expect(function () { return sourceFile.refreshFromFileSystemSync(); }).to.throw(error);
        });
    });
    describe("refreshFromFileSystem", function () {
        it("should update the text", function () { return __awaiter(_this, void 0, void 0, function () {
            var filePath, newText, host, _a, sourceFile, firstChild, _b, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        filePath = "/File.ts";
                        newText = "let t: string;";
                        host = testHelpers_2.getFileSystemHostWithFiles([]);
                        _a = testHelpers_1.getInfoFromText("class MyClass {}", { filePath: filePath, host: host }), sourceFile = _a.sourceFile, firstChild = _a.firstChild;
                        return [4 /*yield*/, sourceFile.save()];
                    case 1:
                        _e.sent();
                        _b = chai_1.expect;
                        return [4 /*yield*/, sourceFile.refreshFromFileSystem()];
                    case 2:
                        _b.apply(void 0, [_e.sent()]).to.equal(compiler_1.FileSystemRefreshResult.NoChange);
                        return [4 /*yield*/, host.writeFile(filePath, newText)];
                    case 3:
                        _e.sent();
                        _c = chai_1.expect;
                        return [4 /*yield*/, sourceFile.refreshFromFileSystem()];
                    case 4:
                        _c.apply(void 0, [_e.sent()]).to.equal(compiler_1.FileSystemRefreshResult.Updated);
                        chai_1.expect(firstChild.wasForgotten()).to.be.true;
                        chai_1.expect(sourceFile.isSaved()).to.be.true;
                        chai_1.expect(sourceFile.getFullText()).to.equal(newText);
                        return [4 /*yield*/, host.delete(filePath)];
                    case 5:
                        _e.sent();
                        _d = chai_1.expect;
                        return [4 /*yield*/, sourceFile.refreshFromFileSystem()];
                    case 6:
                        _d.apply(void 0, [_e.sent()]).to.equal(compiler_1.FileSystemRefreshResult.Deleted);
                        chai_1.expect(sourceFile.wasForgotten()).to.be.true;
                        return [2 /*return*/];
                }
            });
        }); });
        it("should throw when the read file throws an error other than file not found", function () { return __awaiter(_this, void 0, void 0, function () {
            var filePath, host, sourceFile, error, didThrow, err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        filePath = "/File.ts";
                        host = testHelpers_2.getFileSystemHostWithFiles([]);
                        sourceFile = testHelpers_1.getInfoFromText("class MyClass {}", { filePath: filePath, host: host }).sourceFile;
                        return [4 /*yield*/, sourceFile.save()];
                    case 1:
                        _a.sent();
                        error = new Error("");
                        host.readFile = function (path) { return Promise.reject(error); };
                        didThrow = false;
                        _a.label = 2;
                    case 2:
                        _a.trys.push([2, 4, , 5]);
                        return [4 /*yield*/, sourceFile.refreshFromFileSystem()];
                    case 3:
                        _a.sent();
                        return [3 /*break*/, 5];
                    case 4:
                        err_1 = _a.sent();
                        didThrow = err_1 === error;
                        return [3 /*break*/, 5];
                    case 5:
                        chai_1.expect(didThrow).to.be.true;
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("getRelativePathToSourceFile", function () {
        function doTest(from, to, expected) {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var fromFile = project.createSourceFile(from);
            var toFile = project.createSourceFile(to);
            chai_1.expect(fromFile.getRelativePathToSourceFile(toFile)).to.equal(expected);
        }
        // most of these tests are in fileUtilsTests
        it("should get the relative path to a source file in a different directory", function () {
            doTest("/dir/from.ts", "/dir2/to.ts", "../dir2/to.ts");
        });
    });
    describe("getRelativePathToSourceFileAsModuleSpecifier", function () {
        function doTest(from, to, expected) {
            var project = new Project_1.Project({ useVirtualFileSystem: true });
            var fromFile = project.createSourceFile(from);
            var toFile = from === to ? fromFile : project.createSourceFile(to);
            chai_1.expect(fromFile.getRelativePathToSourceFileAsModuleSpecifier(toFile)).to.equal(expected);
        }
        it("should get the module specifier to a source file in a different directory", function () {
            doTest("/dir/from.ts", "/dir2/to.ts", "../dir2/to");
        });
        it("should get the module specifier to a source file in the same directory", function () {
            doTest("/dir/from.ts", "/dir/to.ts", "./to");
        });
        it("should get the module specifier to the same source file", function () {
            doTest("/dir/file.ts", "/dir/file.ts", "./file");
        });
        it("should get the module specifier to a definition file", function () {
            doTest("/dir/from.ts", "/dir2/to.d.ts", "../dir2/to");
        });
        it("should get the module specifier to a definition file that doing use a lower case extension", function () {
            doTest("/dir/from.ts", "/dir2/to.D.TS", "../dir2/to");
        });
        it("should use an implicit index when specifying the index file in a different directory", function () {
            doTest("/dir/file.ts", "/dir2/index.ts", "../dir2");
        });
        it("should use an implicit index when specifying the index file in a parent directory", function () {
            doTest("/dir/parent/file.ts", "/dir/index.ts", "../../dir");
        });
        it("should use an implicit index when specifying the index file in a different directory that has different casing", function () {
            doTest("/dir/file.ts", "/dir2/INDEX.ts", "../dir2");
        });
        it("should use an implicit index when specifying the index file of a definition file in a different directory", function () {
            doTest("/dir/file.ts", "/dir2/index.d.ts", "../dir2");
        });
        it("should use an implicit index when specifying the index file in the same directory", function () {
            doTest("/dir/file.ts", "/dir/index.ts", "../dir");
        });
    });
    describe("getReferencingNodesInOtherSourceFiles", function () {
        it("should get the imports, exports, import equals, and dynamic imports that reference this source file", function () {
            var fileText = "export interface MyInterface {}\nexport class MyClass {}";
            var _a = testHelpers_1.getInfoFromText(fileText, { filePath: "/MyInterface.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var file1 = project.createSourceFile("/file.ts", "import {MyInterface} from \"./MyInterface\";");
            var file2 = project.createSourceFile("/sub/file2.ts", "import * as interfaces from \"../MyInterface\";\nimport \"./../MyInterface\";");
            var file3 = project.createSourceFile("/sub/file3.ts", "export * from \"../MyInterface\";\n" +
                "import test = require(\"../MyInterface\");\n" +
                "async function t() { const u = await import(\"../MyInterface\"); }");
            var file4 = project.createSourceFile("/file4.ts", "export * from \"./sub/MyInterface\";\nimport \"MyOtherFile\";");
            var referencing = sourceFile.getReferencingNodesInOtherSourceFiles();
            chai_1.expect(referencing.map(function (r) { return r.getText(); }).sort()).to.deep.equal(__spread(__spread(file1.getImportDeclarations(), file2.getImportDeclarations(), file3.getExportDeclarations()).map(function (d) { return d.getText(); }), ["import test = require(\"../MyInterface\");", "import(\"../MyInterface\")"]).sort());
        });
        it("should get the nodes that reference an index file", function () {
            var fileText = "export interface MyInterface {}";
            var _a = testHelpers_1.getInfoFromText(fileText, { filePath: "/sub/index.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var file1 = project.createSourceFile("/file.ts", "export * from \"./sub\";");
            var file2 = project.createSourceFile("/file2.ts", "import \"./sub/index\";");
            var referencing = sourceFile.getReferencingNodesInOtherSourceFiles();
            chai_1.expect(referencing.map(function (r) { return r.getText(); }).sort()).to.deep.equal(__spread(file1.getExportDeclarations(), file2.getImportDeclarations()).map(function (d) { return d.getText(); }).sort());
        });
        it("should keep the references up to date during manipulations", function () {
            var _a = testHelpers_1.getInfoFromText("export class MyClass {}", { filePath: "/MyClass.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var file1 = project.createSourceFile("/file.ts", "import {MyClass} from \"./MyClass\";");
            chai_1.expect(sourceFile.getReferencingNodesInOtherSourceFiles().map(function (r) { return r.getText(); })).to.deep.equal(["import {MyClass} from \"./MyClass\";"]);
            file1.getImportDeclarations()[0].remove();
            chai_1.expect(sourceFile.getReferencingNodesInOtherSourceFiles().map(function (r) { return r.getText(); })).to.deep.equal([]);
            file1.addExportDeclaration({ moduleSpecifier: "./MyClass" });
            chai_1.expect(sourceFile.getReferencingNodesInOtherSourceFiles().map(function (r) { return r.getText(); })).to.deep.equal(["export * from \"./MyClass\";"]);
            file1.delete();
            chai_1.expect(sourceFile.getReferencingNodesInOtherSourceFiles().map(function (r) { return r.getText(); })).to.deep.equal([]);
        });
    });
    describe("getReferencingSourceFiles", function () {
        it("should get the source files that reference this source file", function () {
            var fileText = "export interface MyInterface {}";
            var _a = testHelpers_1.getInfoFromText(fileText, { filePath: "/MyInterface.ts" }), sourceFile = _a.sourceFile, project = _a.project;
            var file1 = project.createSourceFile("/file.ts", "import {MyInterface} from \"./MyInterface\";");
            var file2 = project.createSourceFile("/sub/file2.ts", "import * as interfaces from \"../MyInterface\";\nimport \"./../MyInterface\";");
            var file3 = project.createSourceFile("/sub/file3.ts", "export * from \"../MyInterface\";");
            var file4 = project.createSourceFile("/file4.ts", "export * from \"./sub/MyInterface\";\nimport \"MyOtherFile\";");
            var referencing = sourceFile.getReferencingSourceFiles();
            chai_1.expect(referencing.map(function (r) { return r.getFilePath(); }).sort()).to.deep.equal([file1, file2, file3].map(function (s) { return s.getFilePath(); }).sort());
        });
    });
    describe("getExtension", function () {
        function doTest(filePath, extension) {
            var sourceFile = testHelpers_1.getInfoFromText("", { filePath: filePath }).sourceFile;
            chai_1.expect(sourceFile.getExtension()).to.equal(extension);
        }
        // most of these tests are in FileUtils
        it("should get the source file's extension when a .ts file", function () {
            doTest("/MyInterface.ts", ".ts");
        });
        it("should get the source file's extension when a .js file", function () {
            doTest("/MyInterface.js", ".js");
        });
        it("should get the source file's extension when a .d.ts file", function () {
            doTest("/MyInterface.d.ts", ".d.ts");
        });
    });
    describe("getBaseNameWithoutExtension", function () {
        function doTest(filePath, baseNameWithoutExtension) {
            var sourceFile = testHelpers_1.getInfoFromText("", { filePath: filePath }).sourceFile;
            chai_1.expect(sourceFile.getBaseNameWithoutExtension()).to.equal(baseNameWithoutExtension);
        }
        it("should get the source file's extension when a .ts file", function () {
            doTest("/MyInterface.ts", "MyInterface");
        });
        it("should get the source file's extension when a .js file", function () {
            doTest("/MyInterface.js", "MyInterface");
        });
        it("should get the source file's extension when a .d.ts file", function () {
            doTest("/MyInterface.d.ts", "MyInterface");
        });
    });
});
