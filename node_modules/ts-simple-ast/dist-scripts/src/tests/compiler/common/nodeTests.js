"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var code_block_writer_1 = require("code-block-writer");
var chai_1 = require("chai");
var typescript_1 = require("../../../typescript");
var compiler_1 = require("../../../compiler");
var errors = require("../../../errors");
var utils_1 = require("../../../utils");
var testHelpers_1 = require("../testHelpers");
describe("Node", function () {
    describe("constructor", function () {
        it("should throw if constructing a node outside the library", function () {
            var ctor = compiler_1.Node;
            chai_1.expect(function () { return new ctor(); }).to.throw(errors.InvalidOperationError);
        });
        it("should throw if constructing a node outside the library with other arguments", function () {
            var ctor = compiler_1.Node;
            chai_1.expect(function () { return new ctor(1, 2, 3); }).to.throw(errors.InvalidOperationError);
        });
    });
    describe("compilerNode", function () {
        it("should get the underlying compiler node", function () {
            var sourceFile = testHelpers_1.getInfoFromText("enum MyEnum {}\n").sourceFile;
            // just compare that the texts are the same
            chai_1.expect(sourceFile.getFullText()).to.equal(sourceFile.compilerNode.getFullText());
        });
        it("should throw an error when using a removed node", function () {
            var firstChild = testHelpers_1.getInfoFromText("enum MyEnum { member }\n").firstChild;
            var member = firstChild.getMembers()[0];
            member.remove();
            chai_1.expect(function () { return member.compilerNode; }).to.throw();
        });
    });
    describe("getKind", function () {
        it("should return the syntax kind", function () {
            var firstChild = testHelpers_1.getInfoFromText("enum MyEnum {}").firstChild;
            chai_1.expect(firstChild.getKind()).to.equal(typescript_1.SyntaxKind.EnumDeclaration);
        });
    });
    describe("getKindName", function () {
        it("should return the syntax kind name", function () {
            var firstChild = testHelpers_1.getInfoFromText("enum MyEnum {}").firstChild;
            chai_1.expect(firstChild.getKindName()).to.equal("EnumDeclaration");
        });
    });
    describe("containsRange", function () {
        var firstChild = testHelpers_1.getInfoFromText("enum MyEnum {}").firstChild;
        it("should contain the range when equal to the pos and end", function () {
            chai_1.expect(firstChild.containsRange(firstChild.getPos(), firstChild.getEnd())).to.be.true;
        });
        it("should contain the range when inside", function () {
            chai_1.expect(firstChild.containsRange(firstChild.getPos() + 1, firstChild.getEnd() - 1)).to.be.true;
        });
        it("should not contain the range when the position is outside", function () {
            chai_1.expect(firstChild.containsRange(firstChild.getPos() - 1, firstChild.getEnd())).to.be.false;
        });
        it("should not contain the range when the end is outside", function () {
            chai_1.expect(firstChild.containsRange(firstChild.getPos(), firstChild.getEnd() + 1)).to.be.false;
        });
    });
    describe("isInStringAtPos", function () {
        function doTest(text, isInStringAtPos) {
            chai_1.expect(text.length + 1).to.equal(isInStringAtPos.length);
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            for (var i = 0; i < isInStringAtPos.length; i++) {
                chai_1.expect(sourceFile.isInStringAtPos(i)).to.equal(isInStringAtPos[i], "should be equal at index " + i);
            }
        }
        it("should be within a double quote string when it is", function () {
            doTest("\"t\"", [false, true, false, false]);
        });
        it("should be within a single quote string when it is", function () {
            doTest("'t'", [false, true, false, false]);
        });
        it("should be within a tagged template string when it is", function () {
            doTest("`t${v}" + "t${u}t`", [
                false, true, true, false, false, false,
                true, true, false, false, false, true, false, false
            ]);
        });
        it("should throw when specifying a pos less than 0", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(function () { return sourceFile.isInStringAtPos(-1); }).to.throw();
        });
        it("should throw when specifying a pos greater than the length of the file", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(function () { return sourceFile.isInStringAtPos(1); }).to.throw();
        });
        it("should clear the list of cached nodes after manipulating", function () {
            var sourceFile = testHelpers_1.getInfoFromText("\"t\"").sourceFile;
            chai_1.expect(sourceFile.isInStringAtPos(3)).to.be.false;
            sourceFile.replaceText([1, 1], "new text");
            chai_1.expect(sourceFile.isInStringAtPos(3)).to.be.true;
        });
    });
    describe("offsetPositions", function () {
        var sourceFile = testHelpers_1.getInfoFromText("enum MyEnum {}").sourceFile;
        var allNodes = __spread([sourceFile], sourceFile.getDescendants());
        // easiest to just compare the sum of the positions
        var originalStartPosSum = allNodes.map(function (n) { return n.getPos(); }).reduce(function (a, b) { return a + b; }, 0);
        var originalEndPosSum = allNodes.map(function (n) { return n.getEnd(); }).reduce(function (a, b) { return a + b; }, 0);
        it("should offset all the positions", function () {
            sourceFile.offsetPositions(5);
            var adjustedStartPosSum = allNodes.map(function (n) { return n.getPos() - 5; }).reduce(function (a, b) { return a + b; }, 0);
            var adjustedEndPosSum = allNodes.map(function (n) { return n.getEnd() - 5; }).reduce(function (a, b) { return a + b; }, 0);
            chai_1.expect(adjustedStartPosSum).to.equal(originalStartPosSum);
            chai_1.expect(adjustedEndPosSum).to.equal(originalEndPosSum);
        });
    });
    describe("getFirstChildIfKind", function () {
        var firstChild = testHelpers_1.getInfoFromText("enum MyEnum {}").firstChild;
        it("should return the first node if its the specified syntax kind", function () {
            chai_1.expect(firstChild.getFirstChildIfKind(typescript_1.SyntaxKind.EnumKeyword).getText()).to.equal("enum");
        });
        it("should return undefined when the specified syntax kind isn't the first child", function () {
            chai_1.expect(firstChild.getFirstChildIfKind(typescript_1.SyntaxKind.AbstractKeyword)).to.be.undefined;
        });
    });
    describe("getFirstChildIfKindOrThrow", function () {
        var firstChild = testHelpers_1.getInfoFromText("enum MyEnum {}").firstChild;
        it("should return the first node if its the specified syntax kind", function () {
            chai_1.expect(firstChild.getFirstChildIfKindOrThrow(typescript_1.SyntaxKind.EnumKeyword).getText()).to.equal("enum");
        });
        it("should return undefined when the specified syntax kind isn't the first child", function () {
            chai_1.expect(function () { return firstChild.getFirstChildIfKindOrThrow(typescript_1.SyntaxKind.AbstractKeyword); }).to.throw();
        });
    });
    describe("getFirstChildByKind", function () {
        var firstChild = testHelpers_1.getInfoFromText("enum MyEnum {}").firstChild;
        it("should return the first node of the specified syntax kind", function () {
            chai_1.expect(firstChild.getFirstChildByKind(typescript_1.SyntaxKind.OpenBraceToken).getText()).to.equal("{");
        });
        it("should return undefined when the specified syntax kind doesn't exist", function () {
            chai_1.expect(firstChild.getFirstChildByKind(typescript_1.SyntaxKind.ClassDeclaration)).to.be.undefined;
        });
    });
    describe("getChildAtPos", function () {
        var _a = testHelpers_1.getInfoFromText("function myFunction() { const v = 5; }"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
        var syntaxList = sourceFile.getChildSyntaxList();
        var variableStatement = firstChild.getVariableStatements()[0];
        it("should return undefined when providing a value less than the node pos", function () {
            chai_1.expect(syntaxList.getChildAtPos(sourceFile.getPos() - 1)).to.be.undefined;
        });
        it("should return undefined when providing a value equal to the end", function () {
            chai_1.expect(syntaxList.getChildAtPos(sourceFile.getEnd())).to.be.undefined;
        });
        it("should return the child at the specified position", function () {
            chai_1.expect(syntaxList.getChildAtPos(1).getKind()).to.equal(typescript_1.SyntaxKind.FunctionDeclaration);
        });
        it("should return only a child and not a descendant", function () {
            chai_1.expect(syntaxList.getChildAtPos(variableStatement.getPos()).getKind()).to.equal(typescript_1.SyntaxKind.FunctionDeclaration);
        });
    });
    describe("getChildAtIndex", function () {
        var sourceFile = testHelpers_1.getInfoFromText("class Class { } interface Interface {}").sourceFile;
        var syntaxList = sourceFile.getChildSyntaxListOrThrow();
        it("should throw when specifying a negative index", function () {
            chai_1.expect(function () { return syntaxList.getChildAtIndex(-1); }).to.throw();
        });
        it("should throw when specifying an index too high", function () {
            chai_1.expect(function () { return syntaxList.getChildAtIndex(2); }).to.throw();
        });
        it("should get the first child", function () {
            chai_1.expect(syntaxList.getChildAtIndex(0).getKind()).to.equal(typescript_1.SyntaxKind.ClassDeclaration);
        });
        it("should get the last child", function () {
            chai_1.expect(syntaxList.getChildAtIndex(1).getKind()).to.equal(typescript_1.SyntaxKind.InterfaceDeclaration);
        });
    });
    describe("getChildAtIndexIfKind", function () {
        var sourceFile = testHelpers_1.getInfoFromText("class Class { }").sourceFile;
        var syntaxList = sourceFile.getChildSyntaxListOrThrow();
        it("should get the child at the specified index when the kind", function () {
            chai_1.expect(syntaxList.getChildAtIndexIfKind(0, typescript_1.SyntaxKind.ClassDeclaration).getKind()).to.equal(typescript_1.SyntaxKind.ClassDeclaration);
        });
        it("should be undefined when specifying the wrong kind", function () {
            chai_1.expect(syntaxList.getChildAtIndexIfKind(0, typescript_1.SyntaxKind.InterfaceDeclaration)).to.be.undefined;
        });
    });
    describe("getChildAtIndexIfKindOrThrow", function () {
        var sourceFile = testHelpers_1.getInfoFromText("class Class { }").sourceFile;
        var syntaxList = sourceFile.getChildSyntaxListOrThrow();
        it("should get the child at the specified index when the kind", function () {
            chai_1.expect(syntaxList.getChildAtIndexIfKindOrThrow(0, typescript_1.SyntaxKind.ClassDeclaration).getKind()).to.equal(typescript_1.SyntaxKind.ClassDeclaration);
        });
        it("should be undefined when specifying the wrong kind", function () {
            chai_1.expect(function () { return syntaxList.getChildAtIndexIfKindOrThrow(0, typescript_1.SyntaxKind.InterfaceDeclaration); }).to.throw();
        });
    });
    describe("getDescendantAtPos", function () {
        var _a = testHelpers_1.getInfoFromText("function myFunction() { const v = 5; }"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
        var variableStatement = firstChild.getVariableStatements()[0];
        it("should return undefined when providing a value less than the pos", function () {
            chai_1.expect(sourceFile.getDescendantAtPos(sourceFile.getPos() - 1)).to.be.undefined;
        });
        it("should return undefined when providing a value equal to the end", function () {
            chai_1.expect(sourceFile.getDescendantAtPos(sourceFile.getEnd())).to.be.undefined;
        });
        it("should return the descendant at the specified position", function () {
            chai_1.expect(sourceFile.getDescendantAtPos(1).getKind()).to.equal(typescript_1.SyntaxKind.FunctionKeyword);
        });
        it("should return a very descendant descendant", function () {
            chai_1.expect(sourceFile.getDescendantAtPos(variableStatement.getPos()).getKind()).to.equal(typescript_1.SyntaxKind.ConstKeyword);
        });
        it("should return a the node at the specified pos when specifying a space", function () {
            chai_1.expect(sourceFile.getDescendantAtPos(variableStatement.getPos() - 1).getKind()).to.equal(typescript_1.SyntaxKind.OpenBraceToken);
        });
    });
    describe("getDescendantStatements", function () {
        function doTest(text, expectedStatements) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            chai_1.expect(sourceFile.getDescendantStatements().map(function (s) { return s.getText(); })).to.deep.equal(expectedStatements);
        }
        it("should get the descendant statements", function () {
            var expected = [
                "const a = () => {\n    const b = \"\";\n};",
                "const b = \"\";",
                "const c = 5;",
                "function d() {\n    function e() {\n        const f = \"\";\n    }\n}",
                "function e() {\n        const f = \"\";\n    }",
                "const f = \"\";",
                "class MyClass {\n    prop = () => console.log(\"here\");\n}",
                "console.log(\"here\")"
            ];
            doTest("const a = () => {\n    const b = \"\";\n};\nconst c = 5;\nfunction d() {\n    function e() {\n        const f = \"\";\n    }\n}\nclass MyClass {\n    prop = () => console.log(\"here\");\n}\n", expected);
        });
    });
    describe("getStartLinePos", function () {
        function doTest(text, expectedPos, includeJsDocComment) {
            var firstChild = testHelpers_1.getInfoFromText(text).firstChild;
            chai_1.expect(firstChild.getStartLinePos(includeJsDocComment)).to.equal(expectedPos);
        }
        it("should return the start of the file when it's on the first line", function () {
            doTest("enum MyEnum {\n}\n", 0);
        });
        it("should return the start of the file when it's on the first line", function () {
            doTest("    enum MyEnum {\n}\n", 0);
        });
        it("should return the start of the line when it's not on the first line", function () {
            var firstChild = testHelpers_1.getInfoFromText("enum MyEnum {\n    myMember = 1\n}\n").firstChild;
            var memberDeclaration = firstChild.getMembers()[0];
            chai_1.expect(memberDeclaration.getStartLinePos()).to.equal(14);
        });
        it("should return the start of the line when the past line is a \\r\\n", function () {
            doTest("\n  \t  \r\nenum MyEnum {\n}\n", 8);
        });
        it("should get the start line position of the JS doc when specified", function () {
            doTest("/**\n * Test\n */\nenum MyEnum {\n}\n", 0, true);
        });
        it("should get the start line position of not the JS doc when not specified", function () {
            doTest("/**\n * Test\n */\nenum MyEnum {\n}\n", 16);
        });
    });
    describe("getStartLineNumber", function () {
        it("should get the start line number of the node", function () {
            var firstChild = testHelpers_1.getInfoFromText("\n\nclass MyClass {\n\n    prop: string;\n}").firstChild;
            chai_1.expect(firstChild.getInstanceProperties()[0].getStartLineNumber()).to.equal(5);
        });
    });
    describe("getEndLineNumber", function () {
        it("should get the end line number of the node", function () {
            var firstChild = testHelpers_1.getInfoFromText("\n\nclass MyClass {\n\n    prop: string;\n}").firstChild;
            chai_1.expect(firstChild.getEndLineNumber()).to.equal(6);
        });
    });
    describe("getStart", function () {
        function doTest(text, expectedPos, includeJsDocComment) {
            var firstChild = testHelpers_1.getInfoFromText(text).firstChild;
            chai_1.expect(firstChild.getStart(includeJsDocComment)).to.equal(expectedPos);
        }
        it("should return the pos without trivia", function () {
            doTest("\n  \t  /* comment */ //comment  \r\n  \t enum MyEnum {\n}\n", 37);
        });
        it("should return the pos at the start of the js doc comment if specified", function () {
            doTest("/**\n * Test\n */\nenum MyEnum {\n}\n", 0, true);
        });
    });
    describe("getCombinedModifierFlags", function () {
        var firstChild = testHelpers_1.getInfoFromText("export class Identifier {}").firstChild;
        it("should get the combined modifier flags", function () {
            chai_1.expect(firstChild.getCombinedModifierFlags()).to.equal(typescript_1.ts.ModifierFlags.Export);
        });
    });
    describe("getParentIfKind", function () {
        var firstChild = testHelpers_1.getInfoFromText("export class Identifier { prop: string; }").firstChild;
        var child = firstChild.getInstanceProperty("prop");
        it("should get the parent when it's the right kind", function () {
            chai_1.expect(child.getParentIfKind(typescript_1.SyntaxKind.ClassDeclaration)).to.not.be.undefined;
        });
        it("should not get the parent when it's not the right kind", function () {
            chai_1.expect(child.getParentIfKind(typescript_1.SyntaxKind.InterfaceDeclaration)).to.be.undefined;
        });
    });
    describe("getParentIfKindOrThrow", function () {
        var firstChild = testHelpers_1.getInfoFromText("export class Identifier { prop: string; }").firstChild;
        var child = firstChild.getInstanceProperty("prop");
        it("should get the parent when it's the right kind", function () {
            chai_1.expect(child.getParentIfKindOrThrow(typescript_1.SyntaxKind.ClassDeclaration)).to.not.be.undefined;
        });
        it("should throw when it's not the right kind", function () {
            chai_1.expect(function () { return child.getParentIfKindOrThrow(typescript_1.SyntaxKind.InterfaceDeclaration); }).to.throw();
        });
    });
    describe("getParentWhile", function () {
        it("should keep getting the parent until a condition is no longer matched", function () {
            var sourceFile = testHelpers_1.getInfoFromText("const t = Test.Test2.Test3.Test4;").sourceFile;
            var deepestNode = sourceFile.getFirstDescendantOrThrow(function (n) { return n.getText() === "Test"; });
            var topParent = deepestNode.getParentWhile(function (n) { return n.getKind() === typescript_1.SyntaxKind.PropertyAccessExpression; });
            chai_1.expect(topParent.getText()).to.equal("Test.Test2.Test3.Test4");
        });
        it("should return undefined when the initial parent doesn't match the condition", function () {
            var sourceFile = testHelpers_1.getInfoFromText("const t;").sourceFile;
            var child = sourceFile.getVariableStatements()[0];
            chai_1.expect(child.getParentWhile(function () { return false; })).to.be.undefined;
        });
    });
    describe("getParentWhileOrThrow", function () {
        it("should keep getting the parent until a condition is no longer matched", function () {
            var sourceFile = testHelpers_1.getInfoFromText("const t = Test.Test2.Test3.Test4;").sourceFile;
            var deepestNode = sourceFile.getFirstDescendantOrThrow(function (n) { return n.getText() === "Test"; });
            var topParent = deepestNode.getParentWhileOrThrow(function (n) { return n.getKind() === typescript_1.SyntaxKind.PropertyAccessExpression; });
            chai_1.expect(topParent.getText()).to.equal("Test.Test2.Test3.Test4");
        });
        it("should return undefined when the initial parent doesn't match the condition", function () {
            var sourceFile = testHelpers_1.getInfoFromText("const t;").sourceFile;
            var child = sourceFile.getVariableStatements()[0];
            chai_1.expect(function () { return child.getParentWhileOrThrow(function () { return false; }); }).to.throw();
        });
    });
    describe("getParentWhileKind", function () {
        it("should keep getting the parent until a condition is no longer matched", function () {
            var sourceFile = testHelpers_1.getInfoFromText("const t = Test.Test2.Test3.Test4;").sourceFile;
            var deepestNode = sourceFile.getFirstDescendantOrThrow(function (n) { return n.getText() === "Test"; });
            var topParent = deepestNode.getParentWhileKind(typescript_1.SyntaxKind.PropertyAccessExpression);
            chai_1.expect(topParent.getText()).to.equal("Test.Test2.Test3.Test4");
        });
        it("should return undefined when the initial parent doesn't match the condition", function () {
            var sourceFile = testHelpers_1.getInfoFromText("const t;").sourceFile;
            var child = sourceFile.getVariableStatements()[0];
            chai_1.expect(child.getParentWhileKind(typescript_1.SyntaxKind.PrivateKeyword)).to.be.undefined;
        });
    });
    describe("getParentWhileKindOrThrow", function () {
        it("should keep getting the parent until a condition is no longer matched", function () {
            var sourceFile = testHelpers_1.getInfoFromText("const t = Test.Test2.Test3.Test4;").sourceFile;
            var deepestNode = sourceFile.getFirstDescendantOrThrow(function (n) { return n.getText() === "Test"; });
            var topParent = deepestNode.getParentWhileKindOrThrow(typescript_1.SyntaxKind.PropertyAccessExpression);
            chai_1.expect(topParent.getText()).to.equal("Test.Test2.Test3.Test4");
        });
        it("should return undefined when the initial parent doesn't match the condition", function () {
            var sourceFile = testHelpers_1.getInfoFromText("const t;").sourceFile;
            var child = sourceFile.getVariableStatements()[0];
            chai_1.expect(function () { return child.getParentWhileKindOrThrow(typescript_1.SyntaxKind.PrivateKeyword); }).to.throw();
        });
    });
    describe("getFirstChildOrThrow", function () {
        var _a = testHelpers_1.getInfoFromText("class Identifier { prop: string; }\ninterface MyInterface {}"), sourceFile = _a.sourceFile, firstChild = _a.firstChild;
        var syntaxList = sourceFile.getChildSyntaxListOrThrow();
        it("should get the first child by a condition", function () {
            chai_1.expect(syntaxList.getFirstChildOrThrow(function (n) { return n.getKind() === typescript_1.SyntaxKind.InterfaceDeclaration; })).to.be.instanceOf(compiler_1.InterfaceDeclaration);
        });
        it("should throw when it can't find the child", function () {
            chai_1.expect(function () { return syntaxList.getFirstChildOrThrow(function (n) { return n.getKind() === typescript_1.SyntaxKind.IsKeyword; }); }).to.throw();
        });
    });
    describe("getLastChildOrThrow", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Identifier { prop: string; }\ninterface MyInterface {}").sourceFile;
        var syntaxList = sourceFile.getChildSyntaxListOrThrow();
        it("should get the last child by a condition", function () {
            var interfaceDec = syntaxList.getLastChildOrThrow(function (n) { return n.getKind() === typescript_1.SyntaxKind.InterfaceDeclaration; });
            chai_1.expect(interfaceDec.getName()).to.equal("MyInterface");
        });
        it("should throw when it can't find the child", function () {
            chai_1.expect(function () { return syntaxList.getLastChildOrThrow(function (n) { return n.getKind() === typescript_1.SyntaxKind.IsKeyword; }); }).to.throw();
        });
    });
    describe("getFirstDescendant", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Identifier { prop: string; }\ninterface MyInterface { nextProp: string; }").sourceFile;
        it("should get the first descendant by a condition", function () {
            var prop = sourceFile.getFirstDescendant(function (n) { return n.getKind() === typescript_1.SyntaxKind.PropertySignature; });
            chai_1.expect(prop).to.be.instanceOf(compiler_1.PropertySignature);
            chai_1.expect(prop.getName()).to.equal("prop");
        });
        it("should return undefined when it can't find it", function () {
            var privateKeyword = sourceFile.getFirstDescendant(function (n) { return n.getKind() === typescript_1.SyntaxKind.PrivateKeyword; });
            chai_1.expect(privateKeyword).to.be.undefined;
        });
    });
    describe("getFirstDescendantOrThrow", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Identifier { prop: string; }\ninterface MyInterface { nextProp: string; }").sourceFile;
        it("should get the first descendant by a condition", function () {
            var prop = sourceFile.getFirstDescendantOrThrow(function (n) { return n.getKind() === typescript_1.SyntaxKind.PropertySignature; });
            chai_1.expect(prop).to.be.instanceOf(compiler_1.PropertySignature);
            chai_1.expect(prop.getName()).to.equal("prop");
        });
        it("should return undefined when it can't find it", function () {
            chai_1.expect(function () { return sourceFile.getFirstDescendantOrThrow(function (n) { return n.getKind() === typescript_1.SyntaxKind.PrivateKeyword; }); }).to.throw();
        });
    });
    describe("getDescendantsOfKind", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Identifier { prop: string; }\ninterface MyInterface { nextProp: string; }").sourceFile;
        it("should get the descendant by a kind", function () {
            var properties = sourceFile.getDescendantsOfKind(typescript_1.SyntaxKind.PropertySignature);
            chai_1.expect(properties.length).to.equal(2);
            chai_1.expect(properties[0]).to.be.instanceOf(compiler_1.PropertySignature);
            chai_1.expect(properties[1]).to.be.instanceOf(compiler_1.PropertySignature);
        });
    });
    describe("getFirstDescendantByKind", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Identifier { prop: string; }\ninterface MyInterface { nextProp: string; }").sourceFile;
        it("should get the first descendant by a condition", function () {
            var prop = sourceFile.getFirstDescendantByKind(typescript_1.SyntaxKind.PropertySignature);
            chai_1.expect(prop).to.be.instanceOf(compiler_1.PropertySignature);
            chai_1.expect(prop.getName()).to.equal("prop");
        });
        it("should return undefined when it can't find it", function () {
            var privateKeyword = sourceFile.getFirstDescendantByKind(typescript_1.SyntaxKind.PrivateKeyword);
            chai_1.expect(privateKeyword).to.be.undefined;
        });
    });
    describe("getFirstDescendantByKindOrThrow", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Identifier { prop: string; }\ninterface MyInterface { nextProp: string; }").sourceFile;
        it("should get the first descendant by a condition", function () {
            var prop = sourceFile.getFirstDescendantByKindOrThrow(typescript_1.SyntaxKind.PropertySignature);
            chai_1.expect(prop).to.be.instanceOf(compiler_1.PropertySignature);
            chai_1.expect(prop.getName()).to.equal("prop");
        });
        it("should return undefined when it can't find it", function () {
            chai_1.expect(function () { return sourceFile.getFirstDescendantByKindOrThrow(typescript_1.SyntaxKind.PrivateKeyword); }).to.throw();
        });
    });
    describe("getPreviousSibling", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Interface1 {}\ninterface Interface2 {}\ninterface Interface3 {}").sourceFile;
        it("should get the previous sibling based on a condition", function () {
            chai_1.expect(sourceFile.getInterfaces()[2].getPreviousSibling(function (s) { return utils_1.TypeGuards.isInterfaceDeclaration(s) && s.getName() === "Interface1"; }).getText())
                .to.equal("interface Interface1 {}");
        });
        it("should get the previous sibling when not supplying a condition", function () {
            chai_1.expect(sourceFile.getInterfaces()[2].getPreviousSibling().getText()).to.equal("interface Interface2 {}");
        });
        it("should return undefined when it can't find the sibling based on a condition", function () {
            chai_1.expect(sourceFile.getInterfaces()[2].getPreviousSibling(function (s) { return false; })).to.be.undefined;
        });
        it("should return undefined when there isn't a previous sibling", function () {
            chai_1.expect(sourceFile.getInterfaces()[0].getPreviousSibling()).to.be.undefined;
        });
    });
    describe("getPreviousSiblingOrThrow", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Interface1 {}\ninterface Interface2 {}\ninterface Interface3 {}").sourceFile;
        it("should get the previous sibling based on a condition", function () {
            chai_1.expect(sourceFile.getInterfaces()[2].getPreviousSiblingOrThrow(function (s) { return utils_1.TypeGuards.isInterfaceDeclaration(s) && s.getName() === "Interface1"; }).getText())
                .to.equal("interface Interface1 {}");
        });
        it("should get the previous sibling when not supplying a condition", function () {
            chai_1.expect(sourceFile.getInterfaces()[2].getPreviousSiblingOrThrow().getText()).to.equal("interface Interface2 {}");
        });
        it("should throw when it can't find the sibling based on a condition", function () {
            chai_1.expect(function () { return sourceFile.getInterfaces()[2].getPreviousSiblingOrThrow(function (s) { return false; }); }).to.throw();
        });
        it("should throw when there isn't a previous sibling", function () {
            chai_1.expect(function () { return sourceFile.getInterfaces()[0].getPreviousSiblingOrThrow(); }).to.throw();
        });
    });
    describe("getNextSibling", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Interface1 {}\ninterface Interface2 {}\ninterface Interface3 {}").sourceFile;
        it("should get the next sibling based on a condition", function () {
            chai_1.expect(sourceFile.getInterfaces()[0].getNextSibling(function (s) { return utils_1.TypeGuards.isInterfaceDeclaration(s) && s.getName() === "Interface3"; }).getText())
                .to.equal("interface Interface3 {}");
        });
        it("should get the next sibling when not supplying a condition", function () {
            chai_1.expect(sourceFile.getInterfaces()[0].getNextSibling().getText()).to.equal("interface Interface2 {}");
        });
        it("should return undefined when it can't find the sibling based on a condition", function () {
            chai_1.expect(sourceFile.getInterfaces()[0].getNextSibling(function (s) { return false; })).to.be.undefined;
        });
        it("should return undefined when there isn't a next sibling", function () {
            chai_1.expect(sourceFile.getInterfaces()[2].getNextSibling()).to.be.undefined;
        });
    });
    describe("getNextSiblingOrThrow", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Interface1 {}\ninterface Interface2 {}\ninterface Interface3 {}").sourceFile;
        it("should get the next sibling based on a condition", function () {
            chai_1.expect(sourceFile.getInterfaces()[0].getNextSiblingOrThrow(function (s) { return utils_1.TypeGuards.isInterfaceDeclaration(s) && s.getName() === "Interface3"; }).getText())
                .to.equal("interface Interface3 {}");
        });
        it("should get the next sibling when not supplying a condition", function () {
            chai_1.expect(sourceFile.getInterfaces()[0].getNextSiblingOrThrow().getText()).to.equal("interface Interface2 {}");
        });
        it("should throw when it can't find the sibling based on a condition", function () {
            chai_1.expect(function () { return sourceFile.getInterfaces()[0].getNextSiblingOrThrow(function (s) { return false; }); }).to.throw();
        });
        it("should throw when there isn't a next sibling", function () {
            chai_1.expect(function () { return sourceFile.getInterfaces()[2].getNextSiblingOrThrow(); }).to.throw();
        });
    });
    describe("getPreviousSiblings", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Interface1 {}\ninterface Interface2 {}\ninterface Interface3 {}").sourceFile;
        it("should get the previous siblings going away in order", function () {
            chai_1.expect(sourceFile.getInterfaces()[2].getPreviousSiblings().map(function (s) { return s.getName(); }))
                .to.deep.equal(["Interface2", "Interface1"]);
        });
    });
    describe("getNextSiblings", function () {
        var sourceFile = testHelpers_1.getInfoFromText("interface Interface1 {}\ninterface Interface2 {}\ninterface Interface3 {}").sourceFile;
        it("should get the previous siblings going away in order", function () {
            chai_1.expect(sourceFile.getInterfaces()[0].getNextSiblings().map(function (s) { return s.getName(); }))
                .to.deep.equal(["Interface2", "Interface3"]);
        });
    });
    describe("isFirstNodeOnLine", function () {
        function doTest(text, index, expected) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            chai_1.expect(sourceFile.getFirstChildIfKindOrThrow(typescript_1.SyntaxKind.SyntaxList).getChildren()[index].isFirstNodeOnLine()).to.equal(expected);
        }
        it("should be true if it is and it's on the first line", function () {
            doTest("    interface MyTest {}", 0, true);
        });
        it("should be true if it is and on a line within the file", function () {
            doTest("interface MyTest {}\n    \tclass Test {}", 1, true);
        });
        it("should be false if there's something else and it's the first line", function () {
            doTest("    interface MyTest {} class Test {}", 1, false);
        });
        it("should be false if there's something else and it's on a line within the file", function () {
            doTest("\n\ninterface MyTest {\n} class Test {}", 1, false);
        });
    });
    describe("replaceWithText", function () {
        function doTest(startText, replaceText, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startText).sourceFile;
            var varDeclaration = sourceFile.getVariableDeclarations()[0];
            var propAccess = varDeclaration.getInitializerOrThrow();
            var newNode;
            if (typeof replaceText === "string")
                newNode = propAccess.replaceWithText(replaceText);
            else
                newNode = propAccess.replaceWithText(replaceText);
            chai_1.expect(newNode.getText()).to.equal(getReplaceTextAsString());
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(function () { return propAccess.compilerNode; }).to.throw(); // should be forgotten
            function getReplaceTextAsString() {
                if (typeof replaceText === "string")
                    return replaceText;
                var writer = new code_block_writer_1.default();
                replaceText(writer);
                return writer.toString();
            }
        }
        it("should replace when using a string", function () {
            doTest("var t = Some.Prop.Access.Expression;", "NewText", "var t = NewText;");
        });
        it("should replace when using a writer", function () {
            doTest("var t = Some.Prop.Access.Expression;", function (writer) { return writer.write("NewText"); }, "var t = NewText;");
        });
        it("should replace the text for a source file", function () {
            var sourceFile = testHelpers_1.getInfoFromText("var t = Some.Prop.Access;").sourceFile;
            var result = sourceFile.replaceWithText("var t;");
            chai_1.expect(sourceFile.getFullText()).to.equal("var t;"); // in this case, it will not forget the source file
            chai_1.expect(result).to.equal(sourceFile);
        });
        it("should replace the jsdoc text", function () {
            var _a = testHelpers_1.getInfoFromText("/**\n * Testing\n */\nclass MyClass {}"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.replaceWithText("var t;");
            chai_1.expect(sourceFile.getFullText()).to.equal("var t;");
            chai_1.expect(result).to.equal(sourceFile.getStatements()[0]);
        });
        it("should throw when replacing with more than one node", function () {
            var sourceFile = testHelpers_1.getInfoFromText("var t = Some.Prop.Access;").sourceFile;
            var varDeclaration = sourceFile.getVariableDeclarations()[0];
            var propAccess = varDeclaration.getInitializerOrThrow();
            chai_1.expect(function () {
                propAccess.replaceWithText("SomeTest; Test");
            }).to.throw();
        });
    });
    describe("print", function () {
        var nodeText = "class MyClass {\n    // comment\n    prop: string;\n}";
        var _a = testHelpers_1.getInfoFromText(nodeText), sourceFile = _a.sourceFile, firstChild = _a.firstChild;
        it("should print the source file", function () {
            chai_1.expect(sourceFile.print()).to.equal(nodeText + "\n");
        });
        it("should print the node", function () {
            chai_1.expect(firstChild.print()).to.equal(nodeText);
        });
        it("should print the node with different newlines", function () {
            chai_1.expect(firstChild.print({ newLineKind: typescript_1.NewLineKind.CarriageReturnLineFeed })).to.equal(nodeText.replace(/\n/g, "\r\n"));
        });
    });
    describe("formatText", function () {
        function doTest(text, getNode, expectedText, settings) {
            if (settings === void 0) { settings = {}; }
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            getNode(sourceFile).formatText(settings);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
        }
        it("should format only the provided node", function () {
            doTest("class Test{\n   prop:string;\n  }\nclass Test2{\n   prop:string;\n  }\n", function (f) { return f.getClassOrThrow("Test2"); }, "class Test{\n   prop:string;\n  }\nclass Test2 {\n    prop: string;\n}\n");
        });
        it("should format only the provided node with the specified settings", function () {
            doTest("class Test{\n\tprop:string;\n}\n       /** Testing */\nclass Test2{\n\t prop:string;\n\t}\n", function (f) { return f.getClassOrThrow("Test2"); }, "class Test{\n\tprop:string;\n}\n/** Testing */\nclass Test2 {\n  prop: string;\n}\n", {
                convertTabsToSpaces: true,
                indentSize: 2
            });
        });
    });
});
