"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var typescript_1 = require("../../../typescript");
var testHelpers_1 = require("../testHelpers");
describe("Identifier", function () {
    describe("rename", function () {
        it("should rename", function () {
            var text = "function myFunction() {} const reference = myFunction;";
            var _a = testHelpers_1.getInfoFromText(text), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.getNameNode().rename("newFunction");
            chai_1.expect(sourceFile.getFullText()).to.equal(text.replace(/myFunction/g, "newFunction"));
        });
    });
    describe("getDefinitions", function () {
        it("should get the definition", function () {
            var sourceFileText = "function myFunction() {}\nconst reference = myFunction;";
            var _a = testHelpers_1.getInfoFromText(sourceFileText), firstChild = _a.firstChild, sourceFile = _a.sourceFile, project = _a.project;
            var secondSourceFile = project.createSourceFile("second.ts", "const reference2 = myFunction;");
            var definitions = secondSourceFile.getVariableDeclarationOrThrow("reference2").getInitializerOrThrow().getDefinitions();
            chai_1.expect(definitions.length).to.equal(1);
            chai_1.expect(definitions[0].getName()).to.equal("myFunction");
            chai_1.expect(definitions[0].getSourceFile().getFullText()).to.equal(sourceFileText);
            chai_1.expect(definitions[0].getKind()).to.equal(typescript_1.ts.ScriptElementKind.functionElement);
            chai_1.expect(definitions[0].getTextSpan().getStart()).to.equal(firstChild.getNameNode().getStart());
            chai_1.expect(definitions[0].getNode()).to.equal(firstChild);
        });
        it("should get the definition when nested inside a namespace", function () {
            var _a = testHelpers_1.getInfoFromText("namespace N { export function myFunction() {} }\nconst reference = N.myFunction;"), firstChild = _a.firstChild, sourceFile = _a.sourceFile, project = _a.project;
            var definitions = sourceFile.getVariableDeclarationOrThrow("reference").getInitializerOrThrow().getNameNode().getDefinitions();
            chai_1.expect(definitions.length).to.equal(1);
            chai_1.expect(definitions[0].getNode()).to.equal(firstChild.getFunctions()[0]);
        });
    });
    describe("getImplementations", function () {
        it("should get the implementations", function () {
            var sourceFileText = "interface MyInterface {}\nexport class Class1 implements MyInterface {}\nclass Class2 implements MyInterface {}";
            var _a = testHelpers_1.getInfoFromText(sourceFileText), firstChild = _a.firstChild, sourceFile = _a.sourceFile, project = _a.project;
            var implementations = firstChild.getNameNode().getImplementations();
            chai_1.expect(implementations.length).to.equal(2);
            chai_1.expect(implementations[0].getNode().getName()).to.equal("Class1");
            chai_1.expect(implementations[1].getNode().getName()).to.equal("Class2");
        });
    });
    describe("findReferences", function () {
        it("should find all the references", function () {
            var _a = testHelpers_1.getInfoFromText("function myFunction() {}\nconst reference = myFunction;"), firstChild = _a.firstChild, sourceFile = _a.sourceFile, project = _a.project;
            var secondSourceFile = project.createSourceFile("second.ts", "const reference2 = myFunction;");
            var referencedSymbols = firstChild.getNameNode().findReferences();
            chai_1.expect(referencedSymbols.length).to.equal(1);
            var referencedSymbol = referencedSymbols[0];
            var references = referencedSymbol.getReferences();
            // definition
            var definition = referencedSymbol.getDefinition();
            chai_1.expect(definition.getSourceFile()).to.equal(sourceFile);
            chai_1.expect(definition.getContainerName()).to.equal("");
            chai_1.expect(definition.getContainerKind()).to.equal("");
            chai_1.expect(definition.getKind()).to.equal("function");
            chai_1.expect(definition.getName()).to.equal("function myFunction(): void");
            chai_1.expect(definition.getTextSpan().getStart()).to.equal(9);
            chai_1.expect(definition.getTextSpan().getLength()).to.equal("myFunction".length);
            chai_1.expect(definition.getDisplayParts()[0].getText()).to.equal("function"); // only bother testing the first one
            chai_1.expect(definition.getDisplayParts()[0].getKind()).to.equal("keyword");
            // first reference
            chai_1.expect(references[0].getSourceFile()).to.equal(sourceFile);
            chai_1.expect(references[0].getTextSpan().getStart()).to.equal(9);
            chai_1.expect(references[0].getTextSpan().getLength()).to.equal("myFunction".length);
            chai_1.expect(references[0].isDefinition()).to.equal(true);
            chai_1.expect(references[0].isInString()).to.equal(undefined);
            chai_1.expect(references[0].isWriteAccess()).to.equal(true);
            chai_1.expect(references[0].getNode().getParentOrThrow().getKind()).to.equal(typescript_1.SyntaxKind.FunctionDeclaration);
            // second reference
            chai_1.expect(references[1].getSourceFile()).to.equal(sourceFile);
            chai_1.expect(references[1].getTextSpan().getStart()).to.equal(43);
            chai_1.expect(references[1].getTextSpan().getLength()).to.equal("myFunction".length);
            chai_1.expect(references[1].isDefinition()).to.equal(false);
            chai_1.expect(references[1].isInString()).to.equal(undefined);
            chai_1.expect(references[1].isWriteAccess()).to.equal(false);
            chai_1.expect(references[1].getNode().getParentOrThrow().getKind()).to.equal(typescript_1.SyntaxKind.VariableDeclaration);
            // third reference
            chai_1.expect(references[2].getSourceFile()).to.equal(secondSourceFile);
            chai_1.expect(references[2].getTextSpan().getStart()).to.equal(19);
            chai_1.expect(references[2].getTextSpan().getLength()).to.equal("myFunction".length);
            chai_1.expect(references[2].isDefinition()).to.equal(false);
            chai_1.expect(references[2].isInString()).to.equal(undefined);
            chai_1.expect(references[2].isWriteAccess()).to.equal(false);
            chai_1.expect(references[2].getNode().getParentOrThrow().getKind()).to.equal(typescript_1.SyntaxKind.VariableDeclaration);
        });
        it("should get the right node when the reference is at the start of a property access expression", function () {
            var _a = testHelpers_1.getInfoFromText("\nnamespace MyNamespace {\n    export class MyClass {\n    }\n}\n\nconst t = MyNamespace.MyClass;\n"), firstChild = _a.firstChild, sourceFile = _a.sourceFile, project = _a.project;
            var referencedSymbols = firstChild.getNameNode().findReferences();
            chai_1.expect(referencedSymbols.length).to.equal(1);
            var referencedSymbol = referencedSymbols[0];
            var references = referencedSymbol.getReferences();
            var propAccessExpr = sourceFile.getVariableDeclarations()[0].getInitializerOrThrow();
            chai_1.expect(references[1].getNode()).to.equal(propAccessExpr.getExpression());
        });
    });
    describe("getType", function () {
        function doTest(text, expectedTypes) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            var identifiers = sourceFile.getDescendantsOfKind(typescript_1.SyntaxKind.Identifier);
            chai_1.expect(identifiers.map(function (i) { return i.getType().getText(); })).to.deep.equal(expectedTypes);
        }
        it("should get the identifier", function () {
            doTest("class Identifier {}\n var t = Identifier;", ["Identifier", "typeof Identifier", "typeof Identifier"]);
        });
    });
});
