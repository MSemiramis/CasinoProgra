"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var compiler_1 = require("../../../../compiler");
var testHelpers_1 = require("../../testHelpers");
describe("StatementedNode", function () {
    describe("insertTypeAliases", function () {
        function doTest(startCode, index, structures, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.insertTypeAliases(index, structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert to an empty file", function () {
            doTest("", 0, [{
                    name: "Identifier",
                    type: "string"
                }], "type Identifier = string;\n");
        });
        it("should insert at the start with two new lines for a non-type alias after", function () {
            doTest("namespace Identifier2 {\n}\n", 0, [{ name: "Identifier1", type: "string" }], "type Identifier1 = string;\n\nnamespace Identifier2 {\n}\n");
        });
        it("should insert at the start with one new lines for a type alias after", function () {
            doTest("type Identifier2 = string;\n", 0, [{ name: "Identifier1", type: "string" }], "type Identifier1 = string;\ntype Identifier2 = string;\n");
        });
        it("should insert at the end of a file with two new lines for a non-type alias before", function () {
            doTest("namespace Identifier1 {\n}\n", 1, [{ name: "Identifier2", type: "string" }], "namespace Identifier1 {\n}\n\ntype Identifier2 = string;\n");
        });
        it("should insert in the middle of children", function () {
            doTest("namespace Identifier1 {\n}\n\nnamespace Identifier3 {\n}\n", 1, [{ name: "Identifier2", type: "string" }], "namespace Identifier1 {\n}\n\ntype Identifier2 = string;\n\nnamespace Identifier3 {\n}\n");
        });
        it("should insert multiple", function () {
            doTest("namespace Identifier1 {\n}\n", 1, [{ name: "Identifier2", type: "number" }, { name: "Identifier3", type: "string" }], "namespace Identifier1 {\n}\n\ntype Identifier2 = number;\ntype Identifier3 = string;\n");
        });
        it("should have the expected text adding to non-source file", function () {
            var sourceFile = testHelpers_1.getInfoFromText("namespace Identifier {\n}\n").sourceFile;
            var namespaceDec = sourceFile.getNamespaces()[0];
            namespaceDec.insertTypeAliases(0, [{
                    name: "Identifier",
                    type: "string"
                }]);
            chai_1.expect(sourceFile.getFullText()).to.equal("namespace Identifier {\n    type Identifier = string;\n}\n");
        });
    });
    describe("insertTypeAlias", function () {
        function doTest(startCode, index, structure, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.insertTypeAlias(index, structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.TypeAliasDeclaration);
        }
        it("should insert", function () {
            doTest("namespace Identifier2 {\n}\n", 0, { name: "Identifier1", type: "string" }, "type Identifier1 = string;\n\nnamespace Identifier2 {\n}\n");
        });
    });
    describe("addTypeAliases", function () {
        function doTest(startCode, structures, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addTypeAliases(structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add multiple", function () {
            doTest("namespace Identifier1 {\n}\n", [{ name: "Identifier2", type: "string" }, { name: "Identifier3", type: "number" }], "namespace Identifier1 {\n}\n\ntype Identifier2 = string;\ntype Identifier3 = number;\n");
        });
    });
    describe("addTypeAlias", function () {
        function doTest(startCode, structure, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addTypeAlias(structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.TypeAliasDeclaration);
        }
        it("should add one", function () {
            doTest("namespace Identifier1 {\n}\n", { name: "Identifier2", type: "string" }, "namespace Identifier1 {\n}\n\ntype Identifier2 = string;\n");
        });
    });
    describe("getTypeAliases", function () {
        var sourceFile = testHelpers_1.getInfoFromText("type Identifier1 = string;\ntype Identifier2 = number;").sourceFile;
        var typeAliases = sourceFile.getTypeAliases();
        it("should have the expected number of typeAliases", function () {
            chai_1.expect(typeAliases.length).to.equal(2);
        });
        it("should have correct type", function () {
            chai_1.expect(typeAliases[0]).to.be.instanceOf(compiler_1.TypeAliasDeclaration);
        });
    });
    describe("getTypeAlias", function () {
        var sourceFile = testHelpers_1.getInfoFromText("type Identifier1 = string;\ntype Identifier2 = number;").sourceFile;
        it("should get a type alias by a name", function () {
            chai_1.expect(sourceFile.getTypeAlias("Identifier2").getName()).to.equal("Identifier2");
        });
        it("should get a type alias by a search function", function () {
            chai_1.expect(sourceFile.getTypeAlias(function (c) { return c.getName() === "Identifier1"; }).getName()).to.equal("Identifier1");
        });
        it("should return undefined when the type alias doesn't exist", function () {
            chai_1.expect(sourceFile.getTypeAlias("asdf")).to.be.undefined;
        });
    });
    describe("getTypeAliasOrThrow", function () {
        var sourceFile = testHelpers_1.getInfoFromText("type Identifier1 = string;\ntype Identifier2 = number;").sourceFile;
        it("should get a type alias by a name", function () {
            chai_1.expect(sourceFile.getTypeAliasOrThrow("Identifier2").getName()).to.equal("Identifier2");
        });
        it("should get a type alias by a search function", function () {
            chai_1.expect(sourceFile.getTypeAliasOrThrow(function (c) { return c.getName() === "Identifier1"; }).getName()).to.equal("Identifier1");
        });
        it("should throw when the type alias doesn't exist", function () {
            chai_1.expect(function () { return sourceFile.getTypeAliasOrThrow("asdf"); }).to.throw();
        });
    });
});
