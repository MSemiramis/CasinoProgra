"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var compiler_1 = require("../../../../compiler");
var testHelpers_1 = require("../../testHelpers");
describe("StatementedNode", function () {
    describe("insertEnums", function () {
        function doTest(startCode, index, structures, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.insertEnums(index, structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert to an empty file", function () {
            doTest("", 0, [{
                    name: "MyEnum",
                    members: [{ name: "member" }],
                    isConst: true
                }], "const enum MyEnum {\n    member\n}\n");
        });
        it("should insert at the start of a file", function () {
            doTest("class MyClass {\n}\n", 0, [{ name: "MyEnum" }], "enum MyEnum {\n}\n\nclass MyClass {\n}\n");
        });
        it("should insert at the end of a file", function () {
            doTest("class MyClass {\n}\n", 1, [{ name: "MyEnum" }], "class MyClass {\n}\n\nenum MyEnum {\n}\n");
        });
        it("should insert in the middle of children", function () {
            doTest("class MyClass {\n}\n\nclass MyOther {\n}\n", 1, [{ name: "MyEnum" }], "class MyClass {\n}\n\nenum MyEnum {\n}\n\nclass MyOther {\n}\n");
        });
        it("should insert multiple enums", function () {
            doTest("class MyClass {\n}\n", 1, [{ name: "MyEnum" }, { name: "Enum2" }], "class MyClass {\n}\n\nenum MyEnum {\n}\n\nenum Enum2 {\n}\n");
        });
        it("should have the expected text adding to non-source file", function () {
            var sourceFile = testHelpers_1.getInfoFromText("namespace MyNamespace {\n}\n").sourceFile;
            var namespaceDec = sourceFile.getNamespaces()[0];
            namespaceDec.insertEnums(0, [{
                    name: "MyEnum",
                    members: [{ name: "member" }]
                }]);
            chai_1.expect(sourceFile.getFullText()).to.equal("namespace MyNamespace {\n    enum MyEnum {\n        member\n    }\n}\n");
        });
    });
    describe("insertEnum", function () {
        function doTest(startCode, index, structure, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.insertEnum(index, structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.EnumDeclaration);
        }
        it("should insert an enum", function () {
            doTest("class MyClass {\n}\n", 0, { name: "MyEnum" }, "enum MyEnum {\n}\n\nclass MyClass {\n}\n");
        });
    });
    describe("addEnums", function () {
        function doTest(startCode, structures, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addEnums(structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add enums", function () {
            doTest("class MyClass {\n}\n", [{ name: "MyEnum" }, { name: "Enum2" }], "class MyClass {\n}\n\nenum MyEnum {\n}\n\nenum Enum2 {\n}\n");
        });
    });
    describe("addEnum", function () {
        function doTest(startCode, structure, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addEnum(structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.EnumDeclaration);
        }
        it("should add an enum", function () {
            doTest("class MyClass {\n}\n", { name: "MyEnum" }, "class MyClass {\n}\n\nenum MyEnum {\n}\n");
        });
    });
    describe("getEnums", function () {
        var sourceFile = testHelpers_1.getInfoFromText("enum Identifier1 {}\nenum Identifier2 { member }").sourceFile;
        var enums = sourceFile.getEnums();
        it("should have the expected number of enums", function () {
            chai_1.expect(enums.length).to.equal(2);
        });
        it("should have correct type", function () {
            chai_1.expect(enums[0]).to.be.instanceOf(compiler_1.EnumDeclaration);
        });
    });
    describe("getEnum", function () {
        var sourceFile = testHelpers_1.getInfoFromText("enum Identifier1 {}\nenum Identifier2 { member }").sourceFile;
        it("should get an enum by a name", function () {
            chai_1.expect(sourceFile.getEnum("Identifier2").getName()).to.equal("Identifier2");
        });
        it("should get a enum by a search function", function () {
            chai_1.expect(sourceFile.getEnum(function (c) { return c.getName() === "Identifier1"; }).getName()).to.equal("Identifier1");
        });
        it("should return undefined when the enum doesn't exist", function () {
            chai_1.expect(sourceFile.getEnum("asdf")).to.be.undefined;
        });
    });
    describe("getEnumOrThrow", function () {
        var sourceFile = testHelpers_1.getInfoFromText("enum Identifier1 {}\nenum Identifier2 { member }").sourceFile;
        it("should get an enum by a name", function () {
            chai_1.expect(sourceFile.getEnumOrThrow("Identifier2").getName()).to.equal("Identifier2");
        });
        it("should get a enum by a search function", function () {
            chai_1.expect(sourceFile.getEnumOrThrow(function (c) { return c.getName() === "Identifier1"; }).getName()).to.equal("Identifier1");
        });
        it("should throw when the enum doesn't exist", function () {
            chai_1.expect(function () { return sourceFile.getEnumOrThrow("asdf"); }).to.throw();
        });
    });
});
