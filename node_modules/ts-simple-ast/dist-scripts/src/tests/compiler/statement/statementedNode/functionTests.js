"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var compiler_1 = require("../../../../compiler");
var testHelpers_1 = require("../../testHelpers");
describe("StatementedNode", function () {
    describe("insertFunctions", function () {
        function doTest(startCode, index, structures, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.insertFunctions(index, structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert to an empty file", function () {
            doTest("", 0, [{
                    name: "Identifier"
                }], "function Identifier() {\n}\n");
        });
        it("should insert at the start of a file", function () {
            doTest("function Identifier2() {\n}\n", 0, [{ name: "Identifier1" }], "function Identifier1() {\n}\n\nfunction Identifier2() {\n}\n");
        });
        it("should insert at the end of a file", function () {
            doTest("function Identifier1() {\n}\n", 1, [{ name: "Identifier2" }], "function Identifier1() {\n}\n\nfunction Identifier2() {\n}\n");
        });
        it("should insert in the middle of children", function () {
            doTest("function Identifier1() {\n}\n\nfunction Identifier3() {\n}\n", 1, [{ name: "Identifier2" }], "function Identifier1() {\n}\n\nfunction Identifier2() {\n}\n\nfunction Identifier3() {\n}\n");
        });
        it("should insert multiple", function () {
            doTest("function Identifier1() {\n}\n", 1, [{ name: "Identifier2" }, { name: "Identifier3" }], "function Identifier1() {\n}\n\nfunction Identifier2() {\n}\n\nfunction Identifier3() {\n}\n");
        });
        it("should insert ones with a declaration keyword accordingly", function () {
            doTest("function Identifier1() {\n}\ndeclare function Identifier4(): string;", 1, [{ hasDeclareKeyword: true, name: "Identifier2" }, { hasDeclareKeyword: true, name: "Identifier3" }], "function Identifier1() {\n}\n\ndeclare function Identifier2();\ndeclare function Identifier3();\ndeclare function Identifier4(): string;");
        });
        it("should have the expected text adding to non-source file", function () {
            var sourceFile = testHelpers_1.getInfoFromText("namespace Namespace {\n}\n").sourceFile;
            var namespaceDec = sourceFile.getNamespaces()[0];
            namespaceDec.insertFunctions(0, [{
                    name: "Identifier"
                }]);
            chai_1.expect(sourceFile.getFullText()).to.equal("namespace Namespace {\n    function Identifier() {\n    }\n}\n");
        });
        it("should insert when the structure has everything the writer supports", function () {
            doTest("", 0, [{ name: "func", parameters: [{ name: "p1" }, { name: "p2" }] }], "function func(p1, p2) {\n}\n");
        });
    });
    describe("insertFunction", function () {
        function doTest(startCode, index, structure, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.insertFunction(index, structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.FunctionDeclaration);
        }
        it("should insert", function () {
            doTest("function Identifier2() {\n}\n", 0, { name: "Identifier1" }, "function Identifier1() {\n}\n\nfunction Identifier2() {\n}\n");
        });
    });
    describe("addFunctions", function () {
        function doTest(startCode, structures, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addFunctions(structures);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add multiple", function () {
            doTest("function Identifier1() {\n}\n", [{ name: "Identifier2" }, { name: "Identifier3" }], "function Identifier1() {\n}\n\nfunction Identifier2() {\n}\n\nfunction Identifier3() {\n}\n");
        });
    });
    describe("addFunction", function () {
        function doTest(startCode, structure, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
            var result = sourceFile.addFunction(structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            chai_1.expect(result).to.be.instanceOf(compiler_1.FunctionDeclaration);
        }
        it("should add one", function () {
            doTest("function Identifier1() {\n}\n", { name: "Identifier2" }, "function Identifier1() {\n}\n\nfunction Identifier2() {\n}\n");
        });
    });
    describe("getFunctions", function () {
        var sourceFile = testHelpers_1.getInfoFromText("function Identifier1();function Identifier1() {}\nfunction Identifier2() {}" +
            "declare function Identifier3(); declare function Identifier3();").sourceFile;
        var functions = sourceFile.getFunctions();
        it("should have the expected number of functions", function () {
            chai_1.expect(functions.length).to.equal(4);
        });
        it("should have correct type", function () {
            chai_1.expect(functions[0]).to.be.instanceOf(compiler_1.FunctionDeclaration);
        });
    });
    describe("getFunction", function () {
        var sourceFile = testHelpers_1.getInfoFromText("function Identifier1() {}\nfunction Identifier2() {}").sourceFile;
        it("should get a function by a name", function () {
            chai_1.expect(sourceFile.getFunction("Identifier2").getName()).to.equal("Identifier2");
        });
        it("should get a function by a search function", function () {
            chai_1.expect(sourceFile.getFunction(function (c) { return c.getName() === "Identifier1"; }).getName()).to.equal("Identifier1");
        });
        it("should return undefined when the function doesn't exist", function () {
            chai_1.expect(sourceFile.getFunction("asdf")).to.be.undefined;
        });
    });
    describe("getFunctionOrThrow", function () {
        var sourceFile = testHelpers_1.getInfoFromText("function Identifier1() {}\nfunction Identifier2() {}").sourceFile;
        it("should get a function by a name", function () {
            chai_1.expect(sourceFile.getFunctionOrThrow("Identifier2").getName()).to.equal("Identifier2");
        });
        it("should get a function by a search function", function () {
            chai_1.expect(sourceFile.getFunctionOrThrow(function (c) { return c.getName() === "Identifier1"; }).getName()).to.equal("Identifier1");
        });
        it("should throw when the function doesn't exist", function () {
            chai_1.expect(function () { return sourceFile.getFunctionOrThrow("asdf"); }).to.throw();
        });
    });
});
