"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var typescript_1 = require("../../../typescript");
var compiler_1 = require("../../../compiler");
var utils_1 = require("../../../utils");
var testHelpers_1 = require("../testHelpers");
function getInfoFromTextWithSyntax(text, kind) {
    var obj = testHelpers_1.getInfoFromText(text);
    var firstChild = obj.firstChild;
    if (kind != null) {
        firstChild = obj.sourceFile.getFirstDescendantByKindOrThrow(kind);
    }
    return __assign({}, obj, { firstChild: firstChild });
}
describe("StatementedNode", function () {
    describe("getStatements", function () {
        it("should get the statements of a source file", function () {
            var sourceFile = testHelpers_1.getInfoFromText("var t; var m;").sourceFile;
            chai_1.expect(sourceFile.getStatements().map(function (s) { return s.getText(); })).to.deep.equal(["var t;", "var m;"]);
        });
        function doFirstChildTest(code, statements, kind) {
            var firstChild = getInfoFromTextWithSyntax(code, kind).firstChild;
            chai_1.expect(firstChild.getStatements().map(function (s) { return s.getText(); })).to.deep.equal(statements);
        }
        it("should get the statements of a function", function () {
            doFirstChildTest("function i() { var t; var m; }", ["var t;", "var m;"]);
        });
        it("should get the statements of a namespace", function () {
            doFirstChildTest("namespace n { var t; var m; }", ["var t;", "var m;"]);
        });
        it("should get the statements of a namespace that uses dot notation", function () {
            doFirstChildTest("namespace n.inner { var t; var m; }", ["var t;", "var m;"]);
        });
        it("should get statements of a case clause", function () {
            doFirstChildTest("switch (x) { case 1: x = 0; break; }", ["x = 0;", "break;"], typescript_1.SyntaxKind.CaseClause);
        });
        it("should get statements of a default clause", function () {
            doFirstChildTest("switch (x) { default: x = 0; break; }", ["x = 0;", "break;"], typescript_1.SyntaxKind.DefaultClause);
        });
    });
    describe("getStatement", function () {
        it("should get the statement when it exists", function () {
            var sourceFile = testHelpers_1.getInfoFromText("var t; class T {}").sourceFile;
            chai_1.expect(sourceFile.getStatement(function (s) { return utils_1.TypeGuards.isClassDeclaration(s); }).getText()).to.equal("class T {}");
        });
        it("should return undefined when it doesn't exist", function () {
            var sourceFile = testHelpers_1.getInfoFromText("var t; class T {}").sourceFile;
            chai_1.expect(sourceFile.getStatement(function (s) { return utils_1.TypeGuards.isInterfaceDeclaration(s); })).to.be.undefined;
        });
    });
    describe("getStatementOrThrow", function () {
        it("should get the statement when it exists", function () {
            var sourceFile = testHelpers_1.getInfoFromText("var t; class T {}").sourceFile;
            chai_1.expect(sourceFile.getStatementOrThrow(function (s) { return utils_1.TypeGuards.isClassDeclaration(s); }).getText()).to.equal("class T {}");
        });
        it("should throw when it doesn't exist", function () {
            var sourceFile = testHelpers_1.getInfoFromText("var t; class T {}").sourceFile;
            chai_1.expect(function () { return sourceFile.getStatementOrThrow(function (s) { return utils_1.TypeGuards.isInterfaceDeclaration(s); }); }).to.throw();
        });
    });
    describe("getStatementByKind", function () {
        it("should get the statement when it exists", function () {
            var sourceFile = testHelpers_1.getInfoFromText("var t; class T {}").sourceFile;
            chai_1.expect(sourceFile.getStatementByKind(typescript_1.SyntaxKind.ClassDeclaration).getText()).to.equal("class T {}");
        });
        it("should return undefined when it doesn't exist", function () {
            var sourceFile = testHelpers_1.getInfoFromText("var t; class T {}").sourceFile;
            chai_1.expect(sourceFile.getStatementByKind(typescript_1.SyntaxKind.InterfaceDeclaration)).to.be.undefined;
        });
    });
    describe("getStatementByKindOrThrow", function () {
        it("should get the statement when it exists", function () {
            var sourceFile = testHelpers_1.getInfoFromText("var t; class T {}").sourceFile;
            chai_1.expect(sourceFile.getStatementByKindOrThrow(typescript_1.SyntaxKind.ClassDeclaration).getText()).to.equal("class T {}");
        });
        it("should throw when it doesn't exist", function () {
            var sourceFile = testHelpers_1.getInfoFromText("var t; class T {}").sourceFile;
            chai_1.expect(function () { return sourceFile.getStatementByKindOrThrow(typescript_1.SyntaxKind.InterfaceDeclaration); }).to.throw();
        });
    });
    describe("insertStatements", function () {
        function doSourceFileTest(code, index, statements, expectedLength, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(code).sourceFile;
            var nodes = sourceFile.insertStatements(index, statements);
            chai_1.expect(nodes.length).to.equal(expectedLength);
            if (nodes.length > 0)
                chai_1.expect(nodes[0]).to.be.instanceOf(compiler_1.Node);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert statements into an empty source file", function () {
            doSourceFileTest("", 0, "newText;\nsecondText;", 2, "newText;\nsecondText;\n");
        });
        it("should allow inserting nothing", function () {
            doSourceFileTest("", 0, "", 0, "");
        });
        it("should allow inserting whitespace", function () {
            doSourceFileTest("", 0, "    ", 0, "    \n");
        });
        it("should throw when specifying an invalid index", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(function () { return sourceFile.insertStatements(1, "statements;"); }).to.throw();
        });
        it("should allow writing", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            sourceFile.insertStatements(0, function (writer) { return writer.writeLine("statements;"); });
            chai_1.expect(sourceFile.getFullText()).to.equal("statements;\n");
        });
        it("should insert statements at the beginning of a source file", function () {
            doSourceFileTest("function i() {}", 0, "newText;\nsecondText;", 2, "newText;\nsecondText;\nfunction i() {}");
        });
        it("should insert statements in the middle of a source file", function () {
            doSourceFileTest("function a() {}\nfunction b() {}", 1, "newText;\nsecondText;", 2, "function a() {}\nnewText;\nsecondText;\nfunction b() {}");
        });
        it("should insert statements at the end of a source file", function () {
            doSourceFileTest("function a() {}\nfunction b() {}", 2, "newText;\nsecondText;", 2, "function a() {}\nfunction b() {}\nnewText;\nsecondText;");
        });
        function doFirstChildTest(code, index, statements, expectedLength, expectedCode, kind) {
            var _a = getInfoFromTextWithSyntax(code, kind), sourceFile = _a.sourceFile, firstChild = _a.firstChild;
            var nodes = firstChild.insertStatements(index, statements);
            chai_1.expect(nodes.length).to.equal(expectedLength);
            chai_1.expect(nodes[0]).to.be.instanceOf(compiler_1.Node);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert statements into an empty function", function () {
            doFirstChildTest("function i() {\n}\n", 0, "statement;", 1, "function i() {\n    statement;\n}\n");
        });
        it("should insert statements at the beginning and into a function", function () {
            doFirstChildTest("function i() {\n    var t;\n    var m;\n}", 0, "newText;\nsecondText;", 2, "function i() {\n    newText;\n    secondText;\n    var t;\n    var m;\n}");
        });
        it("should insert statements in the middle and into a namespace", function () {
            doFirstChildTest("namespace n {\n    var t;\n    var m;\n}", 1, "newText;\nsecondText;", 2, "namespace n {\n    var t;\n    newText;\n    secondText;\n    var m;\n}");
        });
        it("should insert statements at the end and into a namespace", function () {
            doFirstChildTest("namespace n {\n    var t;\n    var m;\n}", 2, "newText;\nsecondText;", 2, "namespace n {\n    var t;\n    var m;\n    newText;\n    secondText;\n}");
        });
        it("should insert between statements right beside each other", function () {
            doFirstChildTest("function i() { var t;var m; }", 1, "newText;", 1, "function i() { var t;\n    newText;var m; }");
        });
        var caseClause = "switch (x) {\n    case 1:\n        x = 0;\n        y = 1;\n        break;\n}";
        it("should insert statements at the beginning and into a case clase", function () {
            doFirstChildTest(caseClause, 0, "newText;\nsecondText;", 2, "switch (x) {\n    case 1:\n        newText;\n        secondText;\n        x = 0;\n        y = 1;\n        break;\n}", typescript_1.SyntaxKind.CaseClause);
        });
        it("should insert statements in the middle and into a case clause", function () {
            doFirstChildTest(caseClause, 2, "newText;\nsecondText;", 2, "switch (x) {\n    case 1:\n        x = 0;\n        y = 1;\n        newText;\n        secondText;\n        break;\n}", typescript_1.SyntaxKind.CaseClause);
        });
        it("should insert statements at the end and into a case clause", function () {
            doFirstChildTest(caseClause, 3, "newText;\nsecondText;", 2, "switch (x) {\n    case 1:\n        x = 0;\n        y = 1;\n        break;\n        newText;\n        secondText;\n}", typescript_1.SyntaxKind.CaseClause);
        });
        var defaultClause = "switch (x) {\n    default:\n        x = 0;\n        y = 1;\n        break;\n}";
        it("should insert statements at the beginning and into a default clause", function () {
            doFirstChildTest(defaultClause, 0, "newText;\nsecondText;", 2, "switch (x) {\n    default:\n        newText;\n        secondText;\n        x = 0;\n        y = 1;\n        break;\n}", typescript_1.SyntaxKind.DefaultClause);
        });
        it("should insert statements in the middle and into a default clause", function () {
            doFirstChildTest(defaultClause, 2, "newText;\nsecondText;", 2, "switch (x) {\n    default:\n        x = 0;\n        y = 1;\n        newText;\n        secondText;\n        break;\n}", typescript_1.SyntaxKind.DefaultClause);
        });
        it("should insert statements at the end and into a default clause", function () {
            doFirstChildTest(defaultClause, 3, "newText;\nsecondText;", 2, "switch (x) {\n    default:\n        x = 0;\n        y = 1;\n        break;\n        newText;\n        secondText;\n}", typescript_1.SyntaxKind.DefaultClause);
        });
    });
    describe("addStatements", function () {
        function doSourceFileTest(code, statements, expectedLength, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(code).sourceFile;
            var nodes = sourceFile.addStatements(statements);
            chai_1.expect(nodes.length).to.equal(expectedLength);
            chai_1.expect(nodes[0]).to.be.instanceOf(compiler_1.Node);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add statements at the end of a source file", function () {
            doSourceFileTest("function a() {}\nfunction b() {}", "newText;\nsecondText;", 2, "function a() {}\nfunction b() {}\nnewText;\nsecondText;");
        });
    });
    describe("removeStatements", function () {
        function doSourceFileTest(code, range, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(code).sourceFile;
            sourceFile.removeStatements(range);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should throw when specifying an invalid range", function () {
            var sourceFile = testHelpers_1.getInfoFromText("").sourceFile;
            chai_1.expect(function () { return sourceFile.removeStatements([5, 7]); }).to.throw();
        });
        it("should remove statements at the beginning of a source file", function () {
            doSourceFileTest("function a() {}\nfunction b() {}\nfunction c() {}\n", [0, 1], "function c() {}\n");
        });
        it("should remove statements in the middle of a source file", function () {
            doSourceFileTest("function a() {}\nfunction b() {}\nfunction c() {}\n", [1, 1], "function a() {}\n\nfunction c() {}\n");
        });
        it("should remove statements at the end source file", function () {
            doSourceFileTest("function a() {}\nfunction b() {}\nfunction c() {}\n", [1, 2], "function a() {}\n");
        });
        it("should remove an if statement", function () {
            doSourceFileTest("if (true) {\n    console.log(6);\n}\n", [0, 0], "");
        });
        function doFirstChildTest(code, range, expectedCode, kind) {
            var _a = getInfoFromTextWithSyntax(code, kind), sourceFile = _a.sourceFile, firstChild = _a.firstChild;
            var nodes = firstChild.removeStatements(range);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        var caseClause = "switch (x) {\n    case 1:\n        x = 0;\n        y = 1;\n        break;\n}";
        it("should remove statements at the beginning of a case clause", function () {
            doFirstChildTest(caseClause, [0, 1], "switch (x) {\n    case 1:\n        break;\n}", typescript_1.SyntaxKind.CaseClause);
        });
        it("should remove statements in the middle of a case clause", function () {
            doFirstChildTest(caseClause, [1, 1], "switch (x) {\n    case 1:\n        x = 0;\n        break;\n}", typescript_1.SyntaxKind.CaseClause);
        });
        it("should remove statements at the end case clause", function () {
            doFirstChildTest(caseClause, [1, 2], "switch (x) {\n    case 1:\n        x = 0;\n\n}", typescript_1.SyntaxKind.CaseClause);
        });
        var defaultClause = "switch (x) {\n    default:\n        x = 0;\n        y = 1;\n        break;\n}";
        it("should remove statements at the beginning of a default clause", function () {
            doFirstChildTest(defaultClause, [0, 1], "switch (x) {\n    default:\n        break;\n}", typescript_1.SyntaxKind.DefaultClause);
        });
        it("should remove statements in the middle of a default clause", function () {
            doFirstChildTest(defaultClause, [1, 1], "switch (x) {\n    default:\n        x = 0;\n        break;\n}", typescript_1.SyntaxKind.DefaultClause);
        });
        it("should remove statements at the end default clause", function () {
            doFirstChildTest(defaultClause, [1, 2], "switch (x) {\n    default:\n        x = 0;\n\n}", typescript_1.SyntaxKind.DefaultClause);
        });
    });
    describe("removeStatement", function () {
        function doSourceFileTest(code, index, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(code).sourceFile;
            sourceFile.removeStatement(index);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should throw when specifying an invalid index", function () {
            var sourceFile = testHelpers_1.getInfoFromText("class myClass {}").sourceFile;
            chai_1.expect(function () { return sourceFile.removeStatement(1); }).to.throw();
        });
        it("should remove at the specified index", function () {
            doSourceFileTest("function a() {}\nfunction b() {}\nfunction c() {}\n", 1, "function a() {}\n\nfunction c() {}\n");
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var sourceFile = testHelpers_1.getInfoFromText(startingCode).sourceFile;
            sourceFile.fill(structure);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("", {}, "");
        });
        it("should modify when changed", function () {
            var structure = {
                classes: [{ name: "Identifier1" }],
                enums: [{ name: "Identifier2" }],
                functions: [{ name: "Identifier3" }],
                interfaces: [{ name: "Identifier4" }],
                namespaces: [{ name: "Identifier5" }],
                typeAliases: [{ name: "Identifier6", type: "string" }]
            };
            doTest("", structure, "class Identifier1 {\n}\n\nenum Identifier2 {\n}\n\nfunction Identifier3() {\n}\n\ninterface Identifier4 {\n}\n\nnamespace Identifier5 {\n}\n\n" +
                "type Identifier6 = string;\n");
        });
    });
});
