"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testHelpers_1 = require("../testHelpers");
describe("InterfaceDeclaration", function () {
    describe("getType", function () {
        it("should get the interface's type", function () {
            var sourceFile = testHelpers_1.getInfoFromText("interface Identifier { prop: string; }").sourceFile;
            chai_1.expect(sourceFile.getInterfaceOrThrow("Identifier").getType().getText()).to.deep.equal("Identifier");
        });
    });
    describe("getBaseTypes", function () {
        function doTest(text, interfaceName, expectedNames) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            var types = sourceFile.getInterfaceOrThrow(interfaceName).getBaseTypes();
            chai_1.expect(types.map(function (c) { return c.getText(); })).to.deep.equal(expectedNames);
        }
        it("should get the base when it's a interface", function () {
            doTest("interface Base {} interface Child extends Base {}", "Child", ["Base"]);
        });
        it("should get the base when there are multiple", function () {
            doTest("interface Base1 {} interface Base2 {} interface Child extends Base1, Base2 {}", "Child", ["Base1", "Base2"]);
        });
        it("should be empty when there is no base interface", function () {
            doTest("interface Interface {}", "Interface", []);
        });
    });
    describe("getBaseDeclarations", function () {
        function doTest(text, interfaceName, expectedNames) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            var declarations = sourceFile.getInterfaceOrThrow(interfaceName).getBaseDeclarations();
            chai_1.expect(declarations.map(function (c) { return c.getName(); })).to.deep.equal(expectedNames);
        }
        it("should get the base when it's a interface", function () {
            doTest("interface Base {} interface Child extends Base {}", "Child", ["Base"]);
        });
        it("should get the base when there are multiple", function () {
            doTest("interface Base1 {} interface Base2 {} interface Child extends Base1, Base2 {}", "Child", ["Base1", "Base2"]);
        });
        it("should get the base when there are multiple with the same name", function () {
            doTest("interface Base1 {} interface Base2 { prop: string; } interface Base2 { prop2: string; } interface Child extends Base1, Base2 {}", "Child", ["Base1", "Base2", "Base2"]);
        });
        it("should be empty when there is no base interface", function () {
            doTest("interface Interface {}", "Interface", []);
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
        }
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("interface Identifier {\n}", {}, "interface Identifier {\n}");
        });
        // currently no members exist on InterfaceDeclarationSpecificStructure
    });
    describe("remove", function () {
        function doTest(text, index, expectedText) {
            var sourceFile = testHelpers_1.getInfoFromText(text).sourceFile;
            sourceFile.getInterfaces()[index].remove();
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
        }
        it("should remove the interface declaration", function () {
            doTest("interface I {}\n\ninterface J {}\n\ninterface K {}", 1, "interface I {}\n\ninterface K {}");
        });
    });
    describe("getImplementations", function () {
        it("should get the implementations", function () {
            var sourceFileText = "interface MyInterface {}\nexport class Class1 implements MyInterface {}\nclass Class2 implements MyInterface {}";
            var _a = testHelpers_1.getInfoFromText(sourceFileText), firstChild = _a.firstChild, sourceFile = _a.sourceFile, project = _a.project;
            var implementations = firstChild.getImplementations();
            chai_1.expect(implementations.length).to.equal(2);
            chai_1.expect(implementations[0].getNode().getName()).to.equal("Class1");
            chai_1.expect(implementations[1].getNode().getName()).to.equal("Class2");
        });
    });
});
