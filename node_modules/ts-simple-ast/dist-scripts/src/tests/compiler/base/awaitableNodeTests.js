"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testHelpers_1 = require("../testHelpers");
describe("AwaitableNode", function () {
    var awaitForOfText = "for await (const x of [Promise.resolve(1)]) {}";
    var forOfText = "for (const x of [Promise.resolve(1)]) {}";
    var mainSourceFile = testHelpers_1.getInfoFromText(awaitForOfText + "\n" + forOfText).sourceFile;
    var awaitForOf = mainSourceFile.getStatements()[0];
    var forOf = mainSourceFile.getStatements()[1];
    describe("isAwaited", function () {
        it("should be a await when so", function () {
            chai_1.expect(awaitForOf.isAwaited()).to.be.true;
        });
        it("should not be await when not so", function () {
            chai_1.expect(forOf.isAwaited()).to.be.false;
        });
    });
    describe("getAwaitKeyword", function () {
        it("should have an await token when awaited", function () {
            chai_1.expect(awaitForOf.getAwaitKeyword().getText()).to.equal("await");
        });
        it("should not have an await keyword when not awaited", function () {
            chai_1.expect(forOf.getAwaitKeyword()).to.be.undefined;
        });
    });
    describe("getAwaitKeywordOrThrow", function () {
        it("should have an await token when awaited", function () {
            chai_1.expect(awaitForOf.getAwaitKeywordOrThrow().getText()).to.equal("await");
        });
        it("should not have an await keyword when not awaited", function () {
            chai_1.expect(function () { return forOf.getAwaitKeywordOrThrow(); }).to.throw();
        });
    });
    describe("setIsAwaited", function () {
        describe("For of", function () {
            it("should set as await when not a await", function () {
                var _a = testHelpers_1.getInfoFromText(forOfText), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.setIsAwaited(true);
                chai_1.expect(sourceFile.getText()).to.equal(awaitForOfText);
            });
            it("should set as not a await when a await", function () {
                var _a = testHelpers_1.getInfoFromText(awaitForOfText), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.setIsAwaited(false);
                chai_1.expect(sourceFile.getText()).to.equal(forOfText);
            });
            it("should not change the await when already that value", function () {
                var _a = testHelpers_1.getInfoFromText(awaitForOfText), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.setIsAwaited(true);
                chai_1.expect(sourceFile.getText()).to.equal(awaitForOfText);
            });
            //  Well, sort of properly - it maintains there is no space before the first parens.
            it("should handle for spacing properly when adding await", function () {
                var _a = testHelpers_1.getInfoFromText("for(const x of [Promise.resolve(1)]) {}"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.setIsAwaited(true);
                chai_1.expect(sourceFile.getText()).to.equal("for await(const x of [Promise.resolve(1)]) {}");
            });
            it("should handle for spacing properly when removing await", function () {
                var _a = testHelpers_1.getInfoFromText("for await(const x of [Promise.resolve(1)]) {}"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.setIsAwaited(false);
                chai_1.expect(sourceFile.getText()).to.equal("for(const x of [Promise.resolve(1)]) {}");
            });
        });
    });
    describe("fill", function () {
        function doTest(startCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure); // nothing is using this yet
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
        }
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest(forOfText, {}, forOfText);
        });
        it("should not modify anything if the structure doesn't change anything and the node has everything set", function () {
            doTest(awaitForOfText, {}, awaitForOfText);
        });
        it("should modify when setting as await", function () {
            doTest(forOfText, { isAwaited: true }, awaitForOfText);
        });
    });
});
