"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var compiler_1 = require("../../../../compiler");
var testHelpers_1 = require("../../testHelpers");
function getInfoFromTextWithFirstInterfaceProperty(text) {
    var obj = testHelpers_1.getInfoFromText(text);
    var firstProp = obj.firstChild.getProperties()[0];
    return __assign({}, obj, { firstProp: firstProp });
}
describe("PropertyNamedNode", function () {
    describe("rename", function () {
        function renameTest(startText, newName, expectedText) {
            var _a = getInfoFromTextWithFirstInterfaceProperty(startText), firstProp = _a.firstProp, sourceFile = _a.sourceFile, project = _a.project;
            firstProp.rename(newName);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
        }
        it("should set the name and rename any referenced nodes", function () {
            renameTest("interface Identifier { prop: string; }\nlet myVar: Identifier;\nmyVar.prop;", "newProp", "interface Identifier { newProp: string; }\nlet myVar: Identifier;\nmyVar.newProp;");
        });
        it("should rename to a string literal", function () {
            // this actually won't do too good of a job because the compiler currently doesn't support this scenario
            renameTest("interface Identifier { prop: string; }\nlet myVar: Identifier;\nmyVar.prop; console.log('this');", "'str'", "interface Identifier { 'str': string; }\nlet myVar: Identifier;\nmyVar.'str'; console.log('this');");
        });
        function throwTest(text) {
            var firstProp = getInfoFromTextWithFirstInterfaceProperty("interface MyInterface { prop: string; }").firstProp;
            chai_1.expect(function () { return firstProp.rename(text); }).to.throw();
        }
        it("should throw if null", function () {
            throwTest(null);
        });
        it("should throw if empty string", function () {
            throwTest("");
        });
        it("should throw if whitespace", function () {
            throwTest("    ");
        });
        it("should throw if a number", function () {
            throwTest(4);
        });
    });
    describe("getName", function () {
        it("should get the name when regularly named", function () {
            var firstProp = getInfoFromTextWithFirstInterfaceProperty("interface identifier { prop: string; }").firstProp;
            chai_1.expect(firstProp.getName()).to.equal("prop");
        });
        it("should get the name when a string literal", function () {
            var firstProp = getInfoFromTextWithFirstInterfaceProperty("interface identifier { 'str': string; }").firstProp;
            chai_1.expect(firstProp.getName()).to.equal("'str'");
        });
        it("should get the name when a numeric literal", function () {
            var firstProp = getInfoFromTextWithFirstInterfaceProperty("interface identifier { 5: string; }").firstProp;
            chai_1.expect(firstProp.getName()).to.equal("5");
        });
        it("should get the name when a computed property", function () {
            var firstProp = getInfoFromTextWithFirstInterfaceProperty("interface identifier { [5]: string; }").firstProp;
            chai_1.expect(firstProp.getName()).to.equal("[5]");
        });
    });
    describe("getNameNode", function () {
        it("should get a regularly named node property", function () {
            var firstProp = getInfoFromTextWithFirstInterfaceProperty("interface identifier { prop: string; }").firstProp;
            var nameNode = firstProp.getNameNode();
            chai_1.expect(nameNode.getText()).to.equal("prop");
            chai_1.expect(nameNode).to.be.instanceOf(compiler_1.Identifier);
        });
        it("should get a string literal property", function () {
            var firstProp = getInfoFromTextWithFirstInterfaceProperty("interface identifier { 'str': string; }").firstProp;
            var nameNode = firstProp.getNameNode();
            chai_1.expect(nameNode.getText()).to.equal("'str'");
            chai_1.expect(nameNode).to.be.instanceOf(compiler_1.StringLiteral);
        });
        it("should get a numeric literal property", function () {
            var firstProp = getInfoFromTextWithFirstInterfaceProperty("interface identifier { 5: string; }").firstProp;
            var nameNode = firstProp.getNameNode();
            chai_1.expect(nameNode.getText()).to.equal("5");
            chai_1.expect(nameNode).to.be.instanceOf(compiler_1.NumericLiteral);
        });
        it("should get a computed property name", function () {
            var firstProp = getInfoFromTextWithFirstInterfaceProperty("interface identifier { [5]: string; }").firstProp;
            var nameNode = firstProp.getNameNode();
            chai_1.expect(nameNode.getText()).to.equal("[5]");
            chai_1.expect(nameNode).to.be.instanceOf(compiler_1.ComputedPropertyName);
        });
    });
});
