"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testHelpers_1 = require("../testHelpers");
describe("TypedNode", function () {
    var mainSourceFile = testHelpers_1.getInfoFromText("var myImplicitVar = 1; var myExplicitVar: string; type TypeAlias1 = string;").sourceFile;
    var implicitVarDeclaration = mainSourceFile.getVariableStatements()[0].getDeclarations()[0];
    var explicitVarDeclaration = mainSourceFile.getVariableStatements()[1].getDeclarations()[0];
    var typeAliasDeclaration = mainSourceFile.getTypeAliases()[0];
    describe("getType", function () {
        it("should get the expected implicit type", function () {
            chai_1.expect(implicitVarDeclaration.getType().getText()).to.equal("number");
        });
        it("should get the expected explicit type", function () {
            chai_1.expect(explicitVarDeclaration.getType().getText()).to.equal("string");
        });
        it("should get the expected type for a type alias", function () {
            chai_1.expect(typeAliasDeclaration.getType().getText()).to.equal("string");
        });
    });
    describe("getTypeNode", function () {
        it("should return undefined when no type node exists", function () {
            chai_1.expect(implicitVarDeclaration.getTypeNode()).to.be.undefined;
        });
        it("should get the type node when it exists", function () {
            chai_1.expect(explicitVarDeclaration.getTypeNode().getText()).to.equal("string");
        });
        it("should get the type node for a type alias", function () {
            chai_1.expect(typeAliasDeclaration.getTypeNode().getText()).to.equal("string");
        });
    });
    describe("getTypeNodeOrThrow", function () {
        it("should get the type node when it exists", function () {
            chai_1.expect(explicitVarDeclaration.getTypeNodeOrThrow().getText()).to.equal("string");
        });
        it("should return undefined when no type node exists", function () {
            chai_1.expect(function () { return implicitVarDeclaration.getTypeNodeOrThrow(); }).to.throw();
        });
    });
    describe("setType", function () {
        describe("class properties", function () {
            function doTest(startText, type, expectedText) {
                var firstChild = testHelpers_1.getInfoFromText(startText).firstChild;
                var prop = firstChild.getInstanceProperties()[0];
                prop.setType(type);
                chai_1.expect(firstChild.getText()).to.equal(expectedText);
            }
            it("should set when implicit, with a semi-colon, and initializer", function () {
                doTest("class Identifier { prop = \"\"; }", "any", "class Identifier { prop: any = \"\"; }");
            });
            it("should set when explicit, with a semi-colon, no initializer", function () {
                doTest("class Identifier { prop: string; }", "number", "class Identifier { prop: number; }");
            });
            it("should set when explicit, without a semi-colon, no initializer", function () {
                doTest("class Identifier { prop: string }", "number", "class Identifier { prop: number }");
            });
            it("should set when explicit, with a semi-colon, with initializer", function () {
                doTest("class Identifier { prop: string = \"\"; }", "any", "class Identifier { prop: any = \"\"; }");
            });
            it("should remove when the type is empty", function () {
                doTest("class Identifier { prop: string = \"\"; }", "", "class Identifier { prop = \"\"; }");
            });
        });
        describe("function parameters", function () {
            function doTest(startText, type, expectedText) {
                var firstChild = testHelpers_1.getInfoFromText(startText).firstChild;
                var param = firstChild.getParameters()[0];
                param.setType(type);
                chai_1.expect(firstChild.getText()).to.equal(expectedText);
            }
            it("should set when implicit", function () {
                doTest("function Identifier(param) {}", "number", "function Identifier(param: number) {}");
            });
            it("should set when implicit and multiple parameters", function () {
                doTest("function Identifier(param, param2) {}", "number", "function Identifier(param: number, param2) {}");
            });
            it("should set when explicit", function () {
                doTest("function Identifier(param: string) {}", "number", "function Identifier(param: number) {}");
            });
            it("should set when explicit and with an initializer", function () {
                doTest("function Identifier(param: string = \"\") {}", "any", "function Identifier(param: any = \"\") {}");
            });
            it("should remove when the type is empty", function () {
                doTest("function Identifier(param: string = \"\") {}", "", "function Identifier(param = \"\") {}");
            });
        });
        describe("type alias", function () {
            // todo: support this scenario
            /*
            it("should set when no type exists", () => {
                const {firstChild} = getInfoFromText<TypeAliasDeclaration>(`type Identifier;`);
                firstChild.setType("number");
                expect(firstChild.getText()).to.equal(`type Identifier = number;`);
            });
            */
            it("should set when type exists", function () {
                var firstChild = testHelpers_1.getInfoFromText("type Identifier = string;").firstChild;
                firstChild.setType("number");
                chai_1.expect(firstChild.getText()).to.equal("type Identifier = number;");
            });
            it("should throw an error when providing nothing", function () {
                var firstChild = testHelpers_1.getInfoFromText("type Identifier = string;").firstChild;
                chai_1.expect(function () { return firstChild.setType(""); }).to.throw();
            });
        });
        describe("variable declaration", function () {
            function doTest(startText, type, expectedText) {
                var firstChild = testHelpers_1.getInfoFromText(expectedText).firstChild;
                var declaration = firstChild.getDeclarations()[0];
                declaration.setType(type);
                chai_1.expect(firstChild.getText()).to.equal(expectedText);
            }
            it("should set when no type exists", function () {
                doTest("var identifier;", "number", "var identifier: number;");
            });
            it("should set when type exists", function () {
                doTest("var identifier: string;", "number", "var identifier: number;");
            });
            it("should set when type exists and initializer", function () {
                doTest("var identifier: string = \"\";", "number", "var identifier: number = \"\";");
            });
            it("should set for other declaration in list", function () {
                var firstChild = testHelpers_1.getInfoFromText("var var1, var2, var3;").firstChild;
                var declaration = firstChild.getDeclarations()[1];
                declaration.setType("number");
                chai_1.expect(firstChild.getText()).to.equal("var var1, var2: number, var3;");
            });
            it("should remove when the type is empty", function () {
                doTest("var identifier: string = \"\";", "", "var identifier = \"\";");
            });
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
        }
        it("should modify when setting", function () {
            doTest("type myAlias = string;", { type: "number" }, "type myAlias = number;");
        });
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("type myAlias = string;", {}, "type myAlias = string;");
        });
    });
    describe("removeType", function () {
        function doTest(startText, expectedText) {
            var firstChild = testHelpers_1.getInfoFromText(startText).firstChild;
            var prop = firstChild.getInstanceProperties()[0];
            prop.removeType();
            chai_1.expect(firstChild.getText()).to.equal(expectedText);
        }
        it("should remove when exists", function () {
            doTest("class Identifier { prop: string = \"\"; }", "class Identifier { prop = \"\"; }");
        });
        it("should do nothing when not exists", function () {
            doTest("class Identifier { prop = \"\"; }", "class Identifier { prop = \"\"; }");
        });
        it("should throw an error when removing a type alias", function () {
            var firstChild = testHelpers_1.getInfoFromText("type Identifier = string;").firstChild;
            chai_1.expect(function () { return firstChild.removeType(); }).to.throw();
        });
    });
});
