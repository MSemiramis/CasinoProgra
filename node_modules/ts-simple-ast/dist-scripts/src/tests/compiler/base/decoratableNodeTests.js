"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var compiler_1 = require("../../../compiler");
var typescript_1 = require("../../../typescript");
var testHelpers_1 = require("../testHelpers");
describe("DecoratableNode", function () {
    describe("getDecorator", function () {
        var firstChild = testHelpers_1.getInfoFromText("@log\n@log2\nclass Class {}").firstChild;
        it("should get the decorator by name", function () {
            chai_1.expect(firstChild.getDecorator("log").getName()).to.equal("log");
        });
        it("should get the decorator by function", function () {
            chai_1.expect(firstChild.getDecorator(function (p) { return p.getName() === "log2"; })).to.equal(firstChild.getDecorators()[1]);
        });
        it("should return undefined when it doesn't exist", function () {
            chai_1.expect(firstChild.getDecorator("decorator")).to.be.undefined;
        });
    });
    describe("getDecoratorOrThrow", function () {
        var firstChild = testHelpers_1.getInfoFromText("@log\n@log2\nclass Class {}").firstChild;
        it("should get the decorator by name", function () {
            chai_1.expect(firstChild.getDecoratorOrThrow("log").getName()).to.equal("log");
        });
        it("should get the decorator by function", function () {
            chai_1.expect(firstChild.getDecoratorOrThrow(function (p) { return p.getName() === "log2"; })).to.equal(firstChild.getDecorators()[1]);
        });
        it("should throw when it doesn't exist", function () {
            chai_1.expect(function () { return firstChild.getDecoratorOrThrow("decoratorNamedNodeByNameOrFindFunctionSupportedTypes"); }).to.throw();
        });
    });
    describe("getDecorators", function () {
        function doTest(text, expectedLength) {
            var firstChild = testHelpers_1.getInfoFromText(text).firstChild;
            chai_1.expect(firstChild.getDecorators().length).to.equal(expectedLength);
        }
        it("should return an empty array for no decorators", function () {
            doTest("class Identifier {}", 0);
        });
        it("should get the decorators when they exist", function () {
            doTest("@decorator\n@decorator2()\n@decorator3('str')\nclass Identifier {}", 3);
        });
    });
    describe("insertDecorators", function () {
        describe("class decorators", function () {
            function doTest(startCode, index, structures, expectedCode) {
                var _a = testHelpers_1.getInfoFromTextWithDescendant(startCode, typescript_1.SyntaxKind.ClassDeclaration), descendant = _a.descendant, sourceFile = _a.sourceFile;
                var result = descendant.insertDecorators(index, structures);
                chai_1.expect(result.length).to.equal(structures.length);
                chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
            }
            it("should insert when there are no decorators", function () {
                doTest("class MyClass {}", 0, [{ name: "dec" }], "@dec\nclass MyClass {}");
            });
            it("should insert with arguments", function () {
                doTest("class MyClass {}", 0, [{ name: "dec", arguments: [] }, { name: "dec2", arguments: ["1"] }, { name: "dec3", arguments: ["1", "2"] }], "@dec()\n@dec2(1)\n@dec3(1, 2)\nclass MyClass {}");
            });
            it("should insert on the same indentation level", function () {
                doTest("namespace N {\n    class MyClass {}\n}", 0, [{ name: "dec" }, { name: "dec2" }], "namespace N {\n    @dec\n    @dec2\n    class MyClass {}\n}");
            });
            it("should insert at the start", function () {
                doTest("@dec3\nclass MyClass {}", 0, [{ name: "dec" }, { name: "dec2" }], "@dec\n@dec2\n@dec3\nclass MyClass {}");
            });
            it("should insert multiple in the middle", function () {
                doTest("@dec\n@dec4\nclass MyClass {}", 1, [{ name: "dec2" }, { name: "dec3" }], "@dec\n@dec2\n@dec3\n@dec4\nclass MyClass {}");
            });
            it("should insert one in the middle at the same indentation", function () {
                doTest("namespace N {\n    @dec\n    @dec3\nclass MyClass {}\n}", 1, [{ name: "dec2" }], "namespace N {\n    @dec\n    @dec2\n    @dec3\nclass MyClass {}\n}");
            });
            it("should insert multiple in the middle at the same indentation", function () {
                doTest("namespace N {\n    @dec\n    @dec5\nclass MyClass {}\n}", 1, [{ name: "dec2" }, { name: "dec3" }, { name: "dec4" }], "namespace N {\n    @dec\n    @dec2\n    @dec3\n    @dec4\n    @dec5\nclass MyClass {}\n}");
            });
            it("should insert when the decorators are on the same line", function () {
                doTest("    @dec @dec3\n    class MyClass {}", 1, [{ name: "dec2" }], "    @dec @dec2 @dec3\n    class MyClass {}");
            });
            it("should insert at the end", function () {
                doTest("@dec\nclass MyClass {}", 1, [{ name: "dec2" }, { name: "dec3" }], "@dec\n@dec2\n@dec3\nclass MyClass {}");
            });
        });
        describe("parameter decorator", function () {
            function doTest(startCode, index, structures, expectedCode) {
                var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                var result = firstChild.getInstanceMethods()[0].getParameters()[0].insertDecorators(index, structures);
                chai_1.expect(result.length).to.equal(structures.length);
                chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
            }
            it("should insert on the same line when none exists", function () {
                doTest("class MyClass { myMethod(param) {} }", 0, [{ name: "dec" }], "class MyClass { myMethod(@dec param) {} }");
            });
            it("should insert at the start on the same line", function () {
                doTest("class MyClass { myMethod(@dec2 param) {} }", 0, [{ name: "dec1" }], "class MyClass { myMethod(@dec1 @dec2 param) {} }");
            });
            it("should insert at the end on the same line", function () {
                doTest("class MyClass { myMethod(@dec1 param) {} }", 1, [{ name: "dec2" }], "class MyClass { myMethod(@dec1 @dec2 param) {} }");
            });
        });
    });
    describe("insertDecorator", function () {
        function doTest(startCode, index, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.insertDecorator(index, structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.Decorator);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert in the middle", function () {
            doTest("@dec\n@dec3\nclass MyClass {}", 1, { name: "dec2" }, "@dec\n@dec2\n@dec3\nclass MyClass {}");
        });
    });
    describe("addDecorator", function () {
        function doTest(startCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.addDecorator(structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.Decorator);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add when one doesn't exists", function () {
            doTest("class MyClass {}", { name: "dec" }, "@dec\nclass MyClass {}");
        });
        it("should add when one exists", function () {
            doTest("@dec\nclass MyClass {}", { name: "dec2" }, "@dec\n@dec2\nclass MyClass {}");
        });
    });
    describe("addDecorators", function () {
        function doTest(startCode, structures, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.addDecorators(structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add multiple", function () {
            doTest("@dec\nclass MyClass {}", [{ name: "dec2" }, { name: "dec3" }], "@dec\n@dec2\n@dec3\nclass MyClass {}");
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
        }
        it("should modify when setting", function () {
            doTest("class Identifier {}", { decorators: [{ name: "dec1" }, { name: "dec2" }] }, "@dec1\n@dec2\nclass Identifier {}");
        });
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("class Identifier {}", {}, "class Identifier {}");
        });
    });
});
