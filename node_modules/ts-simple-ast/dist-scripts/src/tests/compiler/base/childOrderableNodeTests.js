"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testHelpers_1 = require("../testHelpers");
describe("ChildOrderableNode", function () {
    describe("setOrder", function () {
        describe("enum", function () {
            function doThrowTest(startCode, newIndex) {
                var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
                var enumDec = sourceFile.getChildSyntaxListOrThrow().getChildren()[0];
                chai_1.expect(function () { return enumDec.setOrder(newIndex); }).to.throw();
            }
            it("should throw when specifying an index < 0", function () {
                doThrowTest("enum Identifier1 {}", -1);
            });
            it("should throw when specifying an index > child count - 1", function () {
                doThrowTest("enum Identifier1 {}", 1);
            });
            function doTest(startCode, oldIndex, newIndex, expectedCode) {
                var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
                sourceFile.getChildSyntaxListOrThrow().getChildren()[oldIndex].setOrder(newIndex);
                chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
            }
            it("should not change the order of the node when moving to the same index", function () {
                doTest("enum Identifier1 {}\n\nenum Identifier2 {}", 0, 0, "enum Identifier1 {}\n\nenum Identifier2 {}");
            });
            it("should change the order of the node when there's two moving first to last", function () {
                doTest("enum Identifier1 {}\n\nenum Identifier2 {}", 0, 1, "enum Identifier2 {}\n\nenum Identifier1 {}");
            });
            it("should change the order of the node when there's two moving last to first", function () {
                doTest("enum Identifier1 {}\n\nenum Identifier2 {}", 1, 0, "enum Identifier2 {}\n\nenum Identifier1 {}");
            });
            it("should change the order of the node when there's three moving first to last", function () {
                doTest("enum Identifier1 {}\n\nenum Identifier2 {}\n\nenum Identifier3 {}", 0, 2, "enum Identifier2 {}\n\nenum Identifier3 {}\n\nenum Identifier1 {}");
            });
            it("should change the order of the node when there's three moving last to first", function () {
                doTest("enum Identifier1 {}\n\nenum Identifier2 {}\n\nenum Identifier3 {}", 2, 0, "enum Identifier3 {}\n\nenum Identifier1 {}\n\nenum Identifier2 {}");
            });
            it("should change the order of the node moving middle to first", function () {
                doTest("enum Identifier1 {}\n\nenum Identifier2 {}\n\nenum Identifier3 {}", 1, 0, "enum Identifier2 {}\n\nenum Identifier1 {}\n\nenum Identifier3 {}");
            });
            it("should change the order of the node moving middle to last", function () {
                doTest("enum Identifier1 {}\n\nenum Identifier2 {}\n\nenum Identifier3 {}", 1, 2, "enum Identifier1 {}\n\nenum Identifier3 {}\n\nenum Identifier2 {}");
            });
            it("should change the order of the node moving the first middle node to be the second middle node", function () {
                doTest("enum Identifier1 {}\n\nenum Identifier2 {}\n\nenum Identifier3 {}\n\nenum Identifier4 {}", 1, 2, "enum Identifier1 {}\n\nenum Identifier3 {}\n\nenum Identifier2 {}\n\nenum Identifier4 {}");
            });
            it("should change the order of the node moving the second middle node to be the first middle node", function () {
                doTest("enum Identifier1 {}\n\nenum Identifier2 {}\n\nenum Identifier3 {}\n\nenum Identifier4 {}", 1, 2, "enum Identifier1 {}\n\nenum Identifier3 {}\n\nenum Identifier2 {}\n\nenum Identifier4 {}");
            });
            it("should change the order of the nodes when there's documentation going first to last", function () {
                doTest("/** Docs1 */\nenum Identifier1 {}\n/** Docs2 */\nenum Identifier2 {}", 0, 1, "/** Docs2 */\nenum Identifier2 {}\n\n/** Docs1 */\nenum Identifier1 {}");
            });
            it("should change the order of the nodes when there's documentation going last to first", function () {
                doTest("/** Docs1 */\nenum Identifier1 {}\n/** Docs2 */\nenum Identifier2 {}", 0, 1, "/** Docs2 */\nenum Identifier2 {}\n\n/** Docs1 */\nenum Identifier1 {}");
            });
        });
        describe("class member", function () {
            function doTest(startCode, oldIndex, newIndex, expectedCode) {
                var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
                sourceFile.getClasses()[0].getChildSyntaxListOrThrow().getChildren()[oldIndex].setOrder(newIndex);
                chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
            }
            it("should change the order of the members when there's two, moving first to last", function () {
                doTest("class C {\n    prop: string;\n\n    method() {}\n}", 0, 1, "class C {\n    method() {}\n\n    prop: string;\n}");
            });
            it("should change the order of the members when there's two, moving last to first", function () {
                doTest("class C {\n    prop: string;\n\n    method() {}\n}", 1, 0, "class C {\n    method() {}\n\n    prop: string;\n}");
            });
            it("should change the order of the members when there's multiple, moving first to last", function () {
                doTest("class C {\n    p1: string;\n\n    m2() {}\n\n    p3: number;\n}", 0, 2, "class C {\n    m2() {}\n\n    p3: number;\n    p1: string;\n}");
            });
            it("should change the order of the members when there's multiple, moving last to first", function () {
                doTest("class C {\n    p1: string;\n\n    m2() {}\n\n    p3: number;\n}", 2, 0, "class C {\n    p3: number;\n    p1: string;\n\n    m2() {}\n}");
            });
        });
        describe("interface member", function () {
            function doTest(startCode, oldIndex, newIndex, expectedCode) {
                var sourceFile = testHelpers_1.getInfoFromText(startCode).sourceFile;
                sourceFile.getInterfaces()[0].getChildSyntaxListOrThrow().getChildren()[oldIndex].setOrder(newIndex);
                chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
            }
            it("should change the order of the members when there's two, moving first to last", function () {
                doTest("interface I {\n    prop: string;\n    method(): void;\n}", 0, 1, "interface I {\n    method(): void;\n    prop: string;\n}");
            });
            it("should change the order of the members when there's two, moving last to first", function () {
                doTest("interface I {\n    prop: string;\n\n    method(): void;\n}", 1, 0, "interface I {\n    method(): void;\n    prop: string;\n}");
            });
            it("should change the order of the members when there's multiple, moving first to last", function () {
                doTest("interface I {\n    p1: string;\n\n    m2(): void;\n    p3: number;\n}", 0, 2, "interface I {\n    m2(): void;\n    p3: number;\n    p1: string;\n}");
            });
            it("should change the order of the members when there's multiple, moving last to first", function () {
                doTest("interface I {\n    p1: string;\n\n    m2(): void;\n    p3: number;\n}", 2, 0, "interface I {\n    p3: number;\n    p1: string;\n\n    m2(): void;\n}");
            });
        });
    });
});
