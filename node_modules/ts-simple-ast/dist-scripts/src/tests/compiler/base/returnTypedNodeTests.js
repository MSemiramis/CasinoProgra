"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testHelpers_1 = require("../testHelpers");
describe("ReturnTypedNode", function () {
    var mainSourceFile = testHelpers_1.getInfoFromText("function myImplicit() { return 5; }\nfunction myExplicit(): string { return ''; }").sourceFile;
    var implicitDeclaration = mainSourceFile.getFunctions()[0];
    var explicitDeclaration = mainSourceFile.getFunctions()[1];
    describe("getReturnType", function () {
        it("should get the expected implicit type", function () {
            chai_1.expect(implicitDeclaration.getReturnType().getText()).to.equal("number");
        });
        it("should get the expected explicit type", function () {
            chai_1.expect(explicitDeclaration.getReturnType().getText()).to.equal("string");
        });
    });
    describe("getReturnTypeNode", function () {
        it("should get the expected explicit type for an explicit type", function () {
            chai_1.expect(explicitDeclaration.getReturnTypeNode().getText()).to.equal("string");
        });
        it("should return undefined for an implicit type", function () {
            chai_1.expect(implicitDeclaration.getReturnTypeNode()).to.be.undefined;
        });
    });
    describe("getReturnTypeNodeOrThrow", function () {
        it("should get the expected explicit type for an explicit type", function () {
            chai_1.expect(explicitDeclaration.getReturnTypeNodeOrThrow().getText()).to.equal("string");
        });
        it("should throw for an implicit type", function () {
            chai_1.expect(function () { return implicitDeclaration.getReturnTypeNodeOrThrow(); }).to.throw();
        });
    });
    describe("setReturnType", function () {
        function doTest(startText, returnType, expectedText) {
            var firstChild = testHelpers_1.getInfoFromText(startText).firstChild;
            firstChild.setReturnType(returnType);
            chai_1.expect(firstChild.getText()).to.equal(expectedText);
        }
        it("should set the return type when none exists", function () {
            doTest("function identifier() {}", "string", "function identifier(): string {}");
        });
        it("should set the return type when one already exists", function () {
            doTest("function identifier(): number {}", "string", "function identifier(): string {}");
        });
        it("should set the return type for an ambient declaration with no return type", function () {
            doTest("declare function identifier();", "string", "declare function identifier(): string;");
        });
        it("should set the return type for an ambient declaration", function () {
            doTest("declare function identifier(): number;", "string", "declare function identifier(): string;");
        });
        it("should remove the type when it's empty", function () {
            doTest("function identifier(): string {}", "", "function identifier() {}");
        });
    });
    describe("removeReturnType", function () {
        function doTest(startText, expectedText) {
            var firstChild = testHelpers_1.getInfoFromText(startText).firstChild;
            firstChild.removeReturnType();
            chai_1.expect(firstChild.getText()).to.equal(expectedText);
        }
        it("should remove the type", function () {
            doTest("function identifier(): string {}", "function identifier() {}");
        });
        it("should not throw an error when the return type is already null", function () {
            doTest("function identifier() {}", "function identifier() {}");
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
        }
        it("should modify when setting", function () {
            doTest("function Identifier() {}", { returnType: "number" }, "function Identifier(): number {}");
        });
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("function Identifier() {}", {}, "function Identifier() {}");
        });
    });
});
