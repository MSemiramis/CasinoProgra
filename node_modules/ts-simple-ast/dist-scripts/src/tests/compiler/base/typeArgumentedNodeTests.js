"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testHelpers_1 = require("../testHelpers");
describe("TypeArgumentedNode", function () {
    describe("getTypeArguments", function () {
        function doTest(code, expectedArgs) {
            var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
            var args = firstChild.getDecorators()[0].getCallExpressionOrThrow().getTypeArguments();
            chai_1.expect(args.map(function (a) { return a.getText(); })).to.deep.equal(expectedArgs);
        }
        it("should get the type arguments when there are none", function () {
            doTest("@decorator()\nclass MyClass {}", []);
        });
        it("should get the type arguments when they exist", function () {
            doTest("@decorator<string, number, {}>(arg1, arg2)\nclass MyClass {}", ["string", "number", "{}"]);
        });
    });
    describe("insertTypeArguments", function () {
        function doTest(code, index, texts, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var callExpr = firstChild.getDecorators()[0].getCallExpressionOrThrow();
            var result = callExpr.insertTypeArguments(index, texts);
            chai_1.expect(result.map(function (t) { return t.getText(); })).to.deep.equal(texts);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert multiple type args when none exist", function () {
            doTest("@dec()\nclass T {}", 0, ["5", "6", "7"], "@dec<5, 6, 7>()\nclass T {}");
        });
        it("should insert multiple type args at the beginning", function () {
            doTest("@dec<3>()\nclass T {}", 0, ["1", "2"], "@dec<1, 2, 3>()\nclass T {}");
        });
        it("should insert multiple type args in the middle", function () {
            doTest("@dec<1, 4>()\nclass T {}", 1, ["2", "3"], "@dec<1, 2, 3, 4>()\nclass T {}");
        });
        it("should insert multiple type args at the end", function () {
            doTest("@dec<1>()\nclass T {}", 1, ["2", "3"], "@dec<1, 2, 3>()\nclass T {}");
        });
    });
    describe("insertTypeArgument", function () {
        function doTest(code, index, text, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var callExpr = firstChild.getDecorators()[0].getCallExpressionOrThrow();
            var result = callExpr.insertTypeArgument(index, text);
            chai_1.expect(result.getText()).to.equal(text);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert a type arg", function () {
            doTest("@dec<1, 3>()\nclass T {}", 1, "2", "@dec<1, 2, 3>()\nclass T {}");
        });
    });
    describe("addTypeArguments", function () {
        function doTest(code, texts, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var callExpr = firstChild.getDecorators()[0].getCallExpressionOrThrow();
            var result = callExpr.addTypeArguments(texts);
            chai_1.expect(result.map(function (t) { return t.getText(); })).to.deep.equal(texts);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add multiple type args", function () {
            doTest("@dec<1>()\nclass T {}", ["2", "3"], "@dec<1, 2, 3>()\nclass T {}");
        });
    });
    describe("addTypeArgument", function () {
        function doTest(code, text, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var callExpr = firstChild.getDecorators()[0].getCallExpressionOrThrow();
            var result = callExpr.addTypeArgument(text);
            chai_1.expect(result.getText()).to.equal(text);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add a type arg", function () {
            doTest("@dec<1, 2>()\nclass T {}", "3", "@dec<1, 2, 3>()\nclass T {}");
        });
    });
    describe("removeTypeArgument", function () {
        it("should throw when there are no current type arguments", function () {
            var firstChild = testHelpers_1.getInfoFromText("@decorator(arg1, arg2)\nclass MyClass {}").firstChild;
            chai_1.expect(function () { return firstChild.getDecorators()[0].getCallExpression().removeTypeArgument(0); }).to.throw();
        });
        it("should throw when specifying an out of range index", function () {
            var firstChild = testHelpers_1.getInfoFromText("@decorator<MyClass>(arg1, arg2)\nclass MyClass {}").firstChild;
            chai_1.expect(function () { return firstChild.getDecorators()[0].getCallExpression().removeTypeArgument(1); }).to.throw();
        });
        describe("index", function () {
            function doTest(code, argIndexToRemove, expectedText) {
                var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.getDecorators()[0].getCallExpression().removeTypeArgument(argIndexToRemove);
                chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            }
            it("should remove when the only type argument", function () {
                doTest("@decorator<MyClass>(arg1, arg2)\nclass MyClass {}", 0, "@decorator(arg1, arg2)\nclass MyClass {}");
            });
            it("should remove the first type argument", function () {
                doTest("@decorator<string, number, {}>(arg1, arg2)\nclass MyClass {}", 0, "@decorator<number, {}>(arg1, arg2)\nclass MyClass {}");
            });
            it("should remove the middle type argument", function () {
                doTest("@decorator<string, number, {}>(arg1, arg2)\nclass MyClass {}", 1, "@decorator<string, {}>(arg1, arg2)\nclass MyClass {}");
            });
            it("should remove the last type argument", function () {
                doTest("@decorator<string, number, {}>(arg1, arg2)\nclass MyClass {}", 2, "@decorator<string, number>(arg1, arg2)\nclass MyClass {}");
            });
        });
        describe("element", function () {
            function doTest(code, argIndexToRemove, expectedText) {
                var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                var callExpr = firstChild.getDecorators()[0].getCallExpression();
                callExpr.removeTypeArgument(callExpr.getTypeArguments()[argIndexToRemove]);
                chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
            }
            it("should remove the specified type argument", function () {
                doTest("@decorator<string, number, {}>(arg1, arg2)\nclass MyClass {}", 1, "@decorator<string, {}>(arg1, arg2)\nclass MyClass {}");
            });
        });
    });
});
