"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testHelpers_1 = require("../testHelpers");
describe("ImplementsClauseableNode", function () {
    describe("getImplements", function () {
        it("should return an empty array when they don't exist", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier {}").firstChild;
            var implementsExpressions = firstChild.getImplements();
            chai_1.expect(implementsExpressions.length).to.equal(0);
        });
        it("should return an empty array when they don't exist, but an extends does", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier extends Base {}").firstChild;
            var implementsExpressions = firstChild.getImplements();
            chai_1.expect(implementsExpressions.length).to.equal(0);
        });
        it("should get all the implements expressions when they exist", function () {
            var firstChild = testHelpers_1.getInfoFromText("class Identifier extends Base implements IBase, IBase2 {}").firstChild;
            var implementsExpressions = firstChild.getImplements();
            chai_1.expect(implementsExpressions.length).to.equal(2);
        });
    });
    describe("addImplements", function () {
        function doTest(code, implementsTextOrArray, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            if (implementsTextOrArray instanceof Array) {
                var result = firstChild.addImplements(implementsTextOrArray);
                chai_1.expect(result.length).to.equal(implementsTextOrArray.length);
            }
            else {
                var result = firstChild.addImplements(implementsTextOrArray);
                chai_1.expect(result).to.not.be.instanceOf(Array).and.to.be.not.undefined;
            }
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add an implements", function () {
            doTest("  class Identifier {}  ", "Base", "  class Identifier implements Base {}  ");
        });
        it("should add an implements when the brace is right beside the identifier", function () {
            doTest("  class Identifier{}  ", "Base", "  class Identifier implements Base {}  ");
        });
        it("should add an implements when an implements already exists", function () {
            doTest("class Identifier implements Base1 {}", "Base2", "class Identifier implements Base1, Base2 {}");
        });
        it("should add multiple implements", function () {
            doTest("class Identifier implements Base1 {}", ["Base2", "Base3"], "class Identifier implements Base1, Base2, Base3 {}");
        });
        it("should do nothing if an empty array", function () {
            doTest("class Identifier {}", [], "class Identifier {}");
        });
        it("should throw an error when providing invalid input", function () {
            var _a = testHelpers_1.getInfoFromText("class Identifier implements Base1 {}"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            chai_1.expect(function () { return firstChild.addImplements(""); }).to.throw();
            chai_1.expect(function () { return firstChild.addImplements("  "); }).to.throw();
            chai_1.expect(function () { return firstChild.addImplements(5); }).to.throw();
        });
    });
    describe("insertImplements", function () {
        function doTest(code, index, implementsTextOrArray, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            if (implementsTextOrArray instanceof Array) {
                var result = firstChild.insertImplements(index, implementsTextOrArray);
                chai_1.expect(result.length).to.equal(implementsTextOrArray.length);
            }
            else {
                var result = firstChild.insertImplements(index, implementsTextOrArray);
                chai_1.expect(result).to.not.be.instanceOf(Array).and.to.be.not.undefined;
            }
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        // mosts of the tests for this are already in addImplements
        it("should insert an implements at a position", function () {
            doTest("class Identifier implements Base, Base1 {}", 1, "Base2", "class Identifier implements Base, Base2, Base1 {}");
        });
        it("should insert multiple implements at a position", function () {
            doTest("class Identifier implements Base, Base1 {}", 1, ["Base2", "Base3"], "class Identifier implements Base, Base2, Base3, Base1 {}");
        });
    });
    describe("removeImplements", function () {
        function doTest(startingCode, index, expectedCode) {
            doIndexTest();
            doNodeTest();
            function doIndexTest() {
                var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.removeImplements(index);
                chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            }
            function doNodeTest() {
                var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.removeImplements(firstChild.getImplements()[index]);
                chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            }
        }
        it("should throw when trying to remove and none exist", function () {
            var _a = testHelpers_1.getInfoFromText("class C {}"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            chai_1.expect(function () { return firstChild.removeImplements(0); }).to.throw();
        });
        it("should throw when specifying a bad index", function () {
            var _a = testHelpers_1.getInfoFromText("class C implements B {}"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            chai_1.expect(function () { return firstChild.removeImplements(1); }).to.throw();
        });
        it("should remove the implements when there is one", function () {
            doTest("class MyClass implements T1 {}", 0, "class MyClass {}");
        });
        it("should remove the implements when there is one and an extends exists", function () {
            doTest("class MyClass extends B implements T1 {}", 0, "class MyClass extends B {}");
        });
        it("should remove the implements when there are multiple and the first is specified", function () {
            doTest("class MyClass implements T1, T2 {}", 0, "class MyClass implements T2 {}");
        });
        it("should remove the implements when there are multiple and the middle is specified", function () {
            doTest("class MyClass implements T1, T2, T3 {}", 1, "class MyClass implements T1, T3 {}");
        });
        it("should remove the implements when there are multiple and the last is specified", function () {
            doTest("class MyClass implements T1, T2 {}", 1, "class MyClass implements T1 {}");
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
        }
        it("should modify when setting one", function () {
            doTest("class MyClass {}", { implements: ["Test"] }, "class MyClass implements Test {}");
        });
        it("should modify when setting two", function () {
            doTest("class MyClass {}", { implements: ["Test", "Test2"] }, "class MyClass implements Test, Test2 {}");
        });
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("class MyClass {}", {}, "class MyClass {}");
        });
        it("should not modify anything if the structure has an empty array", function () {
            doTest("class MyClass {}", { implements: [] }, "class MyClass {}");
        });
    });
});
