"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var compiler_1 = require("../../../compiler");
var testHelpers_1 = require("../testHelpers");
describe("TypeElementMemberedNode", function () {
    describe("insertConstructSignatures", function () {
        function doTest(startCode, insertIndex, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertConstructSignatures(insertIndex, structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert when none exists", function () {
            doTest("interface i {\n}", 0, [{}], "interface i {\n    new();\n}");
        });
        it("should insert multiple into other", function () {
            doTest("interface i {\n    method1();\n    method2();\n}", 1, [{ returnType: "string" }, {}], "interface i {\n    method1();\n    new(): string;\n    new();\n    method2();\n}");
        });
    });
    describe("insertConstructSignature", function () {
        function doTest(startCode, insertIndex, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertConstructSignature(insertIndex, structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ConstructSignatureDeclaration);
        }
        it("should insert at index", function () {
            doTest("interface i {\n    method1();\n    method2();\n}", 1, {}, "interface i {\n    method1();\n    new();\n    method2();\n}");
        });
    });
    describe("addConstructSignatures", function () {
        function doTest(startCode, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addConstructSignatures(structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add multiple at end", function () {
            doTest("interface i {\n    method1();\n}", [{}, {}], "interface i {\n    method1();\n    new();\n    new();\n}");
        });
    });
    describe("addConstructSignature", function () {
        function doTest(startCode, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addConstructSignature(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.ConstructSignatureDeclaration);
        }
        it("should add at end", function () {
            doTest("interface i {\n    method1();\n}", {}, "interface i {\n    method1();\n    new();\n}");
        });
    });
    describe("getConstructSignatures", function () {
        describe("none", function () {
            it("should not have any", function () {
                var firstChild = testHelpers_1.getInfoFromText("interface Identifier {\n}\n").firstChild;
                chai_1.expect(firstChild.getConstructSignatures().length).to.equal(0);
            });
        });
        describe("has construct signatures", function () {
            var firstChild = testHelpers_1.getInfoFromText("interface Identifier {\n    prop: string;\n    new(): string;\n    method1():void;\n    method2():string;\n}\n").firstChild;
            it("should get the right number of construct signatures", function () {
                chai_1.expect(firstChild.getConstructSignatures().length).to.equal(1);
            });
            it("should get a construct signature of the right instance of", function () {
                chai_1.expect(firstChild.getConstructSignatures()[0]).to.be.instanceOf(compiler_1.ConstructSignatureDeclaration);
            });
        });
    });
    describe("getConstructSignature", function () {
        var firstChild = testHelpers_1.getInfoFromText("interface Identifier { new(): string; new(str: string): string; }").firstChild;
        it("should get the first that matches", function () {
            chai_1.expect(firstChild.getConstructSignature(function (c) { return c.getParameters().length > 0; })).to.equal(firstChild.getConstructSignatures()[1]);
        });
        it("should return undefined when none match", function () {
            chai_1.expect(firstChild.getConstructSignature(function (c) { return c.getParameters().length > 5; })).to.be.undefined;
        });
    });
    describe("getConstructSignatureOrThrow", function () {
        var firstChild = testHelpers_1.getInfoFromText("interface Identifier { new(): string; new(str: string): string; }").firstChild;
        it("should get the first that matches", function () {
            chai_1.expect(firstChild.getConstructSignatureOrThrow(function (c) { return c.getParameters().length > 0; })).to.equal(firstChild.getConstructSignatures()[1]);
        });
        it("should throw when none match", function () {
            chai_1.expect(function () { return firstChild.getConstructSignatureOrThrow(function (c) { return c.getParameters().length > 5; }); }).to.throw();
        });
    });
    describe("insertIndexSignatures", function () {
        function doTest(startCode, insertIndex, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertIndexSignatures(insertIndex, structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert when none exists", function () {
            doTest("interface i {\n}", 0, [{ returnType: "number" }], "interface i {\n    [key: string]: number;\n}");
        });
        it("should insert multiple into other", function () {
            doTest("interface i {\n    method1();\n    method2();\n}", 1, [{ returnType: "number" }, { keyName: "key2", keyType: "number", returnType: "Date" }], "interface i {\n    method1();\n    [key: string]: number;\n    [key2: number]: Date;\n    method2();\n}");
        });
    });
    describe("insertIndexSignature", function () {
        function doTest(startCode, insertIndex, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertIndexSignature(insertIndex, structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.IndexSignatureDeclaration);
        }
        it("should insert at index", function () {
            doTest("interface i {\n    method1();\n    method2();\n}", 1, { returnType: "Date" }, "interface i {\n    method1();\n    [key: string]: Date;\n    method2();\n}");
        });
    });
    describe("addIndexSignatures", function () {
        function doTest(startCode, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addIndexSignatures(structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add multiple at end", function () {
            doTest("interface i {\n    method1();\n}", [{ returnType: "string" }, { returnType: "Date" }], "interface i {\n    method1();\n    [key: string]: string;\n    [key: string]: Date;\n}");
        });
    });
    describe("addIndexSignature", function () {
        function doTest(startCode, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addIndexSignature(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.IndexSignatureDeclaration);
        }
        it("should add at end", function () {
            doTest("interface i {\n    method1();\n}", { returnType: "string" }, "interface i {\n    method1();\n    [key: string]: string;\n}");
        });
    });
    describe("getIndexSignatures", function () {
        describe("none", function () {
            it("should not have any", function () {
                var firstChild = testHelpers_1.getInfoFromText("interface Identifier {\n}\n").firstChild;
                chai_1.expect(firstChild.getIndexSignatures().length).to.equal(0);
            });
        });
        describe("has index signatures", function () {
            var text = "interface Identifier {\n    prop: string;\n    [key: string]: string;\n    method1():void;\n    method2():string;\n}\n";
            var firstChild = testHelpers_1.getInfoFromText(text).firstChild;
            it("should get the right number of index signatures", function () {
                chai_1.expect(firstChild.getIndexSignatures().length).to.equal(1);
            });
            it("should get a construct signature of the right instance of", function () {
                chai_1.expect(firstChild.getIndexSignatures()[0]).to.be.instanceOf(compiler_1.IndexSignatureDeclaration);
            });
        });
    });
    describe("getIndexSignature", function () {
        var firstChild = testHelpers_1.getInfoFromText("interface Identifier { [key: string]: string; [key2: string]: Date; }").firstChild;
        it("should get the first that matches", function () {
            chai_1.expect(firstChild.getIndexSignature(function (c) { return c.getKeyName() === "key2"; })).to.equal(firstChild.getIndexSignatures()[1]);
        });
        it("should return undefined when none match", function () {
            chai_1.expect(firstChild.getIndexSignature(function (c) { return c.getKeyName() === "other"; })).to.be.undefined;
        });
    });
    describe("getIndexSignatureOrThrow", function () {
        var firstChild = testHelpers_1.getInfoFromText("interface Identifier { [key: string]: string; [key2: string]: Date; }").firstChild;
        it("should get the first that matches", function () {
            chai_1.expect(firstChild.getIndexSignatureOrThrow(function (c) { return c.getKeyName() === "key2"; })).to.equal(firstChild.getIndexSignatures()[1]);
        });
        it("should throw when none match", function () {
            chai_1.expect(function () { return firstChild.getIndexSignatureOrThrow(function (c) { return c.getKeyName() === "other"; }); }).to.throw();
        });
    });
    describe("insertCallSignatures", function () {
        function doTest(startCode, insertIndex, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertCallSignatures(insertIndex, structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert when none exists", function () {
            doTest("interface i {\n}", 0, [{}], "interface i {\n    (): void;\n}");
        });
        it("should insert multiple into other", function () {
            doTest("interface i {\n    method1();\n    method2();\n}", 1, [{ returnType: "string" }, {}], "interface i {\n    method1();\n    (): string;\n    (): void;\n    method2();\n}");
        });
        it("should insert when the structure has everything", function () {
            var structure = {
                docs: [{ description: "Test" }],
                parameters: [{ name: "param" }],
                returnType: "T",
                typeParameters: [{ name: "T" }]
            };
            doTest("interface i {\n}", 0, [structure], "interface i {\n    /**\n     * Test\n     */\n    <T>(param): T;\n}");
        });
    });
    describe("insertCallSignature", function () {
        function doTest(startCode, insertIndex, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertCallSignature(insertIndex, structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.CallSignatureDeclaration);
        }
        it("should insert at index", function () {
            doTest("interface i {\n    method1();\n    method2();\n}", 1, {}, "interface i {\n    method1();\n    (): void;\n    method2();\n}");
        });
    });
    describe("addCallSignatures", function () {
        function doTest(startCode, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addCallSignatures(structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add multiple at end", function () {
            doTest("interface i {\n    method1();\n}", [{}, {}], "interface i {\n    method1();\n    (): void;\n    (): void;\n}");
        });
    });
    describe("addCallSignature", function () {
        function doTest(startCode, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addCallSignature(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.CallSignatureDeclaration);
        }
        it("should add at end", function () {
            doTest("interface i {\n    method1();\n}", {}, "interface i {\n    method1();\n    (): void;\n}");
        });
    });
    describe("getCallSignatures", function () {
        describe("none", function () {
            it("should not have any", function () {
                var firstChild = testHelpers_1.getInfoFromText("interface Identifier {\n}\n").firstChild;
                chai_1.expect(firstChild.getCallSignatures().length).to.equal(0);
            });
        });
        describe("has call signatures", function () {
            var code = "interface Identifier {\n    prop: string;\n    new(): string;\n    (): number;\n    method1():void;\n    method2():string;\n}\n";
            var firstChild = testHelpers_1.getInfoFromText(code).firstChild;
            it("should get the right number of call signatures", function () {
                chai_1.expect(firstChild.getCallSignatures().length).to.equal(1);
            });
            it("should get a call signature of the right instance of", function () {
                chai_1.expect(firstChild.getCallSignatures()[0]).to.be.instanceOf(compiler_1.CallSignatureDeclaration);
            });
        });
    });
    describe("getCallSignature", function () {
        var firstChild = testHelpers_1.getInfoFromText("interface Identifier { (): string; (str: string): string; }").firstChild;
        it("should get the first that matches", function () {
            chai_1.expect(firstChild.getCallSignature(function (c) { return c.getParameters().length > 0; })).to.equal(firstChild.getCallSignatures()[1]);
        });
        it("should return undefined when none match", function () {
            chai_1.expect(firstChild.getCallSignature(function (c) { return c.getParameters().length > 5; })).to.be.undefined;
        });
    });
    describe("getCallSignatureOrThrow", function () {
        var firstChild = testHelpers_1.getInfoFromText("interface Identifier { (): string; (str: string): string; }").firstChild;
        it("should get the first that matches", function () {
            chai_1.expect(firstChild.getCallSignatureOrThrow(function (c) { return c.getParameters().length > 0; })).to.equal(firstChild.getCallSignatures()[1]);
        });
        it("should throw when none match", function () {
            chai_1.expect(function () { return firstChild.getCallSignatureOrThrow(function (c) { return c.getParameters().length > 5; }); }).to.throw();
        });
    });
    describe("insertMethods", function () {
        function doTest(startCode, insertIndex, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertMethods(insertIndex, structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert when none exists", function () {
            doTest("interface i {\n}", 0, [{ name: "method" }], "interface i {\n    method();\n}");
        });
        it("should insert multiple into other methods", function () {
            doTest("interface i {\n    method1();\n    method4();\n}", 1, [{ name: "method2", hasQuestionToken: true, returnType: "string" }, { name: "method3" }], "interface i {\n    method1();\n    method2?(): string;\n    method3();\n    method4();\n}");
        });
    });
    describe("insertMethod", function () {
        function doTest(startCode, insertIndex, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertMethod(insertIndex, structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.MethodSignature);
        }
        it("should insert at index", function () {
            doTest("interface i {\n    method1();\n    method3();\n}", 1, { name: "method2" }, "interface i {\n    method1();\n    method2();\n    method3();\n}");
        });
    });
    describe("addMethods", function () {
        function doTest(startCode, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addMethods(structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add multiple at end", function () {
            doTest("interface i {\n    method1();\n}", [{ name: "method2" }, { name: "method3" }], "interface i {\n    method1();\n    method2();\n    method3();\n}");
        });
    });
    describe("addMethod", function () {
        function doTest(startCode, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addMethod(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.MethodSignature);
        }
        it("should add at end", function () {
            doTest("interface i {\n    method1();\n}", { name: "method2" }, "interface i {\n    method1();\n    method2();\n}");
        });
    });
    describe("getMethod", function () {
        var firstChild = testHelpers_1.getInfoFromText("interface Identifier { method1(); method2(); method3(); }").firstChild;
        it("should get the first that matches by name", function () {
            chai_1.expect(firstChild.getMethod("method2").getName()).to.equal("method2");
        });
        it("should return the first that matches by a find function", function () {
            chai_1.expect(firstChild.getMethod(function (m) { return m.getName() === "method3"; }).getName()).to.equal("method3");
        });
        it("should return undefined when none match", function () {
            chai_1.expect(firstChild.getMethod(function (m) { return m.getParameters().length > 5; })).to.be.undefined;
        });
    });
    describe("getMethodOrThrow", function () {
        var firstChild = testHelpers_1.getInfoFromText("interface Identifier { method1(); method2(); method3(); }").firstChild;
        it("should get the first that matches by name", function () {
            chai_1.expect(firstChild.getMethodOrThrow("method2").getName()).to.equal("method2");
        });
        it("should return the first that matches by a find function", function () {
            chai_1.expect(firstChild.getMethodOrThrow(function (m) { return m.getName() === "method3"; }).getName()).to.equal("method3");
        });
        it("should throw when none match", function () {
            chai_1.expect(function () { return firstChild.getMethodOrThrow(function (m) { return m.getParameters().length > 5; }); }).to.throw();
        });
    });
    describe("getMethods", function () {
        describe("no methods", function () {
            it("should not have any methods", function () {
                var firstChild = testHelpers_1.getInfoFromText("interface Identifier {\n}\n").firstChild;
                chai_1.expect(firstChild.getMethods().length).to.equal(0);
            });
        });
        describe("has methods", function () {
            var firstChild = testHelpers_1.getInfoFromText("interface Identifier {\n    prop: string;\n    method1():void;\n    method2():string;\n}\n").firstChild;
            it("should get the right number of methods", function () {
                chai_1.expect(firstChild.getMethods().length).to.equal(2);
            });
            it("should get a method of the right instance of", function () {
                chai_1.expect(firstChild.getMethods()[0]).to.be.instanceOf(compiler_1.MethodSignature);
            });
        });
    });
    describe("insertProperties", function () {
        function doTest(startCode, insertIndex, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertProperties(insertIndex, structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert when none exists", function () {
            doTest("interface i {\n}", 0, [{ name: "prop" }], "interface i {\n    prop;\n}");
        });
        it("should insert multiple into other properties", function () {
            doTest("interface i {\n    prop1;\n    prop4;\n}", 1, [{ name: "prop2", hasQuestionToken: true, type: "string" }, { name: "prop3" }], "interface i {\n    prop1;\n    prop2?: string;\n    prop3;\n    prop4;\n}");
        });
    });
    describe("insertProperty", function () {
        function doTest(startCode, insertIndex, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertProperty(insertIndex, structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.PropertySignature);
        }
        it("should insert at index", function () {
            doTest("interface i {\n    prop1;\n    prop3;\n}", 1, { name: "prop2" }, "interface i {\n    prop1;\n    prop2;\n    prop3;\n}");
        });
    });
    describe("addProperties", function () {
        function doTest(startCode, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addProperties(structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add multiple at end", function () {
            doTest("interface i {\n    prop1;\n}", [{ name: "prop2" }, { name: "prop3" }], "interface i {\n    prop1;\n    prop2;\n    prop3;\n}");
        });
    });
    describe("addProperty", function () {
        function doTest(startCode, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addProperty(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceOf(compiler_1.PropertySignature);
        }
        it("should add at end", function () {
            doTest("interface i {\n    prop1;\n}", { name: "prop2" }, "interface i {\n    prop1;\n    prop2;\n}");
        });
    });
    describe("getProperty", function () {
        var firstChild = testHelpers_1.getInfoFromText("interface Identifier { prop1: string; prop2: number; prop3: Date; }").firstChild;
        it("should get the first that matches by name", function () {
            chai_1.expect(firstChild.getProperty("prop2").getName()).to.equal("prop2");
        });
        it("should return the first that matches by a find function", function () {
            chai_1.expect(firstChild.getProperty(function (p) { return p.getName() === "prop3"; }).getName()).to.equal("prop3");
        });
        it("should return undefined when none match", function () {
            chai_1.expect(firstChild.getProperty(function (p) { return p.getName() === "none"; })).to.be.undefined;
        });
    });
    describe("getPropertyOrThrow", function () {
        var firstChild = testHelpers_1.getInfoFromText("interface Identifier { prop1: string; prop2: number; prop3: Date; }").firstChild;
        it("should get the first that matches by name", function () {
            chai_1.expect(firstChild.getPropertyOrThrow("prop2").getName()).to.equal("prop2");
        });
        it("should return the first that matches by a find function", function () {
            chai_1.expect(firstChild.getPropertyOrThrow(function (p) { return p.getName() === "prop3"; }).getName()).to.equal("prop3");
        });
        it("should throw when none match", function () {
            chai_1.expect(function () { return firstChild.getPropertyOrThrow(function (p) { return p.getName() === "none"; }); }).to.throw();
        });
    });
    describe("getProperties", function () {
        describe("no properties", function () {
            it("should not have any properties", function () {
                var firstChild = testHelpers_1.getInfoFromText("interface Identifier {\n}\n").firstChild;
                chai_1.expect(firstChild.getProperties().length).to.equal(0);
            });
        });
        describe("has properties", function () {
            var firstChild = testHelpers_1.getInfoFromText("interface Identifier {\nprop: string;\nprop2: number;method1(): void;\n}\n").firstChild;
            it("should get the right number of properties", function () {
                chai_1.expect(firstChild.getProperties().length).to.equal(2);
            });
            it("should get a property of the right instance of", function () {
                chai_1.expect(firstChild.getProperties()[0]).to.be.instanceOf(compiler_1.PropertySignature);
            });
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
        }
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("interface Identifier {\n}", {}, "interface Identifier {\n}");
        });
        it("should modify when changed", function () {
            var structure = {
                callSignatures: [{ returnType: "string" }],
                constructSignatures: [{ returnType: "string" }],
                indexSignatures: [{ keyName: "key", keyType: "string", returnType: "number" }],
                properties: [{ name: "p" }],
                methods: [{ name: "m" }]
            };
            doTest("interface Identifier {\n}", structure, "interface Identifier {\n    (): string;\n    new(): string;\n    [key: string]: number;\n    p;\n    m();\n}");
        });
    });
});
