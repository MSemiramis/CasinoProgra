"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var typescript_1 = require("../../../typescript");
var compiler_1 = require("../../../compiler");
var testHelpers_1 = require("../testHelpers");
describe("JSDocableNode", function () {
    describe("VariableStatement", function () {
        var sourceFile = testHelpers_1.getInfoFromText("/** Text */\nvar docedComment;\n/** First */\n/** Second */var multiCommented;\nvar nonDocedComment;").sourceFile;
        var statements = sourceFile.getVariableStatements();
        var docedStatement = statements[0];
        var multiDocedStatement = statements[1];
        var nonDocedStatement = statements[2];
        describe("getJsDocs", function () {
            describe("documentationed node", function () {
                var nodes = docedStatement.getJsDocs();
                it("should have the right number of nodes", function () {
                    chai_1.expect(nodes.length).to.equal(1);
                });
                it("should have the right node", function () {
                    chai_1.expect(nodes[0].getText()).to.equal("/** Text */");
                });
                it("should have the right node kind", function () {
                    chai_1.expect(nodes[0].getKind()).to.equal(typescript_1.SyntaxKind.JSDocComment);
                });
            });
            describe("multi documentationed node", function () {
                it("should have the right number of nodes", function () {
                    chai_1.expect(multiDocedStatement.getJsDocs().length).to.equal(2);
                });
            });
            describe("not documentationed node", function () {
                it("should not have any doc comment nodes", function () {
                    chai_1.expect(nonDocedStatement.getJsDocs().length).to.equal(0);
                });
            });
        });
    });
    describe("FunctionDeclaration", function () {
        var firstChild = testHelpers_1.getInfoFromText("/**\n * Test.\n * @name - Test\n */\nfunction myFunction(name: string) {}").firstChild;
        var doc = firstChild.getJsDocs()[0];
        it("should have the right node kind", function () {
            chai_1.expect(doc.getKind()).to.equal(typescript_1.SyntaxKind.JSDocComment);
        });
    });
    describe("insertJsDocs", function () {
        function doTest(startCode, insertIndex, structures, expectedCode, syntaxKind) {
            if (syntaxKind === void 0) { syntaxKind = typescript_1.SyntaxKind.FunctionDeclaration; }
            var _a = testHelpers_1.getInfoFromTextWithDescendant(startCode, syntaxKind), descendant = _a.descendant, sourceFile = _a.sourceFile;
            var result = descendant.insertJsDocs(insertIndex, structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert when none exist", function () {
            doTest("function identifier() {}", 0, [{ description: "Description" }], "/**\n * Description\n */\nfunction identifier() {}");
        });
        it("should insert at start when indentation is different", function () {
            doTest("namespace N {\n    /**\n     * Desc2\n     */\n    function identifier() {}\n}", 0, [{ description: "Desc1" }], "namespace N {\n    /**\n     * Desc1\n     */\n    /**\n     * Desc2\n     */\n    function identifier() {}\n}");
        });
        it("should insert multiple at end", function () {
            doTest("/**\n * Desc1\n */\nfunction identifier() {}", 1, [{ description: "Desc2" }, { description: "Desc3" }], "/**\n * Desc1\n */\n/**\n * Desc2\n */\n/**\n * Desc3\n */\nfunction identifier() {}");
        });
        it("should insert in the middle", function () {
            doTest("/**\n * Desc1\n */\n/**\n * Desc3\n */\nfunction identifier() {}", 1, [{ description: "Desc2" }], "/**\n * Desc1\n */\n/**\n * Desc2\n */\n/**\n * Desc3\n */\nfunction identifier() {}");
        });
        it("should do nothing if empty array", function () {
            doTest("function identifier() {}", 0, [], "function identifier() {}");
        });
        describe("PropertyDeclaration", function () {
            it("should add a js doc to a property declaration", function () {
                doTest("class C {\n    prop;\n}", 0, [{ description: "Testing" }], "class C {\n    /**\n     * Testing\n     */\n    prop;\n}", typescript_1.SyntaxKind.PropertyDeclaration);
            });
        });
    });
    describe("insertJsDoc", function () {
        function doTest(startCode, index, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.insertJsDoc(index, structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.Node);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should insert", function () {
            doTest("/**\n * Desc2\n */\nfunction identifier() {}", 0, { description: "Desc1" }, "/**\n * Desc1\n */\n/**\n * Desc2\n */\nfunction identifier() {}");
        });
    });
    describe("addJsDocs", function () {
        function doTest(startCode, structures, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.addJsDocs(structures);
            chai_1.expect(result.length).to.equal(structures.length);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add multiple at end", function () {
            doTest("/**\n * Desc1\n */\nfunction identifier() {}", [{ description: "Desc2" }, { description: "Desc3" }], "/**\n * Desc1\n */\n/**\n * Desc2\n */\n/**\n * Desc3\n */\nfunction identifier() {}");
        });
    });
    describe("addJsDoc", function () {
        function doTest(startCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            var result = firstChild.addJsDoc(structure);
            chai_1.expect(result).to.be.instanceOf(compiler_1.Node);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add at the end", function () {
            doTest("/**\n * Desc1\n */\nfunction identifier() {}", { description: "Desc2" }, "/**\n * Desc1\n */\n/**\n * Desc2\n */\nfunction identifier() {}");
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure);
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should modify when setting", function () {
            doTest("class Identifier {}", { docs: [{ description: "Desc1" }, { description: "Desc2" }] }, "/**\n * Desc1\n */\n/**\n * Desc2\n */\nclass Identifier {}");
        });
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("class Identifier {}", {}, "class Identifier {}");
        });
    });
});
