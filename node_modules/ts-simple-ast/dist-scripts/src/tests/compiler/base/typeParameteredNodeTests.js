"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var typescript_1 = require("../../../typescript");
var compiler_1 = require("../../../compiler");
var testHelpers_1 = require("../testHelpers");
describe("TypeParameteredNode", function () {
    describe("getTypeParameter", function () {
        var firstChild = testHelpers_1.getInfoFromText("function func<T, U>(){}").firstChild;
        it("should get the type parameter by name", function () {
            chai_1.expect(firstChild.getTypeParameter("T").getName()).to.equal("T");
        });
        it("should get the type parameter by function", function () {
            chai_1.expect(firstChild.getTypeParameter(function (p) { return p.getName() === "U"; })).to.equal(firstChild.getTypeParameters()[1]);
        });
        it("should return undefined when it doesn't exist", function () {
            chai_1.expect(firstChild.getTypeParameter("typeParam")).to.be.undefined;
        });
    });
    describe("getTypeParameterOrThrow", function () {
        var firstChild = testHelpers_1.getInfoFromText("function func<T, U>(){}").firstChild;
        it("should get the type parameter by name", function () {
            chai_1.expect(firstChild.getTypeParameterOrThrow("T").getName()).to.equal("T");
        });
        it("should get the type parameter by function", function () {
            chai_1.expect(firstChild.getTypeParameterOrThrow(function (p) { return p.getName() === "U"; })).to.equal(firstChild.getTypeParameters()[1]);
        });
        it("should throw when it doesn't exist", function () {
            chai_1.expect(function () { return firstChild.getTypeParameterOrThrow("typeParam"); }).to.throw();
        });
    });
    describe("getTypeParameters", function () {
        var sourceFile = testHelpers_1.getInfoFromText("function noTypeParamsFunc() {}\n function typeParamsFunc<T, U>() {}").sourceFile;
        var noTypeParamsFunc = sourceFile.getFunctions()[0];
        var typeParamsFunc = sourceFile.getFunctions()[1];
        describe("having no type parameters", function () {
            it("should return an empty array", function () {
                chai_1.expect(noTypeParamsFunc.getTypeParameters().length).to.equal(0);
            });
        });
        describe("having type parameters", function () {
            it("should get the correct number of type parameters", function () {
                chai_1.expect(typeParamsFunc.getTypeParameters().length).to.equal(2);
            });
            it("should have the right instance of", function () {
                chai_1.expect(typeParamsFunc.getTypeParameters()[0]).to.be.instanceOf(compiler_1.TypeParameterDeclaration);
            });
        });
    });
    describe("addTypeParameter", function () {
        function doTest(startCode, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addTypeParameter(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceof(compiler_1.TypeParameterDeclaration);
        }
        it("should add when none exists", function () {
            doTest("function identifier() {}", { name: "T" }, "function identifier<T>() {}");
        });
        it("should add when one exists", function () {
            doTest("function identifier<T>() {}", { name: "U" }, "function identifier<T, U>() {}");
        });
    });
    describe("addTypeParameters", function () {
        function doTest(startCode, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.addTypeParameters(structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should add multiple", function () {
            doTest("function identifier<T>() {}", [{ name: "U" }, { name: "V" }], "function identifier<T, U, V>() {}");
        });
    });
    describe("insertTypeParameter", function () {
        it("should insert when none exists for a call signature declaration", function () {
            var startCode = "interface Identifier {\n    (): void;\n}\n";
            var _a = testHelpers_1.getInfoFromTextWithDescendant(startCode, typescript_1.SyntaxKind.CallSignature), descendant = _a.descendant, sourceFile = _a.sourceFile;
            descendant.insertTypeParameter(0, { name: "T" });
            chai_1.expect(sourceFile.getFullText()).to.equal("interface Identifier {\n    <T>(): void;\n}\n");
        });
        function doTest(startCode, insertIndex, structure, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertTypeParameter(insertIndex, structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result).to.be.instanceof(compiler_1.TypeParameterDeclaration);
        }
        it("should insert when none exists", function () {
            doTest("function identifier() {}", 0, { name: "T" }, "function identifier<T>() {}");
        });
        it("should insert at the start", function () {
            doTest("function identifier<T>() {}", 0, { name: "U" }, "function identifier<U, T>() {}");
        });
        it("should insert at the end", function () {
            doTest("function identifier<T>() {}", 1, { name: "U" }, "function identifier<T, U>() {}");
        });
        it("should insert in the middle", function () {
            doTest("function identifier<T, U>() {}", 1, { name: "V" }, "function identifier<T, V, U>() {}");
        });
        it("should insert with constraint", function () {
            doTest("function identifier<T, U>() {}", 1, { name: "V", constraint: "string" }, "function identifier<T, V extends string, U>() {}");
        });
    });
    describe("insertTypeParameters", function () {
        function doTest(startCode, insertIndex, structures, expectedCode) {
            var firstChild = testHelpers_1.getInfoFromText(startCode).firstChild;
            var result = firstChild.insertTypeParameters(insertIndex, structures);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            chai_1.expect(result.length).to.equal(structures.length);
        }
        it("should insert multiple", function () {
            doTest("function identifier<V>() {}", 0, [{ name: "T" }, { name: "U" }], "function identifier<T, U, V>() {}");
        });
        it("should do nothing if empty array", function () {
            doTest("function identifier() {}", 0, [], "function identifier() {}");
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
        }
        it("should modify when setting", function () {
            doTest("type myAlias = string;", { typeParameters: [{ name: "T" }] }, "type myAlias<T> = string;");
        });
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("type myAlias = string;", {}, "type myAlias = string;");
        });
    });
});
