"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var utils_1 = require("../../../utils");
var testHelpers_1 = require("../testHelpers");
describe("StaticableNode", function () {
    var mainSourceFile = testHelpers_1.getInfoFromText("class MyClass { static prop: string; prop2: string; }").sourceFile;
    var classDec = mainSourceFile.getClasses()[0];
    var staticProp = classDec.getStaticProperties()[0];
    var instanceProp = classDec.getInstanceProperties()[0];
    describe("isStatic", function () {
        it("should be static when static", function () {
            chai_1.expect(staticProp.isStatic()).to.be.true;
        });
        it("should not be static when not static", function () {
            chai_1.expect(instanceProp.isStatic()).to.be.false;
        });
    });
    describe("getStaticKeyword", function () {
        it("should have a static keyword when static", function () {
            chai_1.expect(staticProp.getStaticKeyword().getText()).to.equal("static");
        });
        it("should not have a static keyword when not static", function () {
            chai_1.expect(instanceProp.getStaticKeyword()).to.be.undefined;
        });
    });
    describe("getStaticKeywordOrThrow", function () {
        it("should have a static keyword when static", function () {
            chai_1.expect(staticProp.getStaticKeywordOrThrow().getText()).to.equal("static");
        });
        it("should throw when not static", function () {
            chai_1.expect(function () { return instanceProp.getStaticKeywordOrThrow(); }).to.throw();
        });
    });
    describe("setIsStatic", function () {
        it("should set as static when not static", function () {
            var _a = testHelpers_1.getInfoFromText("class MyClass { prop: string; }"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.getInstanceProperties()[0].setIsStatic(true);
            chai_1.expect(sourceFile.getText()).to.equal("class MyClass { static prop: string; }");
        });
        it("should set as not static when static", function () {
            var _a = testHelpers_1.getInfoFromText("class MyClass { static prop: string; }"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.getStaticProperties()[0].setIsStatic(false);
            chai_1.expect(sourceFile.getText()).to.equal("class MyClass { prop: string; }");
        });
    });
    describe("fill", function () {
        function getFirstMethod(code) {
            var result = testHelpers_1.getInfoFromText(code);
            var firstMethod = result.firstChild.getMembers().filter(function (m) { return utils_1.TypeGuards.isMethodDeclaration(m); })[0];
            return __assign({ firstMethod: firstMethod }, result);
        }
        function doTest(startCode, structure, expectedCode) {
            var _a = getFirstMethod(startCode), firstMethod = _a.firstMethod, sourceFile = _a.sourceFile;
            firstMethod.fill(structure);
            chai_1.expect(sourceFile.getText()).to.equal(expectedCode);
        }
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("class MyClass { method() {} }", {}, "class MyClass { method() {} }");
        });
        it("should not modify anything if the structure doesn't change anything and the node has everything set", function () {
            doTest("class MyClass { static method() {} }", {}, "class MyClass { static method() {} }");
        });
        it("should modify when setting as has declare keyword", function () {
            doTest("class MyClass { method() {} }", { isStatic: true }, "class MyClass { static method() {} }");
        });
    });
});
