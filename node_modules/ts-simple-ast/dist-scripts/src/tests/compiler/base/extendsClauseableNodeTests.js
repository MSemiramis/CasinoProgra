"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var testHelpers_1 = require("../testHelpers");
describe("ExtendsClauseableNode", function () {
    describe("getExtends", function () {
        function doTest(text, expectedLength) {
            var firstChild = testHelpers_1.getInfoFromText(text).firstChild;
            var extendsExpressions = firstChild.getExtends();
            chai_1.expect(extendsExpressions.length).to.equal(expectedLength);
        }
        it("should return an empty array when they don't exist", function () {
            doTest("export interface Identifier {}", 0);
        });
        it("should get all the extends expressions when they exist", function () {
            doTest("export interface Identifier extends Base, Base2 {}", 2);
        });
    });
    describe("addExtends", function () {
        function doTest(code, extendsTextOrArray, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            if (extendsTextOrArray instanceof Array) {
                var result = firstChild.addExtends(extendsTextOrArray);
                chai_1.expect(result.length).to.equal(extendsTextOrArray.length);
            }
            else {
                var result = firstChild.addExtends(extendsTextOrArray);
                chai_1.expect(result).to.not.be.instanceOf(Array).and.to.be.not.undefined;
            }
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        it("should add an extends", function () {
            doTest("  interface Identifier {}  ", "Base", "  interface Identifier extends Base {}  ");
        });
        it("should add an extends when the brace is right beside the identifier", function () {
            doTest("  interface Identifier{}  ", "Base", "  interface Identifier extends Base {}  ");
        });
        it("should add an extends when an extends already exists", function () {
            doTest("interface Identifier extends Base1 {}", "Base2", "interface Identifier extends Base1, Base2 {}");
        });
        it("should add multiple extends", function () {
            doTest("interface Identifier {}", ["Base", "Base2"], "interface Identifier extends Base, Base2 {}");
        });
        it("should do nothing if an empty array", function () {
            doTest("interface Identifier {}", [], "interface Identifier {}");
        });
        it("should throw an error when providing invalid input", function () {
            var _a = testHelpers_1.getInfoFromText("interface Identifier extends Base1 {}"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            chai_1.expect(function () { return firstChild.addExtends(""); }).to.throw();
            chai_1.expect(function () { return firstChild.addExtends("  "); }).to.throw();
            chai_1.expect(function () { return firstChild.addExtends(5); }).to.throw();
        });
    });
    describe("insertExtends", function () {
        function doTest(code, index, extendsTextOrArray, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(code), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            if (extendsTextOrArray instanceof Array) {
                var result = firstChild.insertExtends(index, extendsTextOrArray);
                chai_1.expect(result.length).to.equal(extendsTextOrArray.length);
            }
            else {
                var result = firstChild.insertExtends(index, extendsTextOrArray);
                chai_1.expect(result).to.not.be.instanceOf(Array).and.to.be.not.undefined;
            }
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedCode);
        }
        // mosts of the tests for this are already in addExtends
        it("should insert an extends at a position", function () {
            doTest("interface Identifier extends Base, Base1 {}", 1, "Base2", "interface Identifier extends Base, Base2, Base1 {}");
        });
        it("should insert multiple extends at a position", function () {
            doTest("interface Identifier extends Base, Base1 {}", 1, ["Base2", "Base3"], "interface Identifier extends Base, Base2, Base3, Base1 {}");
        });
    });
    describe("removeExtends", function () {
        function doTest(startingCode, index, expectedCode) {
            doIndexTest();
            doNodeTest();
            function doIndexTest() {
                var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.removeExtends(index);
                chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            }
            function doNodeTest() {
                var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
                firstChild.removeExtends(firstChild.getExtends()[index]);
                chai_1.expect(firstChild.getText()).to.equal(expectedCode);
            }
        }
        it("should throw when trying to remove and none exist", function () {
            var _a = testHelpers_1.getInfoFromText("interface C {}"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            chai_1.expect(function () { return firstChild.removeExtends(0); }).to.throw();
        });
        it("should throw when specifying a bad index", function () {
            var _a = testHelpers_1.getInfoFromText("interface C extends B {}"), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            chai_1.expect(function () { return firstChild.removeExtends(1); }).to.throw();
        });
        it("should remove the extends when there is one", function () {
            doTest("interface Identifier extends T1 {}", 0, "interface Identifier {}");
        });
        it("should remove the extends when there are multiple and the first is specified", function () {
            doTest("interface Identifier extends T1, T2 {}", 0, "interface Identifier extends T2 {}");
        });
        it("should remove the extends when there are multiple and the middle is specified", function () {
            doTest("interface Identifier extends T1, T2, T3 {}", 1, "interface Identifier extends T1, T3 {}");
        });
        it("should remove the extends when there are multiple and the last is specified", function () {
            doTest("interface Identifier extends T1, T2 {}", 1, "interface Identifier extends T1 {}");
        });
    });
    describe("fill", function () {
        function doTest(startingCode, structure, expectedCode) {
            var _a = testHelpers_1.getInfoFromText(startingCode), firstChild = _a.firstChild, sourceFile = _a.sourceFile;
            firstChild.fill(structure);
            chai_1.expect(firstChild.getText()).to.equal(expectedCode);
        }
        it("should modify when setting one", function () {
            doTest("interface Identifier {}", { extends: ["Test"] }, "interface Identifier extends Test {}");
        });
        it("should modify when setting two", function () {
            doTest("interface Identifier {}", { extends: ["Test", "Test2"] }, "interface Identifier extends Test, Test2 {}");
        });
        it("should not modify anything if the structure doesn't change anything", function () {
            doTest("interface Identifier {}", {}, "interface Identifier {}");
        });
        it("should not modify anything if the structure has an empty array", function () {
            doTest("interface Identifier {}", { extends: [] }, "interface Identifier {}");
        });
    });
});
