"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var fileSystem_1 = require("../../fileSystem");
var utils_1 = require("../../utils");
var errors = require("../../errors");
describe("FileSystemWrapper", function () {
    function setup() {
        var fileSystem = new fileSystem_1.VirtualFileSystemHost();
        var hashSet = utils_1.createHashSet();
        return { fileSystem: fileSystem, hashSet: hashSet, wrapper: new fileSystem_1.FileSystemWrapper(fileSystem, hashSet) };
    }
    function checkState(objs, filePath, state) {
        chai_1.expect(objs.wrapper.fileExistsSync(filePath)).to.equal(state[0], "wrapper");
        chai_1.expect(objs.hashSet.has(filePath)).to.equal(state[1], "hash set");
        chai_1.expect(objs.fileSystem.fileExistsSync(filePath)).to.equal(state[2], "file system");
    }
    function checkStateForDir(objs, filePath, state) {
        chai_1.expect(objs.wrapper.directoryExistsSync(filePath)).to.equal(state[0], "wrapper");
        chai_1.expect(objs.hashSet.has(filePath)).to.equal(state[1], "hash set");
        chai_1.expect(objs.fileSystem.directoryExistsSync(filePath)).to.equal(state[2], "file system");
    }
    describe("queueDelete", function () {
        it("should queue a file for delete", function () { return __awaiter(_this, void 0, void 0, function () {
            var objs, wrapper, filePaths, filePaths_1, filePaths_1_1, filePath, e_1, _a;
            return __generator(this, function (_b) {
                objs = setup();
                wrapper = objs.wrapper;
                filePaths = ["/file.ts", "/file2.ts", "/file3.ts"];
                try {
                    for (filePaths_1 = __values(filePaths), filePaths_1_1 = filePaths_1.next(); !filePaths_1_1.done; filePaths_1_1 = filePaths_1.next()) {
                        filePath = filePaths_1_1.value;
                        wrapper.writeFileSync(filePath, "");
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (filePaths_1_1 && !filePaths_1_1.done && (_a = filePaths_1.return)) _a.call(filePaths_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                wrapper.queueDelete(filePaths[0]);
                wrapper.queueDelete(filePaths[1]);
                checkState(objs, filePaths[0], [false, true, true]);
                checkState(objs, filePaths[1], [false, true, true]);
                checkState(objs, filePaths[2], [true, false, true]);
                return [2 /*return*/];
            });
        }); });
    });
    describe("flushSync", function () {
        it("should queue files for delete then flush them", function () {
            var objs = setup();
            var wrapper = objs.wrapper;
            var filePaths = ["/file.ts", "/file2.ts", "/file3.ts"];
            try {
                for (var filePaths_2 = __values(filePaths), filePaths_2_1 = filePaths_2.next(); !filePaths_2_1.done; filePaths_2_1 = filePaths_2.next()) {
                    var filePath = filePaths_2_1.value;
                    wrapper.writeFileSync(filePath, "");
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (filePaths_2_1 && !filePaths_2_1.done && (_a = filePaths_2.return)) _a.call(filePaths_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            wrapper.queueDelete(filePaths[0]);
            wrapper.queueDelete(filePaths[1]);
            wrapper.flushSync();
            checkState(objs, filePaths[0], [false, false, false]);
            checkState(objs, filePaths[1], [false, false, false]);
            checkState(objs, filePaths[2], [true, false, true]);
            var e_2, _a;
        });
        it("should maintain the files to delete when there's errors deleting them", function () {
            var objs = setup();
            var wrapper = objs.wrapper, fileSystem = objs.fileSystem;
            var filePaths = ["/file.ts", "/file2.ts", "/file3.ts"];
            try {
                for (var filePaths_3 = __values(filePaths), filePaths_3_1 = filePaths_3.next(); !filePaths_3_1.done; filePaths_3_1 = filePaths_3.next()) {
                    var filePath = filePaths_3_1.value;
                    wrapper.writeFileSync(filePath, "");
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (filePaths_3_1 && !filePaths_3_1.done && (_a = filePaths_3.return)) _a.call(filePaths_3);
                }
                finally { if (e_3) throw e_3.error; }
            }
            wrapper.queueDelete(filePaths[0]);
            wrapper.queueDelete(filePaths[1]);
            fileSystem.deleteSync = function (path) { throw new Error(); };
            try {
                wrapper.flushSync();
            }
            catch (_b) {
                // do nothing
            }
            checkState(objs, filePaths[0], [false, true, true]);
            checkState(objs, filePaths[1], [false, true, true]);
            checkState(objs, filePaths[2], [true, false, true]);
            var e_3, _a;
        });
        it("should not error for queued files that don't exist", function () {
            var objs = setup();
            var wrapper = objs.wrapper;
            var filePaths = ["/file.ts", "/file2.ts"];
            wrapper.queueDelete(filePaths[0]);
            wrapper.queueDelete(filePaths[1]);
            wrapper.flushSync();
            checkState(objs, filePaths[0], [false, false, false]);
            checkState(objs, filePaths[1], [false, false, false]);
        });
    });
    describe("flush", function () {
        it("should queue files for delete then flush them", function () { return __awaiter(_this, void 0, void 0, function () {
            var objs, wrapper, filePaths, filePaths_4, filePaths_4_1, filePath, e_4, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        objs = setup();
                        wrapper = objs.wrapper;
                        filePaths = ["/file.ts", "/file2.ts", "/file3.ts"];
                        try {
                            for (filePaths_4 = __values(filePaths), filePaths_4_1 = filePaths_4.next(); !filePaths_4_1.done; filePaths_4_1 = filePaths_4.next()) {
                                filePath = filePaths_4_1.value;
                                wrapper.writeFileSync(filePath, "");
                            }
                        }
                        catch (e_4_1) { e_4 = { error: e_4_1 }; }
                        finally {
                            try {
                                if (filePaths_4_1 && !filePaths_4_1.done && (_a = filePaths_4.return)) _a.call(filePaths_4);
                            }
                            finally { if (e_4) throw e_4.error; }
                        }
                        wrapper.queueDelete(filePaths[0]);
                        wrapper.queueDelete(filePaths[1]);
                        return [4 /*yield*/, wrapper.flush()];
                    case 1:
                        _b.sent();
                        checkState(objs, filePaths[0], [false, false, false]);
                        checkState(objs, filePaths[1], [false, false, false]);
                        checkState(objs, filePaths[2], [true, false, true]);
                        return [2 /*return*/];
                }
            });
        }); });
        it("should maintain the files to delete when there's errors deleting them", function () { return __awaiter(_this, void 0, void 0, function () {
            var objs, wrapper, fileSystem, filePaths, filePaths_5, filePaths_5_1, filePath, _a, e_5, _b;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        objs = setup();
                        wrapper = objs.wrapper, fileSystem = objs.fileSystem;
                        filePaths = ["/file.ts", "/file2.ts", "/file3.ts"];
                        try {
                            for (filePaths_5 = __values(filePaths), filePaths_5_1 = filePaths_5.next(); !filePaths_5_1.done; filePaths_5_1 = filePaths_5.next()) {
                                filePath = filePaths_5_1.value;
                                wrapper.writeFileSync(filePath, "");
                            }
                        }
                        catch (e_5_1) { e_5 = { error: e_5_1 }; }
                        finally {
                            try {
                                if (filePaths_5_1 && !filePaths_5_1.done && (_b = filePaths_5.return)) _b.call(filePaths_5);
                            }
                            finally { if (e_5) throw e_5.error; }
                        }
                        wrapper.queueDelete(filePaths[0]);
                        wrapper.queueDelete(filePaths[1]);
                        fileSystem.delete = function (path) { return Promise.reject(new Error()); };
                        _c.label = 1;
                    case 1:
                        _c.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, wrapper.flush()];
                    case 2:
                        _c.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _c.sent();
                        return [3 /*break*/, 4];
                    case 4:
                        checkState(objs, filePaths[0], [false, true, true]);
                        checkState(objs, filePaths[1], [false, true, true]);
                        checkState(objs, filePaths[2], [true, false, true]);
                        return [2 /*return*/];
                }
            });
        }); });
        it("should not error for queued files that don't exist", function () { return __awaiter(_this, void 0, void 0, function () {
            var objs, wrapper, filePaths;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        objs = setup();
                        wrapper = objs.wrapper;
                        filePaths = ["/file.ts", "/file2.ts"];
                        wrapper.queueDelete(filePaths[0]);
                        wrapper.queueDelete(filePaths[1]);
                        return [4 /*yield*/, wrapper.flush()];
                    case 1:
                        _a.sent();
                        checkState(objs, filePaths[0], [false, false, false]);
                        checkState(objs, filePaths[1], [false, false, false]);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("dequeueDelete", function () {
        it("should dequeue a file for delete", function () { return __awaiter(_this, void 0, void 0, function () {
            var objs, wrapper, filePath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        objs = setup();
                        wrapper = objs.wrapper;
                        filePath = "/file.ts";
                        wrapper.writeFileSync(filePath, "");
                        wrapper.queueDelete(filePath);
                        checkState(objs, filePath, [false, true, true]);
                        wrapper.dequeueDelete(filePath);
                        checkState(objs, filePath, [true, false, true]);
                        return [4 /*yield*/, wrapper.flush()];
                    case 1:
                        _a.sent();
                        checkState(objs, filePath, [true, false, true]);
                        return [2 /*return*/];
                }
            });
        }); });
        it("should dequeue the parent folder from deletion when the file is dequeued", function () { return __awaiter(_this, void 0, void 0, function () {
            var objs, wrapper, dirPath, filePath;
            return __generator(this, function (_a) {
                objs = setup();
                wrapper = objs.wrapper;
                dirPath = "/dir";
                filePath = "/dir/file.ts";
                wrapper.mkdirSync(dirPath);
                wrapper.writeFileSync(filePath, "");
                wrapper.queueDelete(filePath);
                wrapper.queueDelete(dirPath);
                checkState(objs, filePath, [false, true, true]);
                checkStateForDir(objs, dirPath, [false, true, true]);
                wrapper.dequeueDelete(filePath);
                checkState(objs, filePath, [true, false, true]);
                checkStateForDir(objs, dirPath, [true, false, true]);
                return [2 /*return*/];
            });
        }); });
    });
    describe("deleteImmediately", function () {
        it("should delete a file immediately", function () { return __awaiter(_this, void 0, void 0, function () {
            var objs, wrapper, filePath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        objs = setup();
                        wrapper = objs.wrapper;
                        filePath = "/file.ts";
                        wrapper.writeFileSync(filePath, "");
                        return [4 /*yield*/, wrapper.deleteImmediately(filePath)];
                    case 1:
                        _a.sent();
                        checkState(objs, filePath, [false, false, false]);
                        return [2 /*return*/];
                }
            });
        }); });
        it("should not error deleting a file that doesn't exist", function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, wrapper, hashSet, caughtErr, err_1;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = setup(), wrapper = _a.wrapper, hashSet = _a.hashSet;
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, wrapper.deleteImmediately("path.ts")];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _b.sent();
                        caughtErr = err_1;
                        return [3 /*break*/, 4];
                    case 4:
                        chai_1.expect(caughtErr).to.be.undefined;
                        chai_1.expect(utils_1.ArrayUtils.from(hashSet.values())).to.deep.equal([], "should not have the path in the hashset");
                        return [2 /*return*/];
                }
            });
        }); });
        it("should delete a file immediately after it was queued for delete", function () { return __awaiter(_this, void 0, void 0, function () {
            var objs, wrapper, filePath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        objs = setup();
                        wrapper = objs.wrapper;
                        filePath = "/file.ts";
                        wrapper.writeFileSync(filePath, "");
                        wrapper.queueDelete(filePath);
                        return [4 /*yield*/, wrapper.deleteImmediately(filePath)];
                    case 1:
                        _a.sent();
                        checkState(objs, filePath, [false, false, false]);
                        return [2 /*return*/];
                }
            });
        }); });
        it("should delete a child file that was queued for delete when immediately deleting a parent dir", function () { return __awaiter(_this, void 0, void 0, function () {
            var objs, wrapper, hashSet, dirPath, filePath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        objs = setup();
                        wrapper = objs.wrapper, hashSet = objs.hashSet;
                        dirPath = "/dir";
                        filePath = "/dir/file.ts";
                        wrapper.mkdirSync(dirPath);
                        wrapper.writeFileSync(filePath, "");
                        wrapper.queueDelete(filePath);
                        return [4 /*yield*/, wrapper.deleteImmediately(dirPath)];
                    case 1:
                        _a.sent();
                        checkState(objs, filePath, [false, false, false]);
                        return [2 /*return*/];
                }
            });
        }); });
        it("should maintain the list of files to delete when there's an error deleting a directory", function () { return __awaiter(_this, void 0, void 0, function () {
            var objs, wrapper, hashSet, fileSystem, dirPath, filePath, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        objs = setup();
                        wrapper = objs.wrapper, hashSet = objs.hashSet, fileSystem = objs.fileSystem;
                        dirPath = "/dir";
                        filePath = "/dir/file.ts";
                        wrapper.mkdirSync(dirPath);
                        wrapper.writeFileSync(filePath, "");
                        wrapper.queueDelete(filePath);
                        fileSystem.delete = function (path) { return Promise.reject(new Error()); };
                        _b.label = 1;
                    case 1:
                        _b.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, wrapper.deleteImmediately(dirPath)];
                    case 2:
                        _b.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        _a = _b.sent();
                        return [3 /*break*/, 4];
                    case 4:
                        checkState(objs, filePath, [false, true, true]);
                        checkStateForDir(objs, dirPath, [false, true, true]);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("deleteImmediatelySync", function () {
        it("should delete a file immediately", function () {
            var objs = setup();
            var wrapper = objs.wrapper;
            var filePath = "/file.ts";
            wrapper.writeFileSync(filePath, "");
            wrapper.deleteImmediatelySync(filePath);
            checkState(objs, filePath, [false, false, false]);
        });
        it("should not error deleting a file that doesn't exist", function () {
            var _a = setup(), wrapper = _a.wrapper, hashSet = _a.hashSet;
            chai_1.expect(function () { return wrapper.deleteImmediatelySync("path.ts"); }).to.not.throw();
            chai_1.expect(utils_1.ArrayUtils.from(hashSet.values())).to.deep.equal([], "should not have the path in the hashset");
        });
        it("should delete a file immediately after it was queued for delete", function () {
            var objs = setup();
            var wrapper = objs.wrapper;
            var filePath = "/file.ts";
            wrapper.writeFileSync(filePath, "");
            wrapper.queueDelete(filePath);
            wrapper.deleteImmediatelySync(filePath);
            checkState(objs, filePath, [false, false, false]);
        });
        it("should delete a child file that was queued for delete when immediately deleting a parent dir", function () {
            var objs = setup();
            var wrapper = objs.wrapper, hashSet = objs.hashSet;
            var dirPath = "/dir";
            var filePath = "/dir/file.ts";
            wrapper.mkdirSync(dirPath);
            wrapper.writeFileSync(filePath, "");
            wrapper.queueDelete(filePath);
            wrapper.deleteImmediatelySync(dirPath);
            checkState(objs, filePath, [false, false, false]);
        });
        it("should maintain the list of files to delete when there's an error deleting a directory", function () {
            var objs = setup();
            var wrapper = objs.wrapper, hashSet = objs.hashSet, fileSystem = objs.fileSystem;
            var dirPath = "/dir";
            var filePath = "/dir/file.ts";
            wrapper.mkdirSync(dirPath);
            wrapper.writeFileSync(filePath, "");
            wrapper.queueDelete(filePath);
            fileSystem.deleteSync = function (path) { throw new Error(); };
            try {
                wrapper.deleteImmediatelySync(dirPath);
            }
            catch (_a) {
                // do nothing
            }
            checkState(objs, filePath, [false, true, true]);
            checkStateForDir(objs, dirPath, [false, true, true]);
        });
    });
    describe("fileExistsSync", function () {
        it("should not exist after queued for delete", function () {
            var wrapper = setup().wrapper;
            var filePath = "/file.ts";
            chai_1.expect(wrapper.fileExistsSync(filePath)).to.equal(false);
            wrapper.writeFileSync(filePath, "");
            chai_1.expect(wrapper.fileExistsSync(filePath)).to.equal(true);
            wrapper.queueDelete(filePath);
            chai_1.expect(wrapper.fileExistsSync(filePath)).to.equal(false);
            wrapper.flushSync();
            chai_1.expect(wrapper.fileExistsSync(filePath)).to.equal(false);
        });
        it("should not exist after a dequeued for delete when originally existed", function () {
            var wrapper = setup().wrapper;
            var filePath = "/file.ts";
            wrapper.writeFileSync(filePath, "");
            wrapper.queueDelete(filePath);
            wrapper.dequeueDelete(filePath);
            chai_1.expect(wrapper.fileExistsSync(filePath)).to.equal(true);
        });
        it("should not exist after a dequeued for delete when not originally existed", function () {
            var wrapper = setup().wrapper;
            var filePath = "/file.ts";
            wrapper.queueDelete(filePath);
            wrapper.dequeueDelete(filePath);
            chai_1.expect(wrapper.fileExistsSync(filePath)).to.equal(false);
        });
        it("should not exist if the parent directory was queued for delete", function () {
            var wrapper = setup().wrapper;
            var dirPath = "/dir";
            var filePath = "/dir/file.ts";
            wrapper.mkdirSync(dirPath);
            wrapper.writeFileSync(filePath, "");
            wrapper.queueDelete(dirPath);
            chai_1.expect(wrapper.fileExistsSync(filePath)).to.equal(false);
        });
    });
    describe("directoryExistsSync", function () {
        it("should not exist after queued for delete", function () {
            var wrapper = setup().wrapper;
            var dirPath = "/dir";
            chai_1.expect(wrapper.directoryExistsSync(dirPath)).to.equal(false);
            wrapper.mkdirSync(dirPath);
            chai_1.expect(wrapper.directoryExistsSync(dirPath)).to.equal(true);
            wrapper.queueDelete(dirPath);
            chai_1.expect(wrapper.directoryExistsSync(dirPath)).to.equal(false);
            wrapper.flushSync();
            chai_1.expect(wrapper.directoryExistsSync(dirPath)).to.equal(false);
        });
        it("should not exist after a dequeued for delete when originally existed", function () {
            var wrapper = setup().wrapper;
            var dirPath = "/dir";
            wrapper.mkdirSync(dirPath);
            wrapper.queueDelete(dirPath);
            wrapper.dequeueDelete(dirPath);
            chai_1.expect(wrapper.directoryExistsSync(dirPath)).to.equal(true);
        });
        it("should not exist after a dequeued for delete when not originally existed", function () {
            var wrapper = setup().wrapper;
            var dirPath = "/dir";
            wrapper.queueDelete(dirPath);
            wrapper.dequeueDelete(dirPath);
            chai_1.expect(wrapper.directoryExistsSync(dirPath)).to.equal(false);
        });
        it("should not exist if the parent directory was queued for delete", function () {
            var wrapper = setup().wrapper;
            var dirPath = "/dir";
            var subDirPath = "/dir/sub";
            wrapper.mkdirSync(dirPath);
            wrapper.mkdirSync(subDirPath);
            wrapper.queueDelete(dirPath);
            chai_1.expect(wrapper.directoryExistsSync(subDirPath)).to.equal(false);
        });
    });
    describe("directoryExists", function () {
        it("should not exist after queued for delete", function () { return __awaiter(_this, void 0, void 0, function () {
            var wrapper, dirPath, _a, _b, _c, _d;
            return __generator(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        wrapper = setup().wrapper;
                        dirPath = "/dir";
                        _a = chai_1.expect;
                        return [4 /*yield*/, wrapper.directoryExists(dirPath)];
                    case 1:
                        _a.apply(void 0, [_e.sent()]).to.equal(false);
                        wrapper.mkdirSync(dirPath);
                        _b = chai_1.expect;
                        return [4 /*yield*/, wrapper.directoryExists(dirPath)];
                    case 2:
                        _b.apply(void 0, [_e.sent()]).to.equal(true);
                        wrapper.queueDelete(dirPath);
                        _c = chai_1.expect;
                        return [4 /*yield*/, wrapper.directoryExists(dirPath)];
                    case 3:
                        _c.apply(void 0, [_e.sent()]).to.equal(false);
                        wrapper.flushSync();
                        _d = chai_1.expect;
                        return [4 /*yield*/, wrapper.directoryExists(dirPath)];
                    case 4:
                        _d.apply(void 0, [_e.sent()]).to.equal(false);
                        return [2 /*return*/];
                }
            });
        }); });
        it("should not exist after a dequeued for delete when originally existed", function () { return __awaiter(_this, void 0, void 0, function () {
            var wrapper, dirPath, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        wrapper = setup().wrapper;
                        dirPath = "/dir";
                        wrapper.mkdirSync(dirPath);
                        wrapper.queueDelete(dirPath);
                        wrapper.dequeueDelete(dirPath);
                        _a = chai_1.expect;
                        return [4 /*yield*/, wrapper.directoryExists(dirPath)];
                    case 1:
                        _a.apply(void 0, [_b.sent()]).to.equal(true);
                        return [2 /*return*/];
                }
            });
        }); });
        it("should not exist after a dequeued for delete when not originally existed", function () { return __awaiter(_this, void 0, void 0, function () {
            var wrapper, dirPath, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        wrapper = setup().wrapper;
                        dirPath = "/dir";
                        wrapper.queueDelete(dirPath);
                        wrapper.dequeueDelete(dirPath);
                        _a = chai_1.expect;
                        return [4 /*yield*/, wrapper.directoryExists(dirPath)];
                    case 1:
                        _a.apply(void 0, [_b.sent()]).to.equal(false);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("readFileSync", function () {
        it("should not read the file after it was deleted", function () {
            var wrapper = setup().wrapper;
            var filePath = "/file.ts";
            var fileText = "test";
            wrapper.writeFileSync(filePath, fileText);
            chai_1.expect(wrapper.readFileSync(filePath, "utf-8")).to.equal(fileText);
            wrapper.queueDelete(filePath);
            chai_1.expect(function () { return wrapper.readFileSync(filePath, "utf-8"); }).to.throw(errors.InvalidOperationError);
            wrapper.flushSync();
            chai_1.expect(function () { return wrapper.readFileSync(filePath, "utf-8"); }).to.throw(errors.FileNotFoundError);
        });
    });
    describe("readDirSync", function () {
        it("should not read the dir after it was deleted", function () {
            var wrapper = setup().wrapper;
            var dirPath = "/dir";
            var filePaths = ["/dir/file.ts", "/dir/file2.ts"];
            try {
                for (var filePaths_6 = __values(filePaths), filePaths_6_1 = filePaths_6.next(); !filePaths_6_1.done; filePaths_6_1 = filePaths_6.next()) {
                    var filePath = filePaths_6_1.value;
                    wrapper.writeFileSync(filePath, "");
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (filePaths_6_1 && !filePaths_6_1.done && (_a = filePaths_6.return)) _a.call(filePaths_6);
                }
                finally { if (e_6) throw e_6.error; }
            }
            chai_1.expect(wrapper.readDirSync(dirPath)).to.deep.equal(filePaths);
            wrapper.queueDelete(filePaths[0]);
            chai_1.expect(wrapper.readDirSync(dirPath)).to.deep.equal([filePaths[1]]);
            wrapper.flushSync();
            chai_1.expect(wrapper.readDirSync(dirPath)).to.deep.equal([filePaths[1]]);
            wrapper.queueDelete(dirPath);
            chai_1.expect(function () { return wrapper.readDirSync(dirPath); }).to.throw(errors.InvalidOperationError);
            wrapper.flushSync();
            chai_1.expect(function () { return wrapper.readDirSync(dirPath); }).to.throw(errors.DirectoryNotFoundError);
            var e_6, _a;
        });
    });
    describe("glob", function () {
        it("should not read the dir after it was deleted", function () {
            var wrapper = setup().wrapper;
            var dirPath = "/dir";
            var dirGlob = "/dir/**/*.ts";
            var filePaths = ["/dir/file.ts", "/dir/file2.ts"];
            try {
                for (var filePaths_7 = __values(filePaths), filePaths_7_1 = filePaths_7.next(); !filePaths_7_1.done; filePaths_7_1 = filePaths_7.next()) {
                    var filePath = filePaths_7_1.value;
                    wrapper.writeFileSync(filePath, "");
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (filePaths_7_1 && !filePaths_7_1.done && (_a = filePaths_7.return)) _a.call(filePaths_7);
                }
                finally { if (e_7) throw e_7.error; }
            }
            chai_1.expect(wrapper.glob([dirGlob])).to.deep.equal(filePaths);
            wrapper.queueDelete(filePaths[0]);
            chai_1.expect(wrapper.glob([dirGlob])).to.deep.equal([filePaths[1]]);
            wrapper.flushSync();
            chai_1.expect(wrapper.glob([dirGlob])).to.deep.equal([filePaths[1]]);
            var e_7, _a;
        });
    });
    describe("readFileOrNotExistsSync", function () {
        it("should return false after it was deleted", function () {
            var wrapper = setup().wrapper;
            var filePath = "/file.ts";
            var fileText = "test";
            wrapper.writeFileSync(filePath, fileText);
            chai_1.expect(wrapper.readFileOrNotExistsSync(filePath, "utf-8")).to.equal(fileText);
            wrapper.queueDelete(filePath);
            chai_1.expect(wrapper.readFileOrNotExistsSync(filePath, "utf-8")).to.equal(false);
            wrapper.flushSync();
            chai_1.expect(wrapper.readFileOrNotExistsSync(filePath, "utf-8")).to.equal(false);
        });
    });
    describe("readFileOrNotExists", function () {
        it("should return false after it was deleted", function () { return __awaiter(_this, void 0, void 0, function () {
            var wrapper, filePath, fileText, _a, _b, _c;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0:
                        wrapper = setup().wrapper;
                        filePath = "/file.ts";
                        fileText = "test";
                        wrapper.writeFileSync(filePath, fileText);
                        _a = chai_1.expect;
                        return [4 /*yield*/, wrapper.readFileOrNotExists(filePath, "utf-8")];
                    case 1:
                        _a.apply(void 0, [_d.sent()]).to.equal(fileText);
                        wrapper.queueDelete(filePath);
                        _b = chai_1.expect;
                        return [4 /*yield*/, wrapper.readFileOrNotExists(filePath, "utf-8")];
                    case 2:
                        _b.apply(void 0, [_d.sent()]).to.equal(false);
                        wrapper.flushSync();
                        _c = chai_1.expect;
                        return [4 /*yield*/, wrapper.readFileOrNotExists(filePath, "utf-8")];
                    case 3:
                        _c.apply(void 0, [_d.sent()]).to.equal(false);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("writeFileSync", function () {
        it("should undo the queued deletion when writing", function () {
            var _a = setup(), wrapper = _a.wrapper, hashSet = _a.hashSet;
            var filePath = "/file.ts";
            var fileText = "test";
            wrapper.writeFileSync(filePath, fileText);
            wrapper.queueDelete(filePath);
            wrapper.writeFileSync(filePath, fileText);
            chai_1.expect(hashSet.has(filePath)).to.be.false;
            chai_1.expect(wrapper.fileExistsSync(filePath)).to.be.true;
        });
    });
    describe("writeFile", function () {
        it("should undo the queued deletion when writing", function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, wrapper, hashSet, filePath, fileText;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = setup(), wrapper = _a.wrapper, hashSet = _a.hashSet;
                        filePath = "/file.ts";
                        fileText = "test";
                        return [4 /*yield*/, wrapper.writeFile(filePath, fileText)];
                    case 1:
                        _b.sent();
                        wrapper.queueDelete(filePath);
                        return [4 /*yield*/, wrapper.writeFile(filePath, fileText)];
                    case 2:
                        _b.sent();
                        chai_1.expect(hashSet.has(filePath)).to.be.false;
                        chai_1.expect(wrapper.fileExistsSync(filePath)).to.be.true;
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("mkdirSync", function () {
        it("should undo the queued deletion when making a directory", function () {
            var objs = setup();
            var wrapper = objs.wrapper;
            var dirPath = "/dir";
            var subDirPath = "/dir/sub";
            wrapper.mkdirSync(dirPath);
            wrapper.mkdirSync(subDirPath);
            checkStateForDir(objs, dirPath, [true, false, true]);
            checkStateForDir(objs, subDirPath, [true, false, true]);
            wrapper.queueDelete(dirPath);
            wrapper.queueDelete(subDirPath);
            checkStateForDir(objs, dirPath, [false, true, true]);
            checkStateForDir(objs, subDirPath, [false, true, true]);
            wrapper.mkdirSync(subDirPath);
            checkStateForDir(objs, dirPath, [true, false, true]);
            checkStateForDir(objs, subDirPath, [true, false, true]);
        });
    });
    describe("mkdir", function () {
        it("should undo the queued deletion when making a directory", function () { return __awaiter(_this, void 0, void 0, function () {
            var objs, wrapper, dirPath, subDirPath;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        objs = setup();
                        wrapper = objs.wrapper;
                        dirPath = "/dir";
                        subDirPath = "/dir/sub";
                        return [4 /*yield*/, wrapper.mkdir(dirPath)];
                    case 1:
                        _a.sent();
                        return [4 /*yield*/, wrapper.mkdir(subDirPath)];
                    case 2:
                        _a.sent();
                        checkStateForDir(objs, dirPath, [true, false, true]);
                        checkStateForDir(objs, subDirPath, [true, false, true]);
                        wrapper.queueDelete(dirPath);
                        wrapper.queueDelete(subDirPath);
                        checkStateForDir(objs, dirPath, [false, true, true]);
                        checkStateForDir(objs, subDirPath, [false, true, true]);
                        return [4 /*yield*/, wrapper.mkdir(subDirPath)];
                    case 3:
                        _a.sent();
                        checkStateForDir(objs, dirPath, [true, false, true]);
                        checkStateForDir(objs, subDirPath, [true, false, true]);
                        return [2 /*return*/];
                }
            });
        }); });
    });
});
