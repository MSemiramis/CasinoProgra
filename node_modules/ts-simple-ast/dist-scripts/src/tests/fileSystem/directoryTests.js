"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __values = (this && this.__values) || function (o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var typescript_1 = require("../../typescript");
var errors = require("../../errors");
var Project_1 = require("../../Project");
var utils_1 = require("../../utils");
var testHelpers_1 = require("../testHelpers");
describe("Directory", function () {
    function getProject(initialFiles, initialDirectories) {
        if (initialFiles === void 0) { initialFiles = []; }
        if (initialDirectories === void 0) { initialDirectories = []; }
        return new Project_1.Project(undefined, testHelpers_1.getFileSystemHostWithFiles(initialFiles, initialDirectories));
    }
    function testDirectoryTree(dir, tree, parent) {
        chai_1.expect(getDirPath(dir)).to.equal(getDirPath(tree.directory), "dir");
        chai_1.expect(getDirPath(dir.getParent())).to.equal(getDirPath(parent), "parent dir of " + getDirPath(dir));
        chai_1.expect(dir.getDirectories().map(function (d) { return d.getPath(); })).to.deep.equal((tree.children || []).map(function (c) { return c.directory.getPath(); }), "child directories");
        chai_1.expect(dir.getSourceFiles().map(function (s) { return s.getFilePath(); })).to.deep.equal((tree.sourceFiles || []).map(function (s) { return s.getFilePath(); }), "source files");
        try {
            for (var _a = __values((tree.children || [])), _b = _a.next(); !_b.done; _b = _a.next()) {
                var child = _b.value;
                testDirectoryTree(child.directory, child, dir);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_b && !_b.done && (_c = _a.return)) _c.call(_a);
            }
            finally { if (e_1) throw e_1.error; }
        }
        function getDirPath(directory) {
            return directory == null ? undefined : directory.getPath();
        }
        var e_1, _c;
    }
    describe("getPath", function () {
        function doTest(filePath, expectedDirPath) {
            var project = getProject();
            var sourceFile = project.createSourceFile(filePath);
            var directory = sourceFile.getDirectory();
            chai_1.expect(directory.getPath()).to.equal(expectedDirPath);
        }
        it("should get the directory path when just creating a file with no directory", function () {
            doTest("test/file.ts", "/test");
        });
        it("should get the directory path in the root directory", function () {
            doTest("/file.ts", "/");
        });
    });
    describe("ancestor/descendant tests", function () {
        var project = getProject();
        var root = project.createDirectory("");
        var child = project.createDirectory("child");
        var childChild = project.createDirectory("child/child");
        var otherChild = project.createDirectory("otherChild");
        var rootSourceFile = project.createSourceFile("file.ts");
        describe("isAncestorOf", function () {
            function doTest(ancestor, descendant, expectedValue) {
                chai_1.expect(ancestor.isAncestorOf(descendant)).to.equal(expectedValue);
            }
            it("should be an ancestor when is parent", function () {
                doTest(root, child, true);
            });
            it("should be an ancestor when is ancestor", function () {
                doTest(root, childChild, true);
            });
            it("should not be when a sibling", function () {
                doTest(child, otherChild, false);
            });
            it("should not be when a child", function () {
                doTest(child, root, false);
            });
            it("should be when a parent dir of a source file", function () {
                doTest(root, rootSourceFile, true);
            });
        });
        describe("isDescendantOf", function () {
            function doTest(descendant, ancestor, expectedValue) {
                chai_1.expect(descendant.isDescendantOf(ancestor)).to.equal(expectedValue);
            }
            it("should be a descendant when is child", function () {
                doTest(child, root, true);
            });
            it("should be a descendant when is descendant", function () {
                doTest(childChild, root, true);
            });
            it("should not be when a sibling", function () {
                doTest(otherChild, child, false);
            });
            it("should not be when a parent", function () {
                doTest(root, child, false);
            });
        });
    });
    describe("getting parent, child directories, and source files in directory", function () {
        it("should not have a parent if no parent exists", function () {
            var project = getProject();
            var sourceFile = project.createSourceFile("directory/file.ts");
            chai_1.expect(sourceFile.getDirectory().getParent()).to.be.undefined;
        });
        it("should get the files in the alphabetical order", function () {
            var project = getProject();
            var directory = project.createDirectory("");
            directory.createSourceFile("D.ts");
            directory.createSourceFile("b.ts");
            directory.createSourceFile("a.ts");
            directory.createSourceFile("C.ts");
            chai_1.expect(directory.getSourceFiles().map(function (s) { return s.getBaseName(); })).to.deep.equal(["a.ts", "b.ts", "C.ts", "D.ts"]);
        });
        it("should get the directories in alphabetical order", function () {
            var project = getProject();
            var directory = project.createDirectory("");
            directory.createDirectory("D");
            directory.createDirectory("b");
            directory.createDirectory("a");
            directory.createDirectory("C");
            chai_1.expect(directory.getDirectories().map(function (s) { return s.getBaseName(); })).to.deep.equal(["a", "b", "C", "D"]);
        });
        it("should have a parent when a file exists in an ancestor folder", function () {
            var project = getProject();
            var sourceFile = project.createSourceFile("file.ts");
            var lowerSourceFile = project.createSourceFile("dir1/dir2/file.ts");
            testDirectoryTree(sourceFile.getDirectory(), {
                directory: sourceFile.getDirectory(),
                sourceFiles: [sourceFile],
                children: [{
                        directory: project.getDirectoryOrThrow("dir1"),
                        children: [{
                                directory: project.getDirectoryOrThrow("dir1/dir2"),
                                sourceFiles: [lowerSourceFile]
                            }]
                    }]
            });
        });
        it("should get the child directories", function () {
            var project = getProject();
            var file1 = project.createSourceFile("file1.ts");
            var file2 = project.createSourceFile("dir1/file2.ts");
            var file3 = project.createSourceFile("dir2/file3.ts");
            testDirectoryTree(file1.getDirectory(), {
                directory: file1.getDirectory(),
                sourceFiles: [file1],
                children: [{
                        directory: file2.getDirectory(),
                        sourceFiles: [file2]
                    }, {
                        directory: file3.getDirectory(),
                        sourceFiles: [file3]
                    }]
            });
        });
        it("should have the correct child directories after creating a file in a parent directory of multiple directories", function () {
            var project = getProject();
            var file2 = project.createSourceFile("dir1/file2.ts");
            var file3 = project.createSourceFile("dir2/file3.ts");
            var file1 = project.createSourceFile("file1.ts");
            testDirectoryTree(file1.getDirectory(), {
                directory: file1.getDirectory(),
                sourceFiles: [file1],
                children: [{
                        directory: file2.getDirectory(),
                        sourceFiles: [file2]
                    }, {
                        directory: file3.getDirectory(),
                        sourceFiles: [file3]
                    }]
            });
        });
        it("should get the directories at the root level", function () {
            var project = getProject();
            var file1 = project.createSourceFile("V:/file1.ts");
            var file2 = project.createSourceFile("V:/file2.ts");
            var file3 = project.createSourceFile("V:/dir1/file2.ts");
            testDirectoryTree(file1.getDirectory(), {
                directory: file1.getDirectory(),
                sourceFiles: [file1, file2],
                children: [{
                        directory: file3.getDirectory(),
                        sourceFiles: [file3]
                    }]
            });
        });
    });
    describe("getParentOrThrow", function () {
        var project = getProject();
        var sourceFile = project.createSourceFile("/file.ts");
        var rootDir = sourceFile.getDirectory();
        var dir = rootDir.createDirectory("dir");
        it("should get the parent when there's a parent", function () {
            chai_1.expect(dir.getParentOrThrow().getPath()).to.equal(rootDir.getPath());
        });
        it("should throw when there's no parent", function () {
            chai_1.expect(function () { return rootDir.getParentOrThrow(); }).to.throw();
        });
    });
    describe("getDescendantSourceFiles", function () {
        it("should get all the descendant source files", function () {
            var project = getProject();
            var sourceFiles = [
                project.createSourceFile("someDir/inSomeFile/more/test.ts"),
                project.createSourceFile("someDir/otherDir/deeper/test.ts"),
                project.createSourceFile("someDir/test.ts"),
                project.createSourceFile("someDir/childDir/deeper/test.ts"),
                project.createSourceFile("final.ts")
            ];
            var finalFile = project.getSourceFileOrThrow("final.ts");
            chai_1.expect(finalFile.getDirectory().getDescendantSourceFiles().map(function (s) { return s.getFilePath(); }).sort()).to.deep.equal(sourceFiles.map(function (s) { return s.getFilePath(); }).sort());
        });
    });
    describe("getDescendantDirectories", function () {
        it("should get all the descendant directories", function () {
            var project = getProject();
            var rootDir = project.createDirectory("");
            var directories = [
                rootDir.createDirectory("someDir"),
                rootDir.createDirectory("someDir/inSomeFile"),
                rootDir.createDirectory("someDir/inSomeFile/more"),
                rootDir.createDirectory("someDir/otherDir"),
                rootDir.createDirectory("someDir/otherDir/deeper"),
                rootDir.createDirectory("someDir/test"),
                rootDir.createDirectory("someDir/childDir")
            ];
            chai_1.expect(rootDir.getDescendantDirectories().map(function (d) { return d.getPath(); }).sort()).to.deep.equal(directories.map(function (d) { return d.getPath(); }).sort());
        });
    });
    describe("createSourceFile", function () {
        function doTest(input, expectedText) {
            var project = getProject();
            var directory = project.createDirectory("dir");
            var sourceFile;
            if (typeof input === "undefined")
                sourceFile = directory.createSourceFile("sourceFile.ts");
            else if (typeof input === "string")
                sourceFile = directory.createSourceFile("sourceFile.ts", input);
            else
                sourceFile = directory.createSourceFile("sourceFile.ts", input);
            chai_1.expect(directory.getSourceFiles()).to.deep.equal([sourceFile]);
            chai_1.expect(sourceFile.getFilePath()).to.equal("/dir/sourceFile.ts");
            chai_1.expect(sourceFile.getFullText()).to.equal(expectedText);
        }
        it("should create a source file in the directory when specifying no text or structure", function () {
            doTest(undefined, "");
        });
        it("should create a source file in the directory when specifying text", function () {
            var code = "const t = 34;";
            doTest(code, code);
        });
        it("should create a source file in the directory when specifying a structure", function () {
            doTest({ enums: [{ name: "MyEnum" }] }, "enum MyEnum {\n}\n");
        });
        it("should throw an exception if creating a source file at an existing path on the disk", function () {
            var project = getProject([{ filePath: "/file.ts", text: "" }], ["/"]);
            var directory = project.addExistingDirectory("/");
            chai_1.expect(function () { return directory.createSourceFile("file.ts", ""); }).to.throw(errors.InvalidOperationError);
        });
    });
    describe("addSourceFileIfExists", function () {
        it("should return undefined if adding a source file at a non-existent path", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project(undefined, fileSystem);
            var directory = project.createDirectory("dir");
            chai_1.expect(directory.addSourceFileIfExists("non-existent-file.ts")).to.be.undefined;
        });
        it("should add a source file that exists", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([{ filePath: "dir/file.ts", text: "" }], ["dir"]);
            var project = new Project_1.Project(undefined, fileSystem);
            var directory = project.addExistingDirectory("dir");
            var sourceFile = directory.addSourceFileIfExists("file.ts");
            chai_1.expect(sourceFile).to.not.be.undefined;
        });
    });
    describe("addExistingSourceFile", function () {
        it("should throw an exception if adding a source file at a non-existent path", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project(undefined, fileSystem);
            var directory = project.createDirectory("dir");
            chai_1.expect(function () {
                directory.addExistingSourceFile("non-existent-file.ts");
            }).to.throw(errors.FileNotFoundError, "File not found: /dir/non-existent-file.ts");
        });
        it("should add a source file that exists", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([{ filePath: "dir/file.ts", text: "" }], ["dir"]);
            var project = new Project_1.Project(undefined, fileSystem);
            var directory = project.addExistingDirectory("dir");
            var sourceFile = directory.addExistingSourceFile("file.ts");
            chai_1.expect(sourceFile).to.not.be.undefined;
        });
    });
    describe("createDirectory", function () {
        var project = getProject([], ["", "childDir"]);
        var directory = project.createDirectory("some/path");
        directory.createDirectory("child");
        directory.createDirectory("../../dir/other/deep/path");
        directory.createDirectory("../../dir/other");
        it("should have created the directories in the first area", function () {
            testDirectoryTree(project.getDirectoryOrThrow("some/path"), {
                directory: project.getDirectoryOrThrow("some/path"),
                children: [{
                        directory: project.getDirectoryOrThrow("some/path/child")
                    }]
            });
        });
        it("should have created the directories in the second area", function () {
            testDirectoryTree(project.getDirectoryOrThrow("dir/other"), {
                directory: project.getDirectoryOrThrow("dir/other"),
                children: [{
                        directory: project.getDirectoryOrThrow("dir/other/deep"),
                        children: [{
                                directory: project.getDirectoryOrThrow("dir/other/deep/path")
                            }]
                    }]
            });
        });
        it("should throw when a directory already exists at the specified path", function () {
            chai_1.expect(function () { return directory.createDirectory("child"); }).to.throw(errors.InvalidOperationError);
        });
        it("should throw when a directory already exists on the file system at the specified path", function () {
            chai_1.expect(function () { return project.addExistingDirectory("").createDirectory("childDir"); }).to.throw(errors.InvalidOperationError);
        });
    });
    describe("addDirectoryIfExists", function () {
        it("should return undefined when the directory doesn't exist", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([], ["dir"]);
            var project = new Project_1.Project(undefined, fileSystem);
            var directory = project.addExistingDirectory("dir");
            chai_1.expect(directory.addDirectoryIfExists("someDir")).to.be.undefined;
        });
        it("should add a directory relative to the specified directory", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([{ filePath: "dir/file.ts", text: "" }], ["dir", "dir2", "dir/child"]);
            var project = new Project_1.Project(undefined, fileSystem);
            var directory = project.addExistingDirectory("dir");
            chai_1.expect(directory.addDirectoryIfExists("child")).to.equal(project.getDirectoryOrThrow("dir/child"));
            chai_1.expect(directory.addDirectoryIfExists("../dir2")).to.equal(project.getDirectoryOrThrow("dir2"));
        });
    });
    describe("addExistingDirectory", function () {
        it("should throw when the directory doesn't exist", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([], ["dir"]);
            var project = new Project_1.Project(undefined, fileSystem);
            var directory = project.addExistingDirectory("dir");
            chai_1.expect(function () { return directory.addExistingDirectory("someDir"); }).to.throw(errors.DirectoryNotFoundError);
        });
        it("should add a directory relative to the specified directory", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([{ filePath: "dir/file.ts", text: "" }], ["dir", "dir2", "dir/child"]);
            var project = new Project_1.Project(undefined, fileSystem);
            var directory = project.addExistingDirectory("dir");
            chai_1.expect(directory.addExistingDirectory("child")).to.equal(project.getDirectoryOrThrow("dir/child"));
            chai_1.expect(directory.addExistingDirectory("../dir2")).to.equal(project.getDirectoryOrThrow("dir2"));
        });
    });
    describe("getDirectory", function () {
        var project = new Project_1.Project({ useVirtualFileSystem: true });
        var directory = project.createDirectory("dir");
        var child1 = directory.createDirectory("child1");
        var child2 = directory.createDirectory("child2");
        var grandChild1 = child1.createDirectory("grandChild1");
        it("should get the directory based on the name", function () {
            chai_1.expect(directory.getDirectory("child2").getPath()).to.equal(child2.getPath());
        });
        it("should get the directory based on the relative path", function () {
            chai_1.expect(directory.getDirectory("child1/grandChild1").getPath()).to.equal(grandChild1.getPath());
        });
        it("should get the directory based on the absolute path", function () {
            chai_1.expect(directory.getDirectory(grandChild1.getPath()).getPath()).to.equal(grandChild1.getPath());
        });
        it("should get the directory based on a condition", function () {
            chai_1.expect(directory.getDirectory(function (d) { return utils_1.FileUtils.getBaseName(d.getPath()) === "child2"; }).getPath()).to.equal(child2.getPath());
        });
        it("should not get the directory when it doesn't exist", function () {
            chai_1.expect(directory.getDirectory("child3")).to.be.undefined;
        });
    });
    describe("getDirectoryOrThrow", function () {
        var project = new Project_1.Project({ useVirtualFileSystem: true });
        var directory = project.createDirectory("dir");
        var child1 = directory.createDirectory("child1");
        var child2 = directory.createDirectory("child2");
        it("should get the directory based on the name", function () {
            chai_1.expect(directory.getDirectoryOrThrow("child2").getPath()).to.equal(child2.getPath());
        });
        it("should get the directory based on a condition", function () {
            chai_1.expect(directory.getDirectoryOrThrow(function (d) { return utils_1.FileUtils.getBaseName(d.getPath()) === "child2"; }).getPath()).to.equal(child2.getPath());
        });
        it("should throw when it doesn't exist", function () {
            chai_1.expect(function () { return directory.getDirectoryOrThrow("child3"); }).to.throw();
        });
        it("should throw when the condition doesn't match", function () {
            chai_1.expect(function () { return directory.getDirectoryOrThrow(function (d) { return false; }); }).to.throw();
        });
    });
    describe("getSourceFile", function () {
        var project = getProject();
        var directory = project.createDirectory("dir");
        var existingFile = directory.createSourceFile("existing-file.ts");
        existingFile.saveSync();
        existingFile.forget();
        var child1 = directory.createSourceFile("child1.ts");
        var child2 = directory.createSourceFile("child2.ts");
        var subDir = directory.createDirectory("subDir");
        var child3 = subDir.createSourceFile("child3.ts");
        it("should not return a file that doesn't exist internally", function () {
            chai_1.expect(directory.getSourceFile("existing-file.ts")).to.be.undefined;
        });
        it("should get based on the name", function () {
            chai_1.expect(directory.getSourceFile("child2.ts").getFilePath()).to.equal(child2.getFilePath());
        });
        it("should get based on the path", function () {
            chai_1.expect(directory.getSourceFile("subDir/child3.ts").getFilePath()).to.equal(child3.getFilePath());
        });
        it("should get based on a condition", function () {
            chai_1.expect(directory.getSourceFile(function (f) { return utils_1.FileUtils.getBaseName(f.getFilePath()) === "child2.ts"; }).getFilePath()).to.equal(child2.getFilePath());
        });
        it("should return undefined when it doesn't exist", function () {
            chai_1.expect(directory.getSourceFile("child3.ts")).to.be.undefined;
        });
        it("should throw when the condition doesn't match", function () {
            chai_1.expect(directory.getSourceFile(function (s) { return false; })).to.be.undefined;
        });
    });
    describe("getSourceFileOrThrow", function () {
        var project = getProject();
        var directory = project.createDirectory("dir");
        var child1 = directory.createSourceFile("child1.ts");
        var child2 = directory.createSourceFile("child2.ts");
        var subDir = directory.createDirectory("subDir");
        var child3 = subDir.createSourceFile("child3.ts");
        it("should get based on the name", function () {
            chai_1.expect(directory.getSourceFileOrThrow("child2.ts").getFilePath()).to.equal(child2.getFilePath());
        });
        it("should get based on the path", function () {
            chai_1.expect(directory.getSourceFileOrThrow("subDir/child3.ts").getFilePath()).to.equal(child3.getFilePath());
        });
        it("should get based on a condition", function () {
            chai_1.expect(directory.getSourceFileOrThrow(function (f) { return utils_1.FileUtils.getBaseName(f.getFilePath()) === "child2.ts"; }).getFilePath()).to.equal(child2.getFilePath());
        });
        it("should throw when it doesn't exist", function () {
            chai_1.expect(function () { return directory.getSourceFileOrThrow("child3.ts"); }).to.throw();
        });
        it("should throw when the condition doesn't match", function () {
            chai_1.expect(function () { return directory.getSourceFileOrThrow(function (s) { return false; }); }).to.throw();
        });
    });
    describe("copy", function () {
        it("should copy a directory to a new directory", function () {
            var project = getProject();
            var mainDir = project.createDirectory("mainDir");
            var dir = mainDir.createDirectory("dir");
            dir.createSourceFile("file.ts");
            dir.createDirectory("dir2").createDirectory("nested").createSourceFile("file2.ts");
            var newDir = dir.copy("../newDir");
            chai_1.expect(newDir.getPath()).to.equal(utils_1.FileUtils.pathJoin(mainDir.getPath(), newDir.getBaseName()));
            testDirectoryTree(newDir, {
                directory: newDir,
                sourceFiles: [project.getSourceFileOrThrow("mainDir/newDir/file.ts")],
                children: [{
                        directory: project.getDirectoryOrThrow("mainDir/newDir/dir2"),
                        children: [{
                                directory: project.getDirectoryOrThrow("mainDir/newDir/dir2/nested"),
                                sourceFiles: [project.getSourceFileOrThrow("mainDir/newDir/dir2/nested/file2.ts")]
                            }]
                    }]
            }, mainDir);
        });
        it("should copy a directory to an existing directory", function () {
            var project = getProject();
            var mainDir = project.createDirectory("mainDir");
            var dir = mainDir.createDirectory("dir");
            dir.createSourceFile("file.ts");
            dir.createDirectory("child");
            var newDir = mainDir.createDirectory("newDir");
            var copyDir = dir.copy(newDir.getPath());
            chai_1.expect(copyDir).to.equal(newDir, "returned directory should equal the existing directory");
            testDirectoryTree(copyDir, {
                directory: copyDir,
                sourceFiles: [project.getSourceFileOrThrow("mainDir/newDir/file.ts")],
                children: [{
                        directory: project.getDirectoryOrThrow("mainDir/newDir/child")
                    }]
            }, mainDir);
        });
        it("should not throw when copying a directory to an existing directory on the file system", function () {
            var project = getProject([], ["mainDir/newDir"]);
            var mainDir = project.createDirectory("mainDir");
            var dir = mainDir.createDirectory("dir");
            dir.createSourceFile("file.ts");
            chai_1.expect(function () { return dir.copy("../newDir"); }).to.not.throw();
        });
        it("should throw when copying a directory to an existing directory and a file exists in the other one", function () {
            var project = getProject([]);
            var dir = project.createDirectory("dir");
            dir.createDirectory("subDir").createSourceFile("file.ts");
            dir.createSourceFile("file.ts");
            dir.copy("../newDir");
            chai_1.expect(function () { return dir.copy("../newDir"); }).to.throw();
        });
        it("should not throw when copying a directory to an existing directory with the overwrite option and a file exists in the other one", function () {
            var project = getProject([]);
            var dir = project.createDirectory("dir");
            dir.createSourceFile("file.ts");
            dir.copy("../newDir");
            chai_1.expect(function () { return dir.copy("../newDir", { overwrite: true }); }).to.not.throw();
        });
    });
    describe("delete", function () {
        it("should delete the file and remove all its descendants", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([], []);
            var project = new Project_1.Project(undefined, fileSystem);
            var directory = project.createDirectory("dir");
            var childDir = directory.createDirectory("childDir");
            var sourceFile = directory.createSourceFile("file.ts");
            var otherSourceFile = project.createSourceFile("otherFile.ts");
            directory.delete();
            chai_1.expect(fileSystem.getDeleteLog()).to.deep.equal([]);
            chai_1.expect(directory._wasRemoved()).to.be.true;
            chai_1.expect(childDir._wasRemoved()).to.be.true;
            chai_1.expect(sourceFile.wasForgotten()).to.be.true;
            chai_1.expect(otherSourceFile.wasForgotten()).to.be.false;
            project.saveSync();
            chai_1.expect(fileSystem.getDeleteLog().map(function (d) { return d.path; }).sort()).to.deep.equal(["/dir/childDir", "/dir/file.ts", "/dir"].sort());
        });
        it("mixing delete and delete immediately", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([], []);
            var project = new Project_1.Project(undefined, fileSystem);
            var directory = project.createDirectory("dir");
            var childDir = directory.createDirectory("childDir");
            var sourceFile = directory.createSourceFile("sourceFile.ts");
            childDir.delete();
            sourceFile.delete();
            directory.deleteImmediately();
            chai_1.expect(fileSystem.getDeleteLog()).to.deep.equal([{ path: "/dir" }]);
            project.saveSync();
            // should not add the child directory and source file here...
            chai_1.expect(fileSystem.getDeleteLog()).to.deep.equal([{ path: "/dir" }]);
        });
        it("should delete the directory's previous items when recreating the directory before a save", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([], []);
            var project = new Project_1.Project(undefined, fileSystem);
            var filePaths = ["/dir/subDir/file.ts", "/dir/file.ts"];
            try {
                for (var filePaths_1 = __values(filePaths), filePaths_1_1 = filePaths_1.next(); !filePaths_1_1.done; filePaths_1_1 = filePaths_1.next()) {
                    var filePath = filePaths_1_1.value;
                    project.createSourceFile(filePath);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (filePaths_1_1 && !filePaths_1_1.done && (_a = filePaths_1.return)) _a.call(filePaths_1);
                }
                finally { if (e_2) throw e_2.error; }
            }
            var directory = project.getDirectoryOrThrow("dir");
            project.saveSync();
            directory.delete();
            project.createDirectory("dir");
            project.saveSync();
            chai_1.expect(fileSystem.getDeleteLog().map(function (d) { return d.path; }).sort()).to.deep.equal(__spread(filePaths, ["/dir/subDir"]).sort());
            var e_2, _a;
        });
    });
    describe("deleteImmediately", function () {
        it("should delete the file and remove all its descendants", function () { return __awaiter(_this, void 0, void 0, function () {
            var fileSystem, project, directory, childDir, sourceFile, otherSourceFile;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fileSystem = testHelpers_1.getFileSystemHostWithFiles([{ filePath: "dir/file.ts", text: "" }], ["dir"]);
                        project = new Project_1.Project(undefined, fileSystem);
                        directory = project.addExistingDirectory("dir");
                        childDir = directory.createDirectory("childDir");
                        sourceFile = directory.addExistingSourceFile("file.ts");
                        otherSourceFile = project.createSourceFile("otherFile.ts");
                        return [4 /*yield*/, directory.deleteImmediately()];
                    case 1:
                        _a.sent();
                        chai_1.expect(directory._wasRemoved()).to.be.true;
                        chai_1.expect(childDir._wasRemoved()).to.be.true;
                        chai_1.expect(sourceFile.wasForgotten()).to.be.true;
                        chai_1.expect(otherSourceFile.wasForgotten()).to.be.false;
                        chai_1.expect(fileSystem.getDeleteLog()).to.deep.equal([{ path: "/dir" }]);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("deleteImmediatelySync", function () {
        it("should delete the file and remove all its descendants synchronously", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([{ filePath: "dir/file.ts", text: "" }], ["dir"]);
            var project = new Project_1.Project(undefined, fileSystem);
            var directory = project.addExistingDirectory("dir");
            var childDir = directory.createDirectory("childDir");
            var sourceFile = directory.addExistingSourceFile("file.ts");
            var otherSourceFile = project.createSourceFile("otherFile.ts");
            directory.deleteImmediatelySync();
            chai_1.expect(directory._wasRemoved()).to.be.true;
            chai_1.expect(childDir._wasRemoved()).to.be.true;
            chai_1.expect(sourceFile.wasForgotten()).to.be.true;
            chai_1.expect(otherSourceFile.wasForgotten()).to.be.false;
            chai_1.expect(fileSystem.getDeleteLog()).to.deep.equal([{ path: "/dir" }]);
        });
    });
    describe("remove", function () {
        it("should remove the file and all its descendants", function () {
            var project = getProject();
            var directory = project.createDirectory("dir");
            var childDir = directory.createDirectory("childDir");
            var sourceFile = directory.createSourceFile("file.ts");
            var otherSourceFile = project.createSourceFile("otherFile.ts");
            directory.remove();
            chai_1.expect(directory._wasRemoved()).to.be.true;
            chai_1.expect(function () { return directory.getPath(); }).to.throw();
            chai_1.expect(childDir._wasRemoved()).to.be.true;
            chai_1.expect(sourceFile.wasForgotten()).to.be.true;
            chai_1.expect(otherSourceFile.wasForgotten()).to.be.false;
        });
    });
    describe("save", function () {
        it("should save all the unsaved source files asynchronously", function () { return __awaiter(_this, void 0, void 0, function () {
            var fileSystem, project, otherFile, dir;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fileSystem = testHelpers_1.getFileSystemHostWithFiles([]);
                        project = new Project_1.Project(undefined, fileSystem);
                        otherFile = project.createSourceFile("file.ts");
                        dir = project.createDirectory("dir");
                        dir.createSourceFile("file1.ts", "").saveSync();
                        dir.createSourceFile("file2.ts", "");
                        dir.createSourceFile("child/file3.ts", "");
                        return [4 /*yield*/, dir.save()];
                    case 1:
                        _a.sent();
                        chai_1.expect(dir.getDescendantSourceFiles().map(function (f) { return f.isSaved(); })).to.deep.equal([true, true, true]);
                        chai_1.expect(otherFile.isSaved()).to.be.false;
                        chai_1.expect(fileSystem.getWriteLog().length).to.equal(2);
                        chai_1.expect(fileSystem.getCreatedDirectories().length).to.equal(2);
                        chai_1.expect(fileSystem.getSyncWriteLog().length).to.equal(1);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("saveSync", function () {
        it("should save all the unsaved source files synchronously", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project(undefined, fileSystem);
            var otherFile = project.createSourceFile("file.ts");
            var dir = project.createDirectory("dir");
            dir.createSourceFile("file1.ts", "").saveSync();
            dir.createSourceFile("file2.ts", "");
            dir.createSourceFile("child/file3.ts", "");
            dir.saveSync();
            chai_1.expect(dir.getDescendantSourceFiles().map(function (f) { return f.isSaved(); })).to.deep.equal([true, true, true]);
            chai_1.expect(otherFile.isSaved()).to.be.false;
            chai_1.expect(fileSystem.getWriteLog().length).to.equal(0);
            chai_1.expect(fileSystem.getCreatedDirectories().length).to.equal(2);
            chai_1.expect(fileSystem.getSyncWriteLog().length).to.equal(3);
        });
    });
    describe("emit", function () {
        function setup(compilerOptions) {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project({ compilerOptions: compilerOptions }, fileSystem);
            var directory = project.createDirectory("dir");
            directory.createSourceFile("file1.ts", "const t = '';");
            directory.createDirectory("subDir").createSourceFile("file2.ts");
            return { directory: directory, fileSystem: fileSystem };
        }
        function runChecks(fileSystem, result, outDir, declarationDir) {
            var writeLog = fileSystem.getWriteLog();
            var createdDirectories = fileSystem.getCreatedDirectories();
            chai_1.expect(result.getEmitSkipped()).to.be.false;
            chai_1.expect(result.getOutputFilePaths().sort()).to.deep.equal(writeLog.map(function (l) { return l.filePath; }).sort());
            chai_1.expect(writeLog.map(function (l) { return l.filePath; }).sort()).to.deep.equal([
                outDir + "/file1.js.map",
                outDir + "/file1.js",
                declarationDir + "/file1.d.ts",
                outDir + "/subDir/file2.js.map",
                outDir + "/subDir/file2.js",
                declarationDir + "/subDir/file2.d.ts"
            ].sort());
        }
        it("should emit correctly when not specifying anything", function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, directory, fileSystem, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = setup({ target: typescript_1.ScriptTarget.ES5, outDir: "dist", declaration: true, sourceMap: true }), directory = _a.directory, fileSystem = _a.fileSystem;
                        return [4 /*yield*/, directory.emit()];
                    case 1:
                        result = _b.sent();
                        runChecks(fileSystem, result, "/dist", "/dist");
                        return [2 /*return*/];
                }
            });
        }); });
        it("should emit correctly when specifying a different out dir and no declaration dir in compiler options", function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, directory, fileSystem, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = setup({ target: typescript_1.ScriptTarget.ES5, outDir: "dist", declaration: true, sourceMap: true }), directory = _a.directory, fileSystem = _a.fileSystem;
                        return [4 /*yield*/, directory.emit({ outDir: "../newOutDir" })];
                    case 1:
                        result = _b.sent();
                        runChecks(fileSystem, result, "/newOutDir", "/newOutDir");
                        return [2 /*return*/];
                }
            });
        }); });
        it("should emit correctly when specifying a different out dir and a declaration dir in compiler options", function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, directory, fileSystem, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = setup({ target: typescript_1.ScriptTarget.ES5, outDir: "dist", declarationDir: "dec", declaration: true, sourceMap: true }), directory = _a.directory, fileSystem = _a.fileSystem;
                        return [4 /*yield*/, directory.emit({ outDir: "../newOutDir" })];
                    case 1:
                        result = _b.sent();
                        runChecks(fileSystem, result, "/newOutDir", "/dec");
                        return [2 /*return*/];
                }
            });
        }); });
        it("should emit correctly when specifying a different declaration dir", function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, directory, fileSystem, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = setup({ target: typescript_1.ScriptTarget.ES5, outDir: "dist", declarationDir: "dec", declaration: true, sourceMap: true }), directory = _a.directory, fileSystem = _a.fileSystem;
                        return [4 /*yield*/, directory.emit({ declarationDir: "newDeclarationDir" })];
                    case 1:
                        result = _b.sent();
                        runChecks(fileSystem, result, "/dist", "/dir/newDeclarationDir");
                        return [2 /*return*/];
                }
            });
        }); });
        it("should emit correctly when specifying a different out and declaration dir", function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, directory, fileSystem, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = setup({ target: typescript_1.ScriptTarget.ES5, outDir: "dist", declarationDir: "dec", declaration: true, sourceMap: true }), directory = _a.directory, fileSystem = _a.fileSystem;
                        return [4 /*yield*/, directory.emit({ outDir: "", declarationDir: "newDeclarationDir" })];
                    case 1:
                        result = _b.sent();
                        runChecks(fileSystem, result, "/dir", "/dir/newDeclarationDir");
                        return [2 /*return*/];
                }
            });
        }); });
        it("should emit correctly when specifying to only emit declaration files", function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, directory, fileSystem, result, writeLog;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = setup({ target: typescript_1.ScriptTarget.ES5, outDir: "dist", declarationDir: "dec", declaration: true, sourceMap: true }), directory = _a.directory, fileSystem = _a.fileSystem;
                        return [4 /*yield*/, directory.emit({ outDir: "", declarationDir: "newDeclarationDir", emitOnlyDtsFiles: true })];
                    case 1:
                        result = _b.sent();
                        writeLog = fileSystem.getWriteLog();
                        chai_1.expect(writeLog[0].filePath).to.equal("/dir/newDeclarationDir/file1.d.ts");
                        chai_1.expect(writeLog[1].filePath).to.equal("/dir/newDeclarationDir/subDir/file2.d.ts");
                        chai_1.expect(writeLog.length).to.equal(2);
                        return [2 /*return*/];
                }
            });
        }); });
        it("should stop emitting when it encounters a problem", function () { return __awaiter(_this, void 0, void 0, function () {
            var fileSystem, project, directory, subDir, result, writeLog;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        fileSystem = testHelpers_1.getFileSystemHostWithFiles([]);
                        project = new Project_1.Project({ compilerOptions: { declaration: true } }, fileSystem);
                        directory = project.createDirectory("dir");
                        subDir = directory.createDirectory("sub");
                        subDir.createSourceFile("file1.ts", "");
                        subDir.createSourceFile("file2.ts", "class Child {}\nexport class Parent extends Child {}");
                        return [4 /*yield*/, directory.emit()];
                    case 1:
                        result = _a.sent();
                        chai_1.expect(result.getEmitSkipped()).to.be.true;
                        writeLog = fileSystem.getWriteLog();
                        chai_1.expect(result.getOutputFilePaths()).to.deep.equal(writeLog.map(function (l) { return l.filePath; }));
                        chai_1.expect(writeLog[0].filePath).to.equal("/dir/sub/file1.js");
                        chai_1.expect(writeLog[1].filePath).to.equal("/dir/sub/file1.d.ts");
                        chai_1.expect(writeLog.length).to.equal(2);
                        return [2 /*return*/];
                }
            });
        }); });
    });
    describe("emitSync", function () {
        function setup(compilerOptions) {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project({ compilerOptions: compilerOptions }, fileSystem);
            var directory = project.createDirectory("dir");
            directory.createSourceFile("file1.ts", "const t = '';");
            directory.createDirectory("subDir").createSourceFile("file2.ts");
            return { directory: directory, fileSystem: fileSystem };
        }
        function runChecks(fileSystem, result, outDir, declarationDir) {
            var writeLog = fileSystem.getSyncWriteLog();
            chai_1.expect(result.getEmitSkipped()).to.be.false;
            chai_1.expect(result.getOutputFilePaths()).to.deep.equal(writeLog.map(function (l) { return l.filePath; }));
            chai_1.expect(writeLog[0].filePath).to.equal(outDir + "/file1.js.map");
            chai_1.expect(writeLog[1].filePath).to.equal(outDir + "/file1.js");
            chai_1.expect(writeLog[1].fileText).to.equal("var t = '';\n//# sourceMappingURL=file1.js.map");
            chai_1.expect(writeLog[2].filePath).to.equal(declarationDir + "/file1.d.ts");
            chai_1.expect(writeLog[3].filePath).to.equal(outDir + "/subDir/file2.js.map");
            chai_1.expect(writeLog[4].filePath).to.equal(outDir + "/subDir/file2.js");
            chai_1.expect(writeLog[5].filePath).to.equal(declarationDir + "/subDir/file2.d.ts");
            chai_1.expect(writeLog.length).to.equal(6);
        }
        it("should emit correctly when not specifying anything", function () {
            var _a = setup({ target: typescript_1.ScriptTarget.ES5, outDir: "dist", declaration: true, sourceMap: true }), directory = _a.directory, fileSystem = _a.fileSystem;
            var result = directory.emitSync();
            runChecks(fileSystem, result, "/dist", "/dist");
        });
        it("should get the absolute path in the output file name", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project({ compilerOptions: { declaration: false } }, fileSystem);
            var directory = project.createDirectory("dir");
            var subDir = directory.createDirectory("sub");
            var subDir2 = directory.createDirectory("sub2");
            subDir.createSourceFile("file1.ts", "");
            var result = subDir.emitSync({ outDir: "../sub2" });
            chai_1.expect(result.getEmitSkipped()).to.be.false;
            var writeLog = fileSystem.getSyncWriteLog();
            chai_1.expect(result.getOutputFilePaths()).to.deep.equal(writeLog.map(function (l) { return l.filePath; }));
            chai_1.expect(writeLog[0].filePath).to.equal("/dir/sub2/file1.js");
            chai_1.expect(writeLog.length).to.equal(1);
        });
        it("should stop emitting when it encounters a problem", function () {
            var fileSystem = testHelpers_1.getFileSystemHostWithFiles([]);
            var project = new Project_1.Project({ compilerOptions: { declaration: true } }, fileSystem);
            var directory = project.createDirectory("dir");
            var subDir = directory.createDirectory("sub");
            subDir.createSourceFile("file1.ts", "");
            subDir.createSourceFile("file2.ts", "class Child {}\nexport class Parent extends Child {}");
            var result = directory.emitSync();
            chai_1.expect(result.getEmitSkipped()).to.be.true;
            var writeLog = fileSystem.getSyncWriteLog();
            chai_1.expect(result.getOutputFilePaths()).to.deep.equal(writeLog.map(function (l) { return l.filePath; }));
            chai_1.expect(writeLog[0].filePath).to.equal("/dir/sub/file1.js");
            chai_1.expect(writeLog[1].filePath).to.equal("/dir/sub/file1.d.ts");
            chai_1.expect(writeLog.length).to.equal(2);
        });
    });
});
