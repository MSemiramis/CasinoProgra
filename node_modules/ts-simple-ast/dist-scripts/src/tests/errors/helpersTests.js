"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var typescript_1 = require("../../typescript");
var errors = require("../../errors");
var testHelpers_1 = require("../compiler/testHelpers");
describe("helpers", function () {
    describe("throwIfNotType", function () {
        it("should throw when not the same type", function () {
            chai_1.expect(function () { return errors.throwIfNotType(4, "string", "argName"); }).to.throw(errors.ArgumentTypeError, "Argument Error (argName): Expected type 'string', but was 'number'.");
        });
        it("should not throw when the same type", function () {
            chai_1.expect(function () { return errors.throwIfNotType("", "string", "argName"); }).to.not.throw();
        });
    });
    describe("throwIfNotStringOrWhitespace", function () {
        it("should throw when not a string", function () {
            chai_1.expect(function () { return errors.throwIfNotStringOrWhitespace(4, "argName"); }).to.throw(errors.ArgumentTypeError, "Argument Error (argName): Expected type 'string', but was 'number'.");
        });
        it("should throw when null", function () {
            chai_1.expect(function () { return errors.throwIfNotStringOrWhitespace(null, "argName"); }).to.throw(errors.ArgumentTypeError, "Argument Error (argName): Expected type 'string', but was 'object'.");
        });
        it("should throw when whitespace string", function () {
            chai_1.expect(function () { return errors.throwIfNotStringOrWhitespace(" ", "argName"); }).to.throw(errors.ArgumentNullOrWhitespaceError, "Argument Error (argName): Cannot be null or whitespace.");
        });
        it("should throw when string that's not a whitespace string", function () {
            chai_1.expect(function () { return errors.throwIfNotStringOrWhitespace("str", "argName"); }).to.not.throw();
        });
    });
    describe("throwIfNotSyntaxKind", function () {
        var firstChild = testHelpers_1.getInfoFromText("class Identifier {}").firstChild;
        it("should throw when not the expected syntax kind and no message is specified", function () {
            chai_1.expect(function () { return errors.throwIfNotSyntaxKind(firstChild, typescript_1.SyntaxKind.AbstractKeyword); })
                .to.throw(errors.NotImplementedError, "Expected node to be syntax kind AbstractKeyword, but was ClassDeclaration.");
        });
        it("should throw when not the expected syntax kind and a message is specified", function () {
            chai_1.expect(function () { return errors.throwIfNotSyntaxKind(firstChild, typescript_1.SyntaxKind.AbstractKeyword, "message"); })
                .to.throw(errors.NotImplementedError, "message");
        });
        it("should not throw when is the expected syntax kind", function () {
            chai_1.expect(function () { return errors.throwIfNotSyntaxKind(firstChild, typescript_1.SyntaxKind.ClassDeclaration); })
                .to.not.throw();
        });
    });
    describe("throwIfOutOfRange", function () {
        it("should not throw when inside the bounds", function () {
            chai_1.expect(function () { return errors.throwIfOutOfRange(5, [1, 10], "arg"); }).to.not.throw();
        });
        it("should throw when outside the inclusive lower bound", function () {
            chai_1.expect(function () { return errors.throwIfOutOfRange(0, [1, 10], "arg"); }).to.throw();
        });
        it("should not throw when inside the inclusive lower bound", function () {
            chai_1.expect(function () { return errors.throwIfOutOfRange(1, [1, 10], "arg"); }).to.not.throw();
        });
        it("should throw when outside the inclusive upper bound", function () {
            chai_1.expect(function () { return errors.throwIfOutOfRange(11, [1, 10], "arg"); }).to.throw();
        });
        it("should not throw when inside the inclusive upper bound", function () {
            chai_1.expect(function () { return errors.throwIfOutOfRange(10, [1, 10], "arg"); }).to.not.throw();
        });
    });
    describe("throwIfRangeOutOfRange", function () {
        it("should throw when the range is flipped", function () {
            chai_1.expect(function () { return errors.throwIfRangeOutOfRange([9, 2], [1, 10], "arg"); }).to.throw();
        });
        it("should not throw when inside the bounds", function () {
            chai_1.expect(function () { return errors.throwIfRangeOutOfRange([2, 9], [1, 10], "arg"); }).to.not.throw();
        });
        it("should throw when outside the inclusive lower bound", function () {
            chai_1.expect(function () { return errors.throwIfRangeOutOfRange([0, 9], [1, 10], "arg"); }).to.throw();
        });
        it("should not throw when inside the inclusive lower or upper bound", function () {
            chai_1.expect(function () { return errors.throwIfRangeOutOfRange([1, 10], [1, 10], "arg"); }).to.not.throw();
        });
        it("should throw when outside the inclusive upper bound", function () {
            chai_1.expect(function () { return errors.throwIfRangeOutOfRange([2, 11], [1, 10], "arg"); }).to.throw();
        });
    });
    describe("throwIfNegative", function () {
        it("should throw when negative", function () {
            chai_1.expect(function () { return errors.throwIfNegative(-1, "arg"); }).to.throw();
        });
        it("should not throw when positive", function () {
            chai_1.expect(function () { return errors.throwIfNegative(1, "arg"); }).to.not.throw();
        });
        it("should not throw when 0", function () {
            chai_1.expect(function () { return errors.throwIfNegative(0, "arg"); }).to.not.throw();
        });
    });
    describe("getNotImplementedForSyntaxKindError", function () {
        var result = errors.getNotImplementedForSyntaxKindError(typescript_1.SyntaxKind.EnumDeclaration);
        it("should return a NotImplementedError", function () {
            chai_1.expect(result).to.be.instanceOf(errors.NotImplementedError);
        });
        it("should have the correct message", function () {
            chai_1.expect(result.message).to.equal("Not implemented feature for syntax kind 'EnumDeclaration'.");
        });
    });
    describe("throwIfNotEqual", function () {
        it("should throw when not equal", function () {
            chai_1.expect(function () { return errors.throwIfNotEqual(1, 2, "New length should equal old length."); }).to.throw(errors.InvalidOperationError, "Expected 1 to equal 2. New length should equal old length.");
        });
        it("should not throw when equal", function () {
            chai_1.expect(function () { return errors.throwIfNotEqual(2, 2, "New length should equal old length."); }).to.not.throw();
        });
    });
    describe("throwIfTrue", function () {
        it("should throw when true", function () {
            chai_1.expect(function () { return errors.throwIfTrue(true, "message"); }).to.throw(errors.InvalidOperationError, "message");
        });
        it("should not throw when false", function () {
            chai_1.expect(function () { return errors.throwIfTrue(false, "message"); }).to.not.throw();
        });
    });
});
