"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var Project_1 = require("../Project");
var createWrappedNode_1 = require("../createWrappedNode");
var typescript_1 = require("../typescript");
var errors = require("../errors");
describe("createWrappedNode", function () {
    it("should throw an exception if passing in a node not created with setParentNodes set to true.", function () {
        var sourceFile = typescript_1.ts.createSourceFile("file.ts", "class MyClass {}", typescript_1.ScriptTarget.ES2016, false);
        var child;
        typescript_1.ts.forEachChild(sourceFile, function (node) { return child = node; });
        chai_1.expect(child.parent).to.equal(undefined);
        chai_1.expect(function () {
            createWrappedNode_1.createWrappedNode(child);
        }).to.throw(errors.InvalidOperationError, "Please ensure the node was created from a source file with 'setParentNodes' set to 'true'.");
    });
    it("should get a wrapped node", function () {
        var compilerSourceFile = typescript_1.ts.createSourceFile("file.ts", "class MyClass {}", typescript_1.ScriptTarget.ES2016, true);
        var child = compilerSourceFile.getChildren()[0];
        var node = createWrappedNode_1.createWrappedNode(child);
        var sourceFile = node.getSourceFile();
        chai_1.expect(node.getKind()).to.equal(typescript_1.SyntaxKind.SyntaxList);
        chai_1.expect(sourceFile.getClasses().length).to.equal(1);
    });
    it("should get a wrapped node when also providing the source file", function () {
        var compilerSourceFile = typescript_1.ts.createSourceFile("file.ts", "class MyClass {}", typescript_1.ScriptTarget.ES2016, true);
        var child = compilerSourceFile.getChildren()[0];
        var node = createWrappedNode_1.createWrappedNode(child, { sourceFile: compilerSourceFile });
        var sourceFile = node.getSourceFile();
        // testing for something arbitrary
        chai_1.expect(sourceFile.getClasses().length).to.equal(1);
    });
    it("should be able to provide compiler options", function () {
        var compilerSourceFile = typescript_1.ts.createSourceFile("file.ts", "class MyClass {}", typescript_1.ScriptTarget.ES2016, true);
        var child = compilerSourceFile.getChildren()[0];
        var compilerOptions = { target: typescript_1.ScriptTarget.ES2016 };
        var node = createWrappedNode_1.createWrappedNode(child, { compilerOptions: compilerOptions });
        chai_1.expect(node.global.compilerOptions).to.deep.equal(compilerOptions);
    });
    it("should be able to provide a type checker", function () {
        var project = new Project_1.Project({ useVirtualFileSystem: true });
        var sourceFile = project.createSourceFile("test.ts", "let s = '';");
        var typeChecker = project.getTypeChecker();
        var wrappedSourceFile = createWrappedNode_1.createWrappedNode(sourceFile.compilerNode, { typeChecker: typeChecker.compilerObject });
        chai_1.expect(wrappedSourceFile.getVariableDeclarationOrThrow("s").getType().getText()).to.equal("string");
    });
    it("should throw when getting the type and no type checker was provided", function () {
        var compilerSourceFile = typescript_1.ts.createSourceFile("file.ts", "let s = '';", typescript_1.ScriptTarget.ES2016, true);
        var wrappedSourceFile = createWrappedNode_1.createWrappedNode(compilerSourceFile);
        var expectedMessage = "A type checker is required for this operation. This might occur when manipulating or " +
            "getting type information from a node that was not added to a Project object and created via createWrappedNode. " +
            "Please submit a bug report if you don't believe a type checker should be required for this operation.";
        chai_1.expect(function () { return wrappedSourceFile.getVariableDeclarationOrThrow("s").getType(); }).to.throw(errors.InvalidOperationError, expectedMessage);
    });
});
