"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
var errors_1 = require("../../errors");
var utils_1 = require("../../utils");
function getFileSystemHostWithFiles(initialFiles, initialDirectories) {
    if (initialDirectories === void 0) { initialDirectories = []; }
    initialDirectories = initialDirectories.map(function (d) { return d[0] === "/" ? d : "/" + d; });
    var writeLog = [];
    var deleteLog = [];
    var syncWriteLog = [];
    var directories = __spread(initialDirectories);
    var files = new utils_1.KeyValueCache();
    initialFiles.forEach(function (file) {
        var filePath = file.filePath[0] === "/" ? file.filePath : "/" + file.filePath;
        files.set(filePath, file.text);
    });
    return {
        delete: function (path) {
            doDelete(path);
            return Promise.resolve();
        },
        deleteSync: function (path) {
            doDelete(path);
        },
        readFile: function (filePath) { return Promise.resolve(readFile(filePath)); },
        readFileSync: function (filePath) { return readFile(filePath); },
        writeFile: function (filePath, fileText) {
            writeLog.push({ filePath: filePath, fileText: fileText });
            files.set(filePath, fileText);
            return Promise.resolve();
        },
        readDirSync: function () { return []; },
        writeFileSync: function (filePath, fileText) {
            syncWriteLog.push({ filePath: filePath, fileText: fileText });
            files.set(filePath, fileText);
        },
        fileExists: function (filePath) {
            return Promise.resolve(files.has(filePath));
        },
        fileExistsSync: function (filePath) {
            return files.has(filePath);
        },
        getCurrentDirectory: function () { return "/"; },
        mkdir: function (dirPath) {
            directories.push(dirPath);
            return Promise.resolve();
        },
        mkdirSync: function (dirPath) { return directories.push(dirPath); },
        directoryExists: function (dirPath) { return Promise.resolve(directories.indexOf(dirPath) >= 0); },
        directoryExistsSync: function (dirPath) { return directories.indexOf(dirPath) >= 0; },
        glob: function (patterns) { return []; },
        getSyncWriteLog: function () { return __spread(syncWriteLog); },
        getWriteLog: function () { return __spread(writeLog); },
        getDeleteLog: function () { return __spread(deleteLog); },
        getFiles: function () { return utils_1.ArrayUtils.from(files.getEntries()); },
        getCreatedDirectories: function () { return __spread(directories).filter(function (path) { return initialDirectories.indexOf(path) === -1; }); }
    };
    function readFile(filePath) {
        if (!files.has(filePath))
            throw new errors_1.FileNotFoundError("Can't find file " + filePath + ".");
        return files.get(filePath) || "";
    }
    function doDelete(path) {
        deleteLog.push({ path: path });
        files.removeByKey(path);
        var dirIndex = directories.indexOf(path);
        if (dirIndex >= 0)
            directories.splice(dirIndex, 1);
    }
}
exports.getFileSystemHostWithFiles = getFileSystemHostWithFiles;
